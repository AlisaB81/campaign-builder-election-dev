require('dotenv').config()
const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const fs = require('fs');
const fsPromises = require('fs').promises;
const path = require('path');
const nodemailer = require('nodemailer');

// Centralized configuration (validates env vars on load)
const { env: config, mapbox: mapboxConfig } = require('./config');

// Import library utilities (Phase 0 refactoring)
const { logger, createLogger, errorHandler, asyncHandler, AppError } = require('./lib');

// Import database layer (Phase 2: PostgreSQL Foundation)
const { initializePool, runMigrations, isPostgresEnabled, isPostgresReady, setPgReady, campaignRepo, contactRepo } = require('./db');

// Twilio Configuration
const accountSid = config.TWILIO_ACCOUNT_SID;
const authToken = config.TWILIO_AUTH_TOKEN;
const twilioClient = require('twilio')(accountSid, authToken);

// System-wide phone number for 2FA; must be provided via environment variable
const SYSTEM_2FA_PHONE_NUMBER = config.SYSTEM_2FA_PHONE_NUMBER;

// SMTP email configuration - using mail.sw7ft.com

const expressLayouts = require('express-ejs-layouts');
const compression = require('compression');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

// Billing: Paddle only. Invoices/receipts are built outside the application.
const stripe = null; // Stripe not used - Paddle for purchases

// Import billing service (Phase 1)
console.log('Paddle env loaded:', {
  env: process.env.PADDLE_ENV,
  hasKey: !!process.env.PADDLE_API_KEY,
});

const cookieParser = require('cookie-parser');

// OpenAI Configuration
const OpenAI = require('openai');

// Initialize OpenAI client
const openai = new OpenAI({
    apiKey: config.OPENAI_API_KEY,
    timeout: 60000, // 60 second timeout
    maxRetries: 3,
    dangerouslyAllowBrowser: false
});

const fetch = require('node-fetch');
const multer = require('multer');
const ExcelJS = require('exceljs');

// Image Prompt Builder for two-stage AI image generation
const { 
    generateTemplateImage, 
    validateImageGenerationRequest, 
    SLOT_DEFAULT_SIZES 
} = require('./js/utils/imagePromptBuilder');

// Environment variables
const UNSPLASH_ACCESS_KEY = config.UNSPLASH_ACCESS_KEY;
const PHONE_NUMBER_PRICE_ID = config.PHONE_NUMBER_PRICE_ID;
const ENCRYPTION_KEY = config.ENCRYPTION_KEY;
const PADDLE_CLIENT_TOKEN =
  config.PADDLE_CLIENT_TOKEN ||
  process.env.PADDLE_CHECKOUT_CLIENT_TOKEN ||
  process.env.PADDLE_PUBLIC_CLIENT_TOKEN;
const PADDLE_WEBHOOK_SECRET = config.PADDLE_WEBHOOK_SECRET;

// Crypto utilities for field-level encryption (AES-256-GCM)
const crypto = require('crypto');

function getCipherKey() {
  if (!ENCRYPTION_KEY) return null;
  // Derive a 32-byte key from the provided string
  return crypto.createHash('sha256').update(ENCRYPTION_KEY).digest();
}

function encryptField(plaintext) {
  try {
    const key = getCipherKey();
    if (!key) {
      // No key configured; store as plain with marker to preserve compatibility
      return `plain:${plaintext}`;
    }
    const iv = crypto.randomBytes(12);
    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
    const encrypted = Buffer.concat([cipher.update(plaintext, 'utf8'), cipher.final()]);
    const authTag = cipher.getAuthTag();
    return `${iv.toString('base64')}:${authTag.toString('base64')}:${encrypted.toString('base64')}`;
  } catch {
    return null;
  }
}

function decryptField(stored) {
  try {
    if (stored == null) return null;
    if (typeof stored !== 'string') return null;
    if (stored.startsWith('plain:')) {
      return stored.slice('plain:'.length);
    }
    const key = getCipherKey();
    if (!key) {
      // Cannot decrypt without key
      return null;
    }
    const [ivB64, tagB64, dataB64] = stored.split(':');
    if (!ivB64 || !tagB64 || !dataB64) return null;
    const iv = Buffer.from(ivB64, 'base64');
    const authTag = Buffer.from(tagB64, 'base64');
    const encrypted = Buffer.from(dataB64, 'base64');
    const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
    decipher.setAuthTag(authTag);
    const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);
    return decrypted.toString('utf8');
  } catch {
    return null;
  }
}

// Server configuration
// Use environment variable or detect from request for localhost
const getBaseUrl = (req) => {
  if (process.env.BASE_URL) return process.env.BASE_URL;
  if (process.env.IS_STAGING === 'true') {
    const port = process.env.PORT || 3081;
    return `http://localhost:${port}`;
  }
  // For production, use the request's host
  if (req) {
    const protocol = req.protocol || 'https';
    const host = req.get('host') || 'campaignbuilder.ca';
    return `${protocol}://${host}`;
  }
  return 'https://campaignbuilder.ca';
};

const BASE_URL = process.env.BASE_URL || (process.env.IS_STAGING === 'true' ? `http://localhost:${process.env.PORT || 3081}` : 'https://campaignbuilder.ca');
const DOMAIN = process.env.DOMAIN || (process.env.IS_STAGING === 'true' ? 'localhost' : 'campaignbuilder.ca');
const PROTOCOL = process.env.PROTOCOL || (process.env.IS_STAGING === 'true' ? 'http' : 'https');
const PORT = process.env.PORT || 3080;

// Phase 2: PostgreSQL init runs after server is listening (see listen callback below)

// JWT Secret - CRITICAL: No fallback allowed in production
const JWT_SECRET = config.JWT_SECRET;
if (!JWT_SECRET) {
    console.error('CRITICAL SECURITY ERROR: JWT_SECRET environment variable is required');
    process.exit(1);
}

// ================== KEYBOARD NAVIGATION UTILITIES ==================

const keyboardNavigationUtils = {
  // Generate focus trap JavaScript for modals
  generateFocusTrap: (modalId) => {
    return `
      (function() {
        const modal = document.getElementById('${modalId}');
        if (!modal) return;
        
        const focusableElements = modal.querySelectorAll(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];
        
        function trapFocus(e) {
          if (e.key === 'Tab') {
            if (e.shiftKey) {
              if (document.activeElement === firstElement) {
                lastElement.focus();
                e.preventDefault();
              }
            } else {
              if (document.activeElement === lastElement) {
                firstElement.focus();
                e.preventDefault();
              }
            }
          }
          if (e.key === 'Escape') {
            closeModal();
          }
        }
        
        modal.addEventListener('keydown', trapFocus);
        if (firstElement) firstElement.focus();
      })();
    `;
  },

  // Generate table navigation JavaScript
  generateTableNavigation: (tableId) => {
    return `
      (function() {
        const table = document.getElementById('${tableId}');
        if (!table) return;
        
        const rows = table.querySelectorAll('tbody tr');
        let currentRow = 0;
        let currentCell = 0;
        
        function highlightCell(row, cell) {
          // Remove previous highlights
          table.querySelectorAll('.keyboard-focus').forEach(el => el.classList.remove('keyboard-focus'));
          
          const targetRow = rows[row];
          if (targetRow) {
            const cells = targetRow.querySelectorAll('td, th');
            if (cells[cell]) {
              cells[cell].classList.add('keyboard-focus');
              cells[cell].scrollIntoView({ block: 'nearest' });
              
              // Focus on interactive elements within cell
              const interactive = cells[cell].querySelector('button, input, select, a');
              if (interactive) interactive.focus();
            }
          }
        }
        
        table.addEventListener('keydown', function(e) {
          const maxRows = rows.length - 1;
          const currentRowElement = rows[currentRow];
          const maxCells = currentRowElement ? currentRowElement.querySelectorAll('td, th').length - 1 : 0;
          
          switch(e.key) {
            case 'ArrowUp':
              e.preventDefault();
              if (currentRow > 0) {
                currentRow--;
                highlightCell(currentRow, currentCell);
              }
              break;
            case 'ArrowDown':
              e.preventDefault();
              if (currentRow < maxRows) {
                currentRow++;
                highlightCell(currentRow, currentCell);
              }
              break;
            case 'ArrowLeft':
              e.preventDefault();
              if (currentCell > 0) {
                currentCell--;
                highlightCell(currentRow, currentCell);
              }
              break;
            case 'ArrowRight':
              e.preventDefault();
              if (currentCell < maxCells) {
                currentCell++;
                highlightCell(currentRow, currentCell);
              }
              break;
            case 'Enter':
            case ' ':
              e.preventDefault();
              const cell = rows[currentRow]?.querySelectorAll('td, th')[currentCell];
              const button = cell?.querySelector('button, a');
              if (button) button.click();
              break;
          }
        });
        
        // Initialize first cell focus
        if (rows.length > 0) {
          table.setAttribute('tabindex', '0');
          highlightCell(0, 0);
        }
      })();
    `;
  },

  // Generate form navigation JavaScript
  generateFormNavigation: () => {
    return `
      (function() {
        // Enhanced form navigation
        document.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' && e.target.type !== 'textarea') {
            // Find next focusable element
            const focusable = Array.from(document.querySelectorAll(
              'input:not([disabled]), button:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
            ));
            const currentIndex = focusable.indexOf(e.target);
            const nextElement = focusable[currentIndex + 1];
            
            if (nextElement) {
              e.preventDefault();
              nextElement.focus();
            }
          }
        });
        
        // Add visual focus indicators
        document.addEventListener('focusin', function(e) {
          e.target.classList.add('keyboard-focused');
        });
        
        document.addEventListener('focusout', function(e) {
          e.target.classList.remove('keyboard-focused');
        });
      })();
    `;
  },

  // Generate accessibility CSS
  generateAccessibilityCSS: () => {
    return `
      <style>
        /* Keyboard Focus Indicators */
        .keyboard-focused,
        *:focus {
          outline: 3px solid #3b82f6 !important;
          outline-offset: 2px !important;
          box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3) !important;
        }
        
        /* Table keyboard navigation */
        .keyboard-focus {
          background-color: #dbeafe !important;
          outline: 2px solid #3b82f6 !important;
        }
        
        /* Skip to content link */
        .skip-link {
          position: absolute;
          top: -40px;
          left: 6px;
          background: #000;
          color: #fff;
          padding: 8px;
          text-decoration: none;
          z-index: 1000;
          border-radius: 0 0 4px 4px;
        }
        
        .skip-link:focus {
          top: 0;
        }
        
        /* Accessible button states */
        button:focus,
        .btn:focus {
          outline: 3px solid #3b82f6 !important;
          outline-offset: 2px !important;
        }
        
        /* Modal accessibility */
        .modal[aria-hidden="true"] {
          display: none;
        }
        
        .modal[aria-hidden="false"] {
          display: block;
        }
        
        /* Screen reader only text */
        .sr-only {
          position: absolute;
          width: 1px;
          height: 1px;
          padding: 0;
          margin: -1px;
          overflow: hidden;
          clip: rect(0, 0, 0, 0);
          white-space: nowrap;
          border: 0;
        }
        
        /* High contrast mode support */
        @media (prefers-contrast: high) {
          .keyboard-focused,
          *:focus {
            outline: 4px solid #000 !important;
            background-color: #fff !important;
            color: #000 !important;
          }
        }
        
        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
          * {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
          }
        }
      </style>
    `;
  }
};

const app = express();

// Trust proxy for rate limiting and IP detection (needed for reverse proxy setup)
app.set('trust proxy', 1);
app.set('layout', 'layout');
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// Health check - no auth, no DB; use to verify server is responsive
app.get('/health', (req, res) => {
  res.status(200).set('Content-Type', 'text/plain').send('ok');
});

// API health check (JSON) for programmatic checks
app.get('/api/health', (req, res) => {
  res.status(200).json({ ok: true, ts: new Date().toISOString() });
});

// Cookie parser MUST run first so we can check token for GET /
app.use(cookieParser());

// Canonical login route: render auth page without app layout.
// Keep this route before heavy middleware so login never gets blocked by app bootstrap logic.
app.get(['/login', '/login/'], (req, res) => {
  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0');
  res.setHeader('Pragma', 'no-cache');
  res.setHeader('Expires', '0');
  return res.render('login', {
    layout: false,
    path: '/login'
  });
});

app.get("/", (req, res) => {
  // unauthenticated -> go to login
  if (!req.user && !req.session?.userId) {
    return res.redirect("/login");
  }

  // authenticated -> go to app
  return res.redirect("/dashboard");
});

// Middleware
// Capture raw body for signature verification (e.g. Paddle webhooks)
app.use(express.json({
  limit: '50mb',
  verify: (req, res, buf) => {
    req.rawBody = buf;
  }
}));

app.use(expressLayouts);
app.use(express.urlencoded({ extended: true, limit: '50mb' }));
// Enhanced security headers configuration
app.use(helmet({
  contentSecurityPolicy: false, // We handle CSP manually
  crossOriginEmbedderPolicy: false, // Disable for compatibility
  // Set HSTS explicitly in production-only middleware below.
  hsts: false,
  xFrameOptions: { action: 'deny' },
  xContentTypeOptions: true,
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
  permissionsPolicy: {
    camera: [],
    microphone: [],
    geolocation: [],
    payment: [],
    usb: []
  }
}));

// Apply HSTS only for production HTTPS requests.
app.use((req, res, next) => {
  const host = (req.get('host') || '').toLowerCase();
  const isLocalhost = host.includes('localhost') || host.includes('127.0.0.1');
  const isStaging = process.env.IS_STAGING === 'true' || process.env.IS_ELECTION_DEV === 'true';
  const isHttps = req.secure || req.get('x-forwarded-proto') === 'https';
  if (!isLocalhost && !isStaging && isHttps) {
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
  }
  next();
});

// Secure CSP configuration - balanced security with Tailwind CSS compatibility
app.use((req, res, next) => {
  // Generate nonce for inline scripts (if needed)
  const nonce = crypto.randomBytes(16).toString('base64');
  res.locals.nonce = nonce;
  
  // Build CSP with localhost support for staging
  const isLocalhost = req.get('host') && (req.get('host').includes('localhost') || req.get('host').includes('127.0.0.1'));
  const isStaging = process.env.IS_STAGING === 'true' || process.env.IS_ELECTION_DEV === 'true';
  
  // Disable caching for localhost/staging to ensure fresh content
  if (isLocalhost || isStaging) {
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate, private');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
  }
  
  const cspStyleSrc = isLocalhost 
    ? "'self' 'unsafe-inline' https://cdn.tailwindcss.com https://api.mapbox.com https://cdn.paddle.com http://localhost:* https://campaignbuilder.ca"
    : "'self' 'unsafe-inline' https://cdn.tailwindcss.com https://api.mapbox.com https://cdn.paddle.com https://campaignbuilder.ca";
  const cspConnectSrc = isLocalhost
    ? "'self' https: http://localhost:*"
    : "'self' https:";
  
  res.setHeader('Content-Security-Policy',
    "default-src 'self' https: data: blob:; " +
    "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.paddle.com https://public.profitwell.com https://unpkg.com https://cdn.tailwindcss.com https://api.mapbox.com http://localhost:* https://campaignbuilder.ca blob:; " +
    "script-src-elem 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.paddle.com https://public.profitwell.com https://unpkg.com https://cdn.tailwindcss.com https://api.mapbox.com http://localhost:* https://campaignbuilder.ca; " +
    "script-src-attr 'unsafe-inline'; " +
    "worker-src 'self' blob:; " +
    "img-src 'self' data: blob: https: http://localhost:*; " +
    `style-src ${cspStyleSrc}; ` +
    `connect-src ${cspConnectSrc}; ` +
    "frame-src https://cdn.paddle.com https://buy.paddle.com https://*.paddle.com; " +
    "font-src 'self' data: https: http://localhost:*"
  );
  next();
});
// Comprehensive rate limiting for different endpoint types
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // Reduced for auth endpoints
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Too many authentication attempts, please try again later.',
  skipSuccessfulRequests: true
});

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 200, // Higher limit for general API calls
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Too many API requests, please try again later.'
});

const uploadLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 20, // Limit file uploads per hour
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Too many file uploads, please try again later.'
});

const strictLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 5, // Very strict for sensitive operations
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Too many requests, please wait before trying again.'
});

const adminLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // More lenient for admin operations
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Too many admin requests, please try again later.'
});

const emailSendLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 500, // High limit for email campaigns per hour per user
  standardHeaders: true,
  legacyHeaders: false,
  message: 'Too many email sending requests. Please wait before sending another campaign.',
  keyGenerator: (req) => {
    // Rate limit per user if authenticated, otherwise per IP
    return req.user ? req.user.id.toString() : req.ip;
  }
});

// Apply rate limiting to specific endpoint groups
app.use(['/api/login', '/api/forgot-password', '/api/register'], authLimiter);
app.use(['/api/templates/upload-image', '/api/images/upload'], uploadLimiter);
app.use(['/api/delete'], strictLimiter);
app.use(['/api/admin'], adminLimiter);
app.use('/api/messages/send-email', emailSendLimiter);
app.use('/api', apiLimiter);

// Input validation and sanitization middleware
const inputValidationMiddleware = (req, res, next) => {
    // Sanitize string inputs to prevent XSS and injection attacks
    const sanitizeString = (str) => {
        if (typeof str !== 'string') return str;
        return str
            .replace(/[<>]/g, '') // Remove potential HTML tags
            .replace(/['"]/g, '') // Remove quotes to prevent injection
            .replace(/[;]/g, '') // Remove semicolons
            .trim();
    };

    // Sanitize request body
    if (req.body && typeof req.body === 'object') {
        for (const key in req.body) {
            if (typeof req.body[key] === 'string') {
                req.body[key] = sanitizeString(req.body[key]);
            }
        }
    }

    // Sanitize query parameters
    if (req.query && typeof req.query === 'object') {
        for (const key in req.query) {
            if (typeof req.query[key] === 'string') {
                req.query[key] = sanitizeString(req.query[key]);
            }
        }
    }

    // Validate common input patterns
    const validateEmail = (email) => {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    };

    const validatePhone = (phone) => {
        const phoneRegex = /^\+?[\d\s\-\(\)]+$/;
        return phoneRegex.test(phone) && phone.replace(/\D/g, '').length >= 10;
    };

    // Add validation functions to request object for use in routes
    req.validateEmail = validateEmail;
    req.validatePhone = validatePhone;
    req.sanitizeString = sanitizeString;

    next();
};

// Password validation utility
const validatePassword = (password) => {
    const errors = [];
    
    if (password.length < 8) {
        errors.push('Password must be at least 8 characters long');
    }
    
    if (!/[A-Z]/.test(password)) {
        errors.push('Password must contain at least one uppercase letter');
    }
    
    if (!/[a-z]/.test(password)) {
        errors.push('Password must contain at least one lowercase letter');
    }
    
    if (!/\d/.test(password)) {
        errors.push('Password must contain at least one number');
    }
    
    if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
        errors.push('Password must contain at least one special character');
    }
    
    // Check for common weak passwords
    const commonPasswords = [
        'password', '123456', 'password123', 'admin', 'qwerty',
        'letmein', 'welcome', 'monkey', 'dragon', 'master'
    ];
    
    if (commonPasswords.some(common => password.toLowerCase().includes(common))) {
        errors.push('Password contains common words and is not secure');
    }
    
    return {
        isValid: errors.length === 0,
        errors: errors
    };
};

// Security event logging utility
const logSecurityEvent = async (eventType, details, req = null) => {
  try {
    const logEntry = {
      timestamp: new Date().toISOString(),
      eventType,
      details,
      ip: req ? req.ip : 'unknown',
      userAgent: req ? req.get('User-Agent') : 'unknown',
      url: req ? req.url : 'unknown',
      method: req ? req.method : 'unknown',
      userId: req && req.user ? req.user.id : null
    };

    // Log to console for immediate visibility

    // Log to file for audit trail
    const logDir = path.join(__dirname, 'data', 'security-logs');
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }

    const logFile = path.join(logDir, `security-${new Date().toISOString().split('T')[0]}.json`);
    let logs = [];
    
    if (fs.existsSync(logFile)) {
      try {
        logs = JSON.parse(fs.readFileSync(logFile, 'utf8'));
      } catch (e) {
        console.error('Error reading security log:', e);
      }
    }
    
    logs.push(logEntry);
    fs.writeFileSync(logFile, JSON.stringify(logs, null, 2));
  } catch (error) {
    console.error('Error writing security log:', error);
  }
};

// Security monitoring middleware
const securityMonitoringMiddleware = (req, res, next) => {
  // Log suspicious activities
  const suspiciousPatterns = [
    /\.\./, // Path traversal attempts
    /<script/i, // XSS attempts
    /union.*select/i, // SQL injection attempts
    /javascript:/i, // JavaScript injection
    /eval\(/i, // Code injection
    /base64/i // Potential encoding attacks
  ];

  const requestData = JSON.stringify(req.body) + JSON.stringify(req.query) + req.url;
  
  for (const pattern of suspiciousPatterns) {
    if (pattern.test(requestData)) {
      logSecurityEvent('SUSPICIOUS_REQUEST', {
        pattern: pattern.toString(),
        requestData: requestData.substring(0, 500) // Limit log size
      }, req);
      break;
    }
  }

  // Log authentication attempts
  if (req.url.includes('/api/login') || req.url.includes('/api/register')) {
    logSecurityEvent('AUTH_ATTEMPT', {
      endpoint: req.url,
      hasBody: !!req.body
    }, req);
  }

  // Log file uploads
  if (req.url.includes('/upload')) {
    logSecurityEvent('FILE_UPLOAD_ATTEMPT', {
      endpoint: req.url,
      contentType: req.get('Content-Type')
    }, req);
  }

  next();
};

// Apply input validation to all routes except endpoints that need HTML content
app.use((req, res, next) => {
    // Skip sanitization for endpoints that need HTML content preserved
    // - Email sending: HTML email content
    // - Templates: HTML in footerText, bodyElements, etc.
    // SMS should remain sanitized since it's plain text only
    const htmlAllowedPaths = [
        '/api/messages/send-email',
        '/api/templates'
    ];
    
    if (htmlAllowedPaths.some(path => req.path.startsWith(path))) {
        return next();
    }
    return inputValidationMiddleware(req, res, next);
});

// Apply security monitoring
app.use(securityMonitoringMiddleware);

// Redirect to login â€“ API / JSON never get 302
function redirectToLogin(res, req, src, code, extra = {}) {
  const isApi = req.originalUrl?.startsWith('/api/') || req.path?.startsWith('/api/');
  const wantsJson = (req.get('accept') || '').includes('application/json');
  if (isApi || wantsJson) {
    return res.status(401).json({
      ok: false,
      error: 'AUTH_REQUIRED',
      message: 'Authentication required'
    });
  }
  return res.redirect('/login');
}

// Secure error handling middleware
const secureErrorHandler = (err, req, res, next) => {
    console.error('Application Error:', {
        message: err.message,
        stack: err.stack,
        url: req.url,
        method: req.method,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        timestamp: new Date().toISOString()
    });

    // Don't expose internal errors to clients
    const isDevelopment = process.env.NODE_ENV === 'development';
    
    const wantsHtml = req.accepts('html') || (req.method === 'GET' && !req.xhr && !req.path.startsWith('/api/'));
    if (wantsHtml) {
        // Only redirect to login for explicit auth errors (401/403). Do NOT redirect 500 or unset status
        // so that template/compile errors show an error page instead of masquerading as a login loop.
        if (err.status === 401 || err.status === 403) {
            return redirectToLogin(res, req, 'secureErrorHandler', 'HTML_ERR', { status: String(err.status) });
        }
        // All other statuses (404, 500, unset): render error page in HTML
        const statusCode = err.status || 500;
        const message = isDevelopment ? err.message : 'An error occurred. Please try again.';
        return res.status(statusCode).send(`
            <!DOCTYPE html>
            <html>
            <head>
                <title>Error ${statusCode}</title>
                <meta charset="UTF-8">
                <style>
                    body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
                    h1 { color: #e74c3c; }
                    p { color: #666; }
                </style>
            </head>
            <body>
                <h1>Error ${statusCode}</h1>
                <p>${message}</p>
                ${isDevelopment && err.stack ? `<pre style="text-align: left; background: #f5f5f5; padding: 20px; border-radius: 5px;">${err.stack}</pre>` : ''}
                <p><a href="/login">Return to Login</a></p>
            </body>
            </html>
        `);
    } else {
        // For API requests, return generic error messages
        const statusCode = err.status || 500;
        const message = isDevelopment ? err.message : 'An error occurred';
        
        res.status(statusCode).json({
            error: message,
            ...(isDevelopment && { details: err.stack })
        });
    }
};

// Enable gzip/brotli compression (safe default)
app.use(compression());

// BaseUrl and view locals (billing via Paddle; no Stripe)
app.use((req, res, next) => {
  res.locals.STRIPE_PUBLIC_KEY = '';
  res.locals.baseUrl = getBaseUrl(req);
  // Pass IS_STAGING to templates for base tag logic
  res.locals.IS_STAGING = process.env.IS_STAGING === 'true';
  res.locals.isLocalhost = req.get('host') && (req.get('host').includes('localhost') || req.get('host').includes('127.0.0.1'));
  next();
});

app.use('/uploads', (req, res, next) => {
    // Secure CORS configuration - only allow trusted domains
    const allowedOrigins = [
        'https://campaignbuilder.ca',
        'https://www.campaignbuilder.ca',
        'http://localhost:3080',
        'http://127.0.0.1:3080',
        'http://localhost:3081',
        'http://127.0.0.1:3081'
    ];
    
    const origin = req.headers.origin;
    if (allowedOrigins.includes(origin)) {
        res.header('Access-Control-Allow-Origin', origin);
    }
    
    res.header('Access-Control-Allow-Methods', 'GET');
    res.header('Access-Control-Allow-Headers', 'Content-Type');
    next();
}, express.static(path.join(__dirname, 'public/uploads')));

// Static file serving with no-cache for localhost/staging
const isStaging = process.env.IS_STAGING === 'true' || process.env.IS_ELECTION_DEV === 'true';
if (isStaging) {
  app.use(express.static('public', {
    setHeaders: (res, path) => {
      res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate, private');
      res.setHeader('Pragma', 'no-cache');
      res.setHeader('Expires', '0');
    }
  }));
} else {
  app.use(express.static('public'));
}

// Database operations
const dbPath = path.join(__dirname, 'data', 'db.json');
const INDIVIDUAL_DATA_DIR = path.join(__dirname, 'data', 'individual-data');
const ACCOUNTS_DIR = path.join(__dirname, 'data', 'accounts');
const SHARED_DATA_DIR = path.join(__dirname, 'data', 'shared-data');

// Pending email opens queue - stores opens that arrived before campaign was saved
const pendingEmailOpens = new Map(); // Map<campaignId, Array<openEvent>>

// Process pending opens every 10 seconds
setInterval(async () => {
    if (pendingEmailOpens.size === 0) return;
    
    for (const [campaignKey, opens] of pendingEmailOpens.entries()) {
        const [accountId, msgId] = campaignKey.split(':');
        if (!accountId || !msgId) continue;
        
        try {
            const emailCampaignsPath = path.join(SHARED_DATA_DIR, accountId, 'email-campaigns.json');
            if (!fs.existsSync(emailCampaignsPath)) continue;
            
            const emailMessages = JSON.parse(fs.readFileSync(emailCampaignsPath, 'utf8'));
            let msg = emailMessages.find(m => m.id === msgId);
            
            // Try fuzzy matching by timestamp
            if (!msg) {
                const msgTimestamp = parseInt(msgId.split('-')[0]);
                if (!isNaN(msgTimestamp)) {
                    const nearbyCampaigns = emailMessages.filter(m => {
                        const campaignTimestamp = parseInt(m.id.split('-')[0]);
                        return Math.abs(campaignTimestamp - msgTimestamp) < 60000; // Within 1 minute
                    });
                    if (nearbyCampaigns.length > 0) msg = nearbyCampaigns[0];
                }
            }
            
            if (msg) {
                if (!msg.opens) msg.opens = [];
                msg.opens.push(...opens);
                await fsPromises.writeFile(emailCampaignsPath, JSON.stringify(emailMessages, null, 2));
                console.log(`[EMAIL-OPEN-TRACKING] Processed ${opens.length} pending opens for campaign ${msgId}`);
                pendingEmailOpens.delete(campaignKey);
            }
        } catch (error) {
            // Will retry on next interval
            console.error(`[EMAIL-OPEN-TRACKING] Error processing pending opens for ${campaignKey}:`, error.message);
        }
    }
}, 10000);

// Ensure users directory exists

const readDB = async () => {
  try {
    const data = await fsPromises.readFile(dbPath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    // Enhanced default structure with embedded documents
    return { 
      systemMessages: [], 
      systemSettings: {
        version: "2.0",
        migratedAt: new Date().toISOString()
      }
    };
  }
};

const writeDB = async (data) => {
  await fsPromises.writeFile(dbPath, JSON.stringify(data, null, 2), 'utf8');
};

const getAllUserIds = async () => {
  try {
    // Get user IDs from individual-data system only
    const userIds = new Set();
    const entries = await fsPromises.readdir(INDIVIDUAL_DATA_DIR);
    
    for (const entry of entries) {
      try {
        const entryPath = path.join(INDIVIDUAL_DATA_DIR, entry);
        const stat = await fsPromises.stat(entryPath);
        
        if (stat.isDirectory()) {
          // New structure: directory name is userId
          const userFile = path.join(entryPath, 'user.json');
          try {
            await fsPromises.access(userFile);
            userIds.add(entry);
          } catch (error) {
            // user.json doesn't exist in this directory
          }
        } else if (stat.isFile() && entry.endsWith('.json')) {
          // Old structure: filename is userId.json
          const userId = entry.replace(/\.json$/, '');
          userIds.add(userId);
        }
      } catch (error) {
        // Skip entries that can't be processed
        continue;
      }
    }
    
    return Array.from(userIds);
  } catch (error) {
    return [];
  }
};

// Database migration function to fix user schema inconsistencies
const migrateUserSchema = async (userId) => {
  try {
    const user = await readUserFileRaw(userId);
    if (!user) return null;
    
    let needsUpdate = false;
    
    // Define the complete schema with default values in the correct order (including multi-user fields)
    const completeSchema = {
      id: user.id,
      email: user.email,
      username: user.username || null,
      password: user.password,
      verificationToken: user.verificationToken || null,
      isVerified: user.isVerified !== undefined ? user.isVerified : false,
      is2FAEnabled: user.is2FAEnabled !== undefined ? user.is2FAEnabled : false,
      
      // Multi-user fields
      userType: user.userType || null, // 'app_owner' | 'account_holder' | 'team_member'
      accountId: user.accountId || null, // Links to account (null for app_owners)
      invitedBy: user.invitedBy || null, // User ID who invited this user (for team_members)
      
      // Personal information
      personalInfo: user.personalInfo || {
        firstName: user.firstName || '',
        lastName: user.lastName || '',
        phone: user.phone || ''
      },
      
      // Legacy fields (will be moved to account level during migration)
      tokenBalance: user.tokenBalance !== undefined ? user.tokenBalance : 0,
      contacts: user.contacts || [],
      autoReply: user.autoReply || { isEnabled: false, message: '' },
      smsMessages: user.smsMessages || { sent: [], received: [] },
      tokenTransactions: user.tokenTransactions || [],
      messages: user.messages || [],
      invoices: user.invoices || [],
      smsTokens: user.smsTokens !== undefined ? user.smsTokens : 0,
      emailTokens: user.emailTokens !== undefined ? user.emailTokens : 0,
      phoneNumbers: user.phoneNumbers || [],
      
      // System fields
      isAdmin: user.isAdmin !== undefined ? user.isAdmin : false,
      createdAt: user.createdAt || new Date().toISOString(),
      lastLoginAt: user.lastLoginAt || null,
      company: user.company || null
    };
    
    // Check if any fields are missing or in wrong order
    const currentKeys = Object.keys(user);
    const expectedKeys = Object.keys(completeSchema);
    
    // Check for missing fields
    const missingFields = expectedKeys.filter(key => !currentKeys.includes(key));
    if (missingFields.length > 0) {
      needsUpdate = true;
    }
    
    // Check if fields are in wrong order (optional, but helps with consistency)
    const isOrderCorrect = expectedKeys.every((key, index) => currentKeys[index] === key);
    if (!isOrderCorrect) {
      needsUpdate = true;
    }
    
    // Add company field if it doesn't exist
    if (user.company === undefined) {
      needsUpdate = true;
    }
    
    // Add username field if it doesn't exist
    if (user.username === undefined) {
      needsUpdate = true;
    }
    
    // Update the file if needed
    if (needsUpdate) {
      await writeIndividualUserFile(userId, completeSchema);
    }
    
    return completeSchema;
  } catch (error) {
    return null;
  }
};

// Migrate all existing users
// const migrateAllUsers = async () => {
//   try {
//     //     const userIds = await getAllUserIds();
//     let migratedCount = 0;
//     
//     for (const userId of userIds) {
//       try {
//         await migrateUserSchema(userId);
//         migratedCount++;
//       } catch (error) {
//         console.error(`Failed to migrate user ${userId}:`, error);
//       }
//     }
//     
//     //   } catch (error) {
//     console.error('Database migration failed:', error);
//   }
// };

// Account management functions
const accountsDir = path.join(__dirname, 'data', 'accounts');

const ensureAccountsDir = async () => {
  try {
    await fsPromises.access(accountsDir);
  } catch (error) {
    if (error.code === 'ENOENT') {
      await fsPromises.mkdir(accountsDir, { recursive: true });
    }
  }
};

const createAccount = async (accountData) => {
  await ensureAccountsDir();
  const accountId = accountData.id || Date.now().toString();
  const accountPath = path.join(accountsDir, `${accountId}.json`);
  
  const account = {
    id: accountId,
    ownerId: accountData.ownerId,
    companyInfo: accountData.companyInfo || null,
    contacts: accountData.contacts || [],
    campaigns: accountData.campaigns || [],
    messageTemplates: accountData.messageTemplates || [],
    tokens: {
      smsTokens: accountData.tokens?.smsTokens || 0,
      emailTokens: accountData.tokens?.emailTokens || 0,
      aiTokens: accountData.tokens?.aiTokens || 0
    },
    phoneNumbers: accountData.phoneNumbers || [],
    billing: accountData.billing || {},
    invoices: accountData.invoices || [],
    senderEmails: accountData.senderEmails || [],
    createdAt: accountData.createdAt || new Date().toISOString(),
    isActive: accountData.isActive !== undefined ? accountData.isActive : true,
    plan: accountData.plan || 'basic'
  };
  
  await fsPromises.writeFile(accountPath, JSON.stringify(account, null, 2), 'utf8');
  return account;
};

const getAccount = async (accountId) => {
  try {
    const accountPath = path.join(accountsDir, `${accountId}.json`);
    const data = await fsPromises.readFile(accountPath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    if (error.code === 'ENOENT') {
      return null;
    }
    throw error;
  }
};

const updateAccount = async (accountId, accountData) => {
  await ensureAccountsDir();
  const accountPath = path.join(accountsDir, `${accountId}.json`);
  await fsPromises.writeFile(accountPath, JSON.stringify(accountData, null, 2), 'utf8');
  return accountData;
};

const getUsersByAccount = async (accountId) => {
  const userIds = await getAllUserIds();
  const users = [];
  
  for (const userId of userIds) {
    const user = await findUserById(userId);
    if (user && user.accountId === accountId) {
      users.push(user);
    }
  }
  
  return users;
};

const getAllAccountIds = async () => {
  try {
    await ensureAccountsDir();
    const files = await fsPromises.readdir(accountsDir);
    return files.filter(file => file.endsWith('.json')).map(file => file.replace('.json', ''));
  } catch (error) {
    return [];
  }
};

// Migration function for multi-user system
const migrateToMultiUserSystem = async () => {
  try {
    // Ensure accounts directory exists
    await ensureAccountsDir();
    
    // Get all user files
    const userFiles = await fsPromises.readdir(usersDir);
    const jsonFiles = userFiles.filter(file => file.endsWith('.json') && !file.includes('backup'));
    
    // Define app owners (these two users have full system access)
    const APP_OWNERS = ['1750698273468', '1739581379147']; // Alisa & Matt
    
    for (const file of jsonFiles) {
      const userId = file.replace('.json', '');
      
      try {
        const user = await findUserById(userId);
        
        if (APP_OWNERS.includes(userId)) {
          // Migrate app owners - they have ALL privileges including admin access
          user.userType = 'app_owner';
          user.accountId = null; // App owners don't belong to specific accounts
          user.invitedBy = null;
          user.permissions = ['*']; // Full system access
          
        } else {
          // Migrate regular users as account holders - all privileges except admin access
          user.userType = 'account_holder';
          user.accountId = userId; // Each user becomes their own account holder
          user.invitedBy = null;
          user.permissions = [
            'manage_account', 'manage_contacts', 'manage_campaigns', 'manage_templates',
            'view_analytics', 'access_billing', 'manage_tokens', 'manage_settings',
            'delete_account', 'invite_users', 'manage_users'
          ];
          
          // Create an account for this user
          const accountData = {
            id: userId,
            ownerId: userId,
            companyInfo: user.company || null,
            contacts: user.contacts || [],
            campaigns: user.campaigns || [],
            autoReply: user.autoReply || { isEnabled: false, message: '' },
            smsMessages: user.smsMessages || { sent: [], received: [] },
            tokenTransactions: user.tokenTransactions || [],
            messages: user.messages || [],
            invoices: user.invoices || [],
            smsTokens: user.smsTokens || { count: 0, lastUpdated: Date.now() },
            emailTokens: user.emailTokens || { count: 0, lastUpdated: Date.now() },
            createdAt: user.createdAt || Date.now(),
            updatedAt: Date.now()
          };
          
          await createAccount(accountData);
          
        }
        
        // Save updated user
        await writeIndividualUserFile(userId, user);
        
      } catch (error) {
      }
    }
    
    return { success: true, message: 'Multi-user migration completed' };
    
  } catch (error) {
    return { success: false, error: error.message };
  }
};

// Account type constants
const ACCOUNT_TYPES = {
  EDA: 'eda',           // EDA accounts - no subscription required
  APP_OWNER: 'app_owner', // System admins - no subscription required  
  REG_CLIENT: 'reg_client' // Regular clients - subscription required
};

const SUBSCRIPTION_STATUS = {
  ACTIVE: 'active',
  TRIAL: 'trial', 
  EXPIRED: 'expired',
  NONE: 'none'
};

// Permission system constants
const USER_PERMISSIONS = {
  APP_OWNER: ['*'], // Full system access
  ACCOUNT_HOLDER: [
    'manage_account', 'manage_contacts', 'manage_campaigns', 'manage_templates',
    'view_analytics', 'access_billing', 'manage_tokens', 'manage_settings',
    'delete_account', 'invite_users', 'manage_users', 'view_invoices'
  ],
  USER: [
    'manage_contacts', 'manage_campaigns', 'manage_templates', 'view_analytics',
    'view_settings', 'send_campaigns', 'send_messages'
    // CANNOT: access_billing, manage_tokens, delete_account, invite_users, manage_users, delete_all_contacts
  ]
};

// Subscription checking functions
const requiresSubscription = async (user) => {
  if (!user) return true;
  
  // Team members inherit subscription status from their account holder
  if (user.userType === 'team_member' || (user.accountId && user.accountId !== user.id)) {
    try {
      // Get account holder's information
      const accountHolder = await findUserById(user.accountId);
      if (accountHolder) {
        // Recursively check account holder's subscription requirement
        return await requiresSubscription(accountHolder);
      }
    } catch (error) {
      console.error('Error checking account holder subscription:', error);
    }
  }
  
  // EDA and app_owner accounts don't need subscription
  if (user.accountType === ACCOUNT_TYPES.EDA || user.accountType === ACCOUNT_TYPES.APP_OWNER) {
    return false;
  }
  
  // Legacy app_owner userType also doesn't need subscription
  if (user.userType === 'app_owner') {
    return false;
  }
  
  // REG_CLIENT accounts need subscription
  if (user.accountType === ACCOUNT_TYPES.REG_CLIENT) {
    return true;
  }
  
  // Default to requiring subscription for safety
  return true;
};

// Import new account middleware (Phase 0 refactoring)
// Note: requireActiveAccount instance will be created after findUserById is defined
const accountMiddleware = require('./middleware/account');

// Import election middleware (Phase 3)
const electionMiddleware = require('./middleware/election');

// Import election service (Phase 3)
const electionService = require('./services/election');

// Import scrutineering service (Phase 4)
const scrutineeringService = require('./services/scrutineering');

// Import voter interactions service (Phase 4)
const voterInteractionsService = require('./services/voter-interactions');

// Import election lists service (Phase 4)
const electionListsService = require('./services/election-lists');

// Import election teams service (Phase 4: teams, roles, permissions, assignments)
const electionTeams = require('./services/election-teams');

// Import canvassing service (Phase 4)
const canvassingService = require('./services/canvassing');

// Import export service
const exportService = require('./services/export');

// Import validation utilities
const validation = require('./lib/validation');

// Import admin dashboard service
const adminDashboardService = require('./services/admin-dashboard');

// Import bulk operations service
const bulkOperationsService = require('./services/bulk-operations');

// Import requests service (campaign / token / billing requests, owner-managed)
const requestsService = require('./services/requests');

// Middleware to require active subscription for app features
const requireActiveSubscription = async (req, res, next) => {
  try {

    const user = await findUserById(req.user.id);
    
    if (!user) {

      return res.status(401).json({ error: 'User not found' });
    }
    
    // Check if user needs subscription
    const needsSubscription = await requiresSubscription(user);
    const hasActiveSub = await hasActiveSubscription(user);

    // If user needs subscription but doesn't have one, redirect to subscription page
    if (needsSubscription && !hasActiveSub) {

      if (req.accepts('html')) {
        return res.redirect('/subscription');
      } else {
        return res.status(403).json({ 
          error: 'Active subscription required',
          redirectTo: '/subscription'
        });
      }
    }

    // User has access, continue to next middleware
    next();
  } catch (error) {

    res.status(500).json({ error: 'Subscription check failed' });
  }
};

// Middleware to require NDA acceptance before using the application.
// App owner / EDA / account_holder: no session cookie needed. Election users: must have signed NDA this session.
const requireNdaAcceptance = async (req, res, next) => {
  const isPageRequest = req.accepts('html') || (req.method === 'GET' && !req.xhr && !req.path.startsWith('/api/'));
  try {
    const userId = req.user && req.user.id != null ? String(req.user.id) : '';
    let user = await findUserById(userId);
    if (!user && req.user) user = req.user;
    if (!user) {
      if (isPageRequest) return redirectToLogin(res, req, 'requireNdaAcceptance', 'USER_NOT_FOUND');
      return res.status(401).json({ error: 'User not found' });
    }
    // Exempt: app_owner, eda, account_holder (no per-session NDA)
    const exemptFromNda = user.userType === 'app_owner' || user.accountType === 'app_owner' ||
      user.accountType === 'eda' || user.userType === 'account_holder';
    if (exemptFromNda) return next();

    if (!user.ndaAccepted) {
      if (isPageRequest) return res.redirect('/nda');
      return res.status(403).json({ error: 'NDA acceptance required', redirectTo: '/nda' });
    }
    // Only election users need session cookie (sign NDA every login)
    const isElectionUser = user.electionMode || user.accountType === 'election' || user.userType === 'team_member';
    if (isElectionUser) {
      const ndaSessionCookie = req.cookies && req.cookies.election_nda_session;
      if (!ndaSessionCookie) {
        if (isPageRequest) return res.redirect('/nda');
        return res.status(403).json({ error: 'NDA acceptance required this session', redirectTo: '/nda' });
      }
    }
    next();
  } catch (error) {
    console.error('NDA check failed:', error);
    if (req.user) return next();
    if (isPageRequest) return redirectToLogin(res, req, 'requireNdaAcceptance', 'CATCH');
    res.status(500).json({ error: 'NDA check failed' });
  }
};

const hasActiveSubscription = async (user) => {
  if (!(await requiresSubscription(user))) {
    return true;
  }
  
  // For team members, check if their account holder has an active subscription
  if (user.userType === 'team_member' && user.accountId) {
    try {
      const accountHolder = await findUserById(user.accountId);
      if (accountHolder) {
        // Account holders are EDA, so team members inherit full access
        if (accountHolder.accountType === ACCOUNT_TYPES.EDA || accountHolder.accountType === ACCOUNT_TYPES.APP_OWNER) {
          return true;
        }
        // Check account holder's subscription for reg_client accounts
        if (accountHolder.subscriptionStatus === SUBSCRIPTION_STATUS.ACTIVE) {
          return true;
        }
        if (accountHolder.subscriptionStatus === SUBSCRIPTION_STATUS.TRIAL && accountHolder.trialEndsAt) {
          return new Date() < new Date(accountHolder.trialEndsAt);
        }
      }
    } catch (error) {
    }
    return false;
  }
  
  // For account holders, check their own subscription
  if (!user.subscriptionStatus) return false;
  
  // Check if subscription is active
  if (user.subscriptionStatus === SUBSCRIPTION_STATUS.ACTIVE) {
    return true;
  }
  
  // Check if in trial period
  if (user.subscriptionStatus === SUBSCRIPTION_STATUS.TRIAL && user.trialEndsAt) {
    return new Date() < new Date(user.trialEndsAt);
  }
  
  return false;
};

const isSubscriptionExpired = async (user) => {
  if (!(await requiresSubscription(user))) return false;
  
  if (user.subscriptionStatus === SUBSCRIPTION_STATUS.EXPIRED) {
    return true;
  }
  
  // Check if trial has expired
  if (user.subscriptionStatus === SUBSCRIPTION_STATUS.TRIAL && user.trialEndsAt) {
    return new Date() >= new Date(user.trialEndsAt);
  }
  
  return false;
};

// Permission checking function
const checkUserPermission = (user, permission) => {
  if (!user || !user.userType) {
    console.log(`[PERMISSION CHECK] User missing or no userType - user: ${!!user}, userType: ${user?.userType}`);
    return false;
  }
  
  // App owners and users with admin privileges have all permissions
  if (user.userType === 'app_owner' || user.isAdmin === true) {
    return true;
  }
  
  // Account holders should ALWAYS have team management permissions
  // This ensures all account holders can manage their team, even if permissions array is missing/corrupted
  if (user.userType === 'account_holder') {
    const accountHolderPermissions = USER_PERMISSIONS.ACCOUNT_HOLDER || [];
    if (accountHolderPermissions.includes(permission) || accountHolderPermissions.includes('*')) {
      return true;
    }
    // Also check explicit permissions if they exist
    if (user.permissions && Array.isArray(user.permissions) && user.permissions.length > 0) {
      if (user.permissions.includes(permission) || user.permissions.includes('*')) {
        return true;
      }
    }
  }
  
  // Check if user has specific permission
  // Use user.permissions if it exists and is a non-empty array, otherwise fall back to default permissions
  let userPermissions;
  const hasExplicitPermissions = user.permissions && 
                                 Array.isArray(user.permissions) && 
                                 user.permissions.length > 0;
  
  if (hasExplicitPermissions) {
    userPermissions = user.permissions;
  } else {
    // Fall back to default permissions based on userType
    const userTypeKey = user.userType.toUpperCase().replace(/-/g, '_'); // Handle any dashes
    userPermissions = USER_PERMISSIONS[userTypeKey] || [];
    
    // If still no permissions found, try alternative key formats
    if (userPermissions.length === 0) {
      // Try with underscore replacement (account-holder -> ACCOUNT_HOLDER)
      const altKey = user.userType.replace(/-/g, '_').toUpperCase();
      userPermissions = USER_PERMISSIONS[altKey] || [];
    }
    
    if (userPermissions.length === 0) {
      console.log(`[PERMISSION CHECK] No default permissions found for userType: ${user.userType} (tried keys: ${userTypeKey}, ${user.userType.replace(/-/g, '_').toUpperCase()})`);
    }
  }
  
  let hasPermission = userPermissions.includes(permission) || userPermissions.includes('*');
  
  // Backward compatibility: 'manage_team' is equivalent to 'manage_users'
  if (!hasPermission && permission === 'manage_users' && userPermissions.includes('manage_team')) {
    hasPermission = true;
  }
  if (!hasPermission && permission === 'manage_team' && userPermissions.includes('manage_users')) {
    hasPermission = true;
  }
  
  if (!hasPermission) {
    console.log(`[PERMISSION CHECK] User ${user.id} (${user.email || 'no-email'}) - userType: ${user.userType}, required: ${permission}, hasExplicit: ${hasExplicitPermissions}, permissions: ${JSON.stringify(userPermissions)}`);
  }
  
  return hasPermission;
};

// Permission middleware factory
const requirePermission = (permission) => {
  return async (req, res, next) => {
    try {
      let user = req.user;
      
      // Always reload user from database to ensure we have latest data
      if (user?.id) {
        user = await findUserById(user.id);
      }
      
      if (!user) {
        return res.status(401).json({ error: 'User not found' });
      }
      
      // Ensure account holders have the correct permissions if they're missing
      if (user.userType === 'account_holder') {
        const defaultPermissions = USER_PERMISSIONS.ACCOUNT_HOLDER || [];
        if (!user.permissions || !Array.isArray(user.permissions) || user.permissions.length === 0) {
          // User is missing permissions, use defaults
          user.permissions = defaultPermissions;
          // Optionally save the fix (but don't block the request)
          try {
            await writeIndividualUserFile(user.id, user);
            console.log(`[PERMISSION FIX] Fixed missing permissions for account holder ${user.id}`);
          } catch (error) {
            console.error(`[PERMISSION FIX] Failed to save fixed permissions: ${error.message}`);
          }
        } else {
          // Ensure critical permissions are present even if user has explicit permissions
          const criticalPermissions = ['invite_users', 'manage_users'];
          let needsUpdate = false;
          for (const criticalPerm of criticalPermissions) {
            if (!user.permissions.includes(criticalPerm) && defaultPermissions.includes(criticalPerm)) {
              user.permissions.push(criticalPerm);
              needsUpdate = true;
            }
          }
          if (needsUpdate) {
            try {
              await writeIndividualUserFile(user.id, user);
              console.log(`[PERMISSION FIX] Added missing critical permissions for account holder ${user.id}`);
            } catch (error) {
              console.error(`[PERMISSION FIX] Failed to save fixed permissions: ${error.message}`);
            }
          }
        }
      }
      
      // Check permission
      const hasPermission = checkUserPermission(user, permission);
      
      if (!hasPermission) {
        // Log permission denial for debugging
        console.log(`[PERMISSION DENIED] User ${user.id} (${user.email}) - userType: ${user.userType}, required: ${permission}, permissions: ${JSON.stringify(user.permissions || 'none')}`);
        return res.status(403).json({ 
          error: 'Permission denied', 
          required: permission,
          userType: user?.userType,
          hasPermissions: !!user.permissions,
          permissionsCount: user.permissions?.length || 0
        });
      }
      
      req.user = user; // Ensure user is attached to request
      next();
    } catch (error) {
      console.error('Permission check error:', error);
      res.status(500).json({ error: 'Permission check failed' });
    }
  };
};

// Paywall middleware - checks subscription status
const requireSubscription = async (req, res, next) => {
  try {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    // Check if user needs subscription
    if (!(await requiresSubscription(req.user))) {
      return next(); // User doesn't need subscription
    }
    
    // Check if user has active subscription
    if (!(await hasActiveSubscription(req.user))) {
      // Check if subscription is expired
      if (await isSubscriptionExpired(req.user)) {
        if (req.accepts('html')) {
          return res.redirect('/subscription');
        }
        return res.status(402).json({ 
          error: 'Subscription expired',
          subscriptionRequired: true,
          accountType: req.user.accountType || 'reg_client'
        });
      }
      
      // User needs to subscribe
      if (req.accepts('html')) {
        return res.redirect('/subscription');
      }
      return res.status(402).json({ 
        error: 'Subscription required',
        subscriptionRequired: true,
        accountType: req.user.accountType || 'reg_client'
      });
    }
    
    next();
  } catch (error) {
    res.status(500).json({ error: 'Subscription check failed' });
  }
};

// Account access middleware - ensures user can only access their own account data
const requireAccountAccess = async (req, res, next) => {
  try {
    const userId = (req.user && req.user.id) != null ? String(req.user.id) : null;
    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    const user = await findUserById(userId);
    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }
    
    // App owners and users with admin privileges can access any account
    if (user.userType === 'app_owner' || user.isAdmin === true) {
      req.user = user;
      return next();
    }
    
    // Get target account ID from request (params, body, or query)
    const targetAccountId = req.params.accountId || req.body.accountId || req.query.accountId || user.accountId;
    
    // Users can only access their own account
    if (user.accountId !== targetAccountId) {
      return res.status(403).json({ 
        error: 'Account access denied',
        message: 'You can only access your own account data'
      });
    }
    
    req.user = user;
    req.accountId = targetAccountId;
    next();
  } catch (error) {
    res.status(500).json({ error: 'Account access check failed' });
  }
};

// ===== STANDARDIZED DATA ACCESS FUNCTIONS =====
// These functions provide consistent access to the new database structure

// Standardized account ID resolution
const getEffectiveAccountId = (user) => {
  if (user.userType === 'app_owner' || user.isAdmin === true) {
    return user.id; // App owners and admin users use their own ID as account ID
  }
  return user.accountId || user.id;
};

// Check if account uses special contact structure (EDA special format)
const isSpecialContactStructure = async (accountId) => {
  try {
    const userData = await readIndividualUserData(accountId.toString());
    if (userData) {
      return userData.contactStructure === 'eda_special';
    }
    return false;
  } catch (error) {
    console.error('Error checking contact structure:', error);
    return false;
  }
};

// Safe file reading with proper error handling and corruption recovery
const safeReadJsonFile = async (filePath, defaultValue = []) => {
  try {
    if (!fs.existsSync(filePath)) {
      return defaultValue;
    }
    let data = await fsPromises.readFile(filePath, 'utf8');
    
    // Try to parse the JSON
    try {
      return JSON.parse(data);
    } catch (parseError) {
      // If parsing fails, try to recover by finding the last valid JSON object
      console.warn(`JSON parse error in ${filePath}, attempting recovery...`);
      
      // Try to find the last complete JSON array/object
      // Look for the last ']' or '}' that might indicate end of valid JSON
      let lastValidIndex = -1;
      
      // For arrays, find the last ']'
      const lastArrayEnd = data.lastIndexOf(']');
      if (lastArrayEnd > 0) {
        try {
          const recovered = JSON.parse(data.substring(0, lastArrayEnd + 1));
          console.log(`Recovered ${recovered.length || 'some'} entries from corrupted file`);
          
          // Backup corrupted file and write recovered data
          const backupPath = filePath + '.corrupted.' + Date.now();
          await fsPromises.copyFile(filePath, backupPath);
          await safeWriteJsonFile(filePath, recovered);
          console.log(`Backed up corrupted file to ${backupPath} and restored valid data`);
          
          return recovered;
        } catch (e) {
          // Recovery failed, continue to fallback
        }
      }
      
      // If recovery failed, backup but DON'T auto-recreate with empty array for contacts
      console.error(`Could not recover ${filePath}, backing up...`);
      const backupPath = filePath + '.corrupted.' + Date.now();
      
      // CRITICAL SAFETY: Never write empty array to contacts.json
      if (filePath.includes('contacts.json') && Array.isArray(defaultValue) && defaultValue.length === 0) {
        console.error(`ðŸš¨ CRITICAL: Cannot recover contacts.json and refusing to write empty array!`);
        console.error('Check the backup files in the data directory for recovery');
        // Return default but DON'T write it to file
        return defaultValue;
      }
      
      try {
        await fsPromises.copyFile(filePath, backupPath);
        console.log(`Backed up corrupted file to ${backupPath}`);
      } catch (backupError) {
        console.error(`Failed to backup corrupted file:`, backupError);
      }
      
      // Write default value to fix the file
      await safeWriteJsonFile(filePath, defaultValue);
      return defaultValue;
    }
  } catch (error) {
    console.error(`Error reading ${filePath}:`, error);
    return defaultValue;
  }
};

// Safe file writing with directory creation
// File write locks to prevent race conditions
const fileWriteLocks = new Map();

const safeWriteJsonFile = async (filePath, data) => {
  try {
    const dir = path.dirname(filePath);
    await fsPromises.mkdir(dir, { recursive: true });
    
    // Implement file locking to prevent concurrent writes
    // Wait for any existing write to complete
    while (fileWriteLocks.has(filePath)) {
      await new Promise(resolve => setTimeout(resolve, 50)); // Wait 50ms
    }
    
    // Acquire lock
    fileWriteLocks.set(filePath, true);
    
    try {
      // Critical safety check for contacts.json - NEVER write empty array
      if (filePath.includes('contacts.json') && Array.isArray(data) && data.length === 0) {
        console.error(`ðŸš¨ CRITICAL: Attempted to write EMPTY contacts array to ${filePath}. Operation blocked!`);
        console.error('This is likely a bug - investigate the calling code!');
        // Don't write empty array - keep existing file
        return false;
      }
      
      // Use atomic write: write to temp file first, then rename
      const tempPath = filePath + '.tmp.' + Date.now();
      await fsPromises.writeFile(tempPath, JSON.stringify(data, null, 2), 'utf8');
      
      // Atomic rename - this prevents partial writes from corrupting the file
      await fsPromises.rename(tempPath, filePath);
      
      return true;
    } finally {
      // Release lock
      fileWriteLocks.delete(filePath);
    }
  } catch (error) {
    console.error(`Error writing ${filePath}:`, error);
    fileWriteLocks.delete(filePath); // Ensure lock is released on error
    return false;
  }
};

// Timeout for PG data calls; if exceeded, fall back to JSON so app stays responsive
const PG_QUERY_TIMEOUT_MS = 8000;
const withTimeout = (p, ms) => Promise.race([
  p,
  new Promise((_, reject) => setTimeout(() => reject(new Error('PG query timeout')), ms)),
]);

// Account-level data access functions
const getAccountContacts = async (accountId) => {
  let contacts;
  // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
  if (isPostgresReady()) {
    try {
      contacts = await withTimeout(contactRepo.getContacts(accountId), PG_QUERY_TIMEOUT_MS);
      if (!Array.isArray(contacts)) contacts = [];
    } catch (err) {
      console.error('[getAccountContacts] PG timeout or error, falling back to JSON', err.message);
      const sharedContactsPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'contacts.json');
      contacts = await safeReadJsonFile(sharedContactsPath, []);
    }
  } else {
    const sharedContactsPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'contacts.json');
    contacts = await safeReadJsonFile(sharedContactsPath, []);
  }

  // Defensive check - ensure contacts is always an array
  if (!Array.isArray(contacts)) {
    console.error(`[getAccountContacts] Warning: contacts for account ${accountId} is not an array (type: ${typeof contacts}), defaulting to []`);
    contacts = [];
  }

  let needsMigration = false;
  const isSpecial = await isSpecialContactStructure(accountId);

  const migrated = contacts.map(originalContact => {
    const contact = { ...originalContact };

    if (!contact.communicationPreferences) {
      needsMigration = true;
    }
    ensureCommunicationPreferences(contact);

    // Migrate old single 'category' field to new 'categories' array
    if (!Array.isArray(contact.categories)) {
      needsMigration = true;
      contact.categories = contact.category ? [contact.category] : [];
    }

    // Only normalize names for standard structure contacts
    if (!isSpecial && normalizeContactName(contact)) {
      needsMigration = true;
    }

    if (ensureNotesArray(contact)) {
      needsMigration = true;
    }

    return contact;
  });

  if (needsMigration) {
    await updateAccountContacts(accountId, migrated);
  }

  return migrated;
};

const getAccountCampaigns = async (accountId) => {
  // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
  if (isPostgresReady()) {
    try {
      return await withTimeout(campaignRepo.getCampaigns(accountId), PG_QUERY_TIMEOUT_MS);
    } catch (err) {
      console.error('[getAccountCampaigns] PG timeout or error, falling back to JSON', err.message);
    }
  }
  const sharedCampaignsPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'campaigns.json');
  return await safeReadJsonFile(sharedCampaignsPath, []);
};

const getAccountTemplates = async (accountId) => {
  const sharedTemplatesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'templates.json');
  return await safeReadJsonFile(sharedTemplatesPath, []);
};

const getAccountImages = async (accountId) => {
  const sharedImagesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'images.json');
  return await safeReadJsonFile(sharedImagesPath, []);
};

const getAccountTokens = async (accountId) => {
  const sharedTokensPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'tokens.json');
  const defaultTokens = { smsTokens: 0, emailTokens: 0, aiTokens: 0, lastUpdated: Date.now() };
  
  const tokens = await safeReadJsonFile(sharedTokensPath, defaultTokens);
  
  // If we got default tokens and file doesn't exist, create it
  if (tokens === defaultTokens && !fs.existsSync(sharedTokensPath)) {
    await safeWriteJsonFile(sharedTokensPath, defaultTokens);
  }
  
  return tokens;
};

// Additional standardized data access functions
const getAccountInvoices = async (accountId) => {
  const sharedInvoicesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'invoices.json');
  return await safeReadJsonFile(sharedInvoicesPath, []);
};

const getAccountSenderEmails = async (accountId) => {
  const sharedSenderEmailsPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'senderEmails.json');
  return await safeReadJsonFile(sharedSenderEmailsPath, []);
};

const getAccountPhoneNumbers = async (accountId) => {
  const sharedPhoneNumbersPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'phoneNumbers.json');
  return await safeReadJsonFile(sharedPhoneNumbersPath, []);
};

const getAccountMessages = async (accountId, messageType = 'messages') => {
  const sharedMessagesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), `${messageType}.json`);
  return await safeReadJsonFile(sharedMessagesPath, []);
};

const getAccountEmailMessages = async (accountId) => {
  return await getAccountMessages(accountId, 'email-messages');
};

const getAccountSmsMessages = async (accountId) => {
  return await getAccountMessages(accountId, 'sms-messages');
};

const getAccountVoiceMessages = async (accountId) => {
  return await getAccountMessages(accountId, 'voice-messages');
};

// Write functions for updating shared data
const updateAccountContacts = async (accountId, contacts) => {
  // Critical safety check before writing contacts
  if (!Array.isArray(contacts)) {
    console.error(`ðŸš¨ CRITICAL: Attempted to write non-array to contacts for account ${accountId}`);
    console.error('Data type:', typeof contacts);
    console.error('Stack trace:', new Error().stack);
    return false;
  }

  // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
  if (isPostgresReady()) {
    try {
      await withTimeout(contactRepo.updateAccountContacts(accountId, contacts), PG_QUERY_TIMEOUT_MS);
      console.log(`[CONTACTS] Updated PostgreSQL contacts for account ${accountId}: ${contacts.length} contacts`);
      return true;
    } catch (err) {
      console.error('[updateAccountContacts] PG timeout or error', err.message);
      return false;
    }
  }

  if (contacts.length === 0) {
    console.error(`ðŸš¨ WARNING: Attempting to write EMPTY contacts array for account ${accountId}`);
    console.error('Stack trace:', new Error().stack);
    // This will be blocked by safeWriteJsonFile
  }

  const sharedContactsPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'contacts.json');
  console.log(`[CONTACTS] Updating contacts.json for account ${accountId}: ${contacts.length} contacts`);
  return await safeWriteJsonFile(sharedContactsPath, contacts);
};

// Election interactions (JSON backend only) - Phase 4
const getElectionInteractionsPath = (accountId) => path.join(SHARED_DATA_DIR, accountId.toString(), 'election-interactions.json');
const getElectionInteractionsJson = async (accountId) => {
  const filePath = getElectionInteractionsPath(accountId);
  const list = await safeReadJsonFile(filePath, []);
  return Array.isArray(list) ? list : [];
};
const saveElectionInteractionsJson = async (accountId, interactions) => {
  const filePath = getElectionInteractionsPath(accountId);
  await fsPromises.mkdir(path.dirname(filePath), { recursive: true });
  const tempPath = filePath + '.tmp.' + Date.now();
  await fsPromises.writeFile(tempPath, JSON.stringify(interactions, null, 2), 'utf8');
  await fsPromises.rename(tempPath, filePath);
};

// Unsubscribe Management Helper Functions
const ensureCommunicationPreferences = (contact) => {
  if (!contact.communicationPreferences) {
    contact.communicationPreferences = {
      email: { subscribed: true, unsubscribedAt: null, unsubscribeReason: null, unsubscribeMethod: null },
      sms: { subscribed: true, unsubscribedAt: null, unsubscribeReason: null, unsubscribeMethod: null },
      voice: { subscribed: true, unsubscribedAt: null, unsubscribeReason: null, unsubscribeMethod: null }
    };
  }
  return contact;
};

// Normalize contact.notes to array of { text, updatedAt }. Returns true if migration was applied.
const ensureNotesArray = (contact) => {
  if (!contact) return false;
  if (Array.isArray(contact.notes)) {
    contact.notes = contact.notes.filter(n => n && (n.text != null || n.updatedAt != null)).map(n => ({
      text: n.text != null ? String(n.text) : '',
      updatedAt: n.updatedAt || null,
      authorName: n.authorName != null ? String(n.authorName).trim() || null : null
    }));
    return false;
  }
  const text = typeof contact.notes === 'string' ? contact.notes.trim() : '';
  const updatedAt = contact.notesUpdatedAt || contact.updatedAt || null;
  contact.notes = text ? [{ text, updatedAt }] : [];
  if (contact.notesUpdatedAt !== undefined) delete contact.notesUpdatedAt;
  return true;
};

const migrateContactsWithPreferences = async (accountId) => {
  const contacts = await getAccountContacts(accountId);
  let updated = false;
  const migrated = contacts.map(contact => {
    if (!contact.communicationPreferences) {
      updated = true;
      return ensureCommunicationPreferences(contact);
    }
    return contact;
  });
  if (updated) {
    await updateAccountContacts(accountId, migrated);
  }
  return migrated;
};

const filterUnsubscribedContacts = (contacts, channel) => {
  return contacts.filter(contact => {
    const prefs = contact.communicationPreferences;
    if (!prefs || !prefs[channel]) {
      // Default to subscribed if preferences don't exist
      return true;
    }
    return prefs[channel].subscribed !== false;
  });
};

const logUnsubscribeEvent = async (accountId, unsubscribeData) => {
  const logPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'unsubscribe-log.json');
  // Use safeReadJsonFile instead of direct file reading to handle corruption
  let log = await safeReadJsonFile(logPath, []);
  
  // Ensure log is an array
  if (!Array.isArray(log)) {
    log = [];
  }
  
  log.push({
    id: `unsub-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    ...unsubscribeData,
    timestamp: new Date().toISOString()
  });
  // Keep only last 1000 entries
  if (log.length > 1000) {
    log = log.slice(-1000);
  }
  await safeWriteJsonFile(logPath, log);
};

const generateUnsubscribeToken = (contactId, accountId, channel) => {
  const payload = `${contactId}:${accountId}:${channel}:${Date.now()}`;
  const secretKey = process.env.SECRET_KEY;
  if (!secretKey) {
    throw new Error('SECRET_KEY environment variable is required for token generation');
  }
  const token = crypto.createHash('sha256').update(payload + secretKey).digest('hex');
  return Buffer.from(token).toString('base64url').substring(0, 32);
};

const validateUnsubscribeToken = (token, contactId, accountId, channel) => {
  // For now, we'll use a simpler approach - token contains contact info
  // In production, you'd want to store tokens with expiration
  try {
    const decoded = Buffer.from(token, 'base64url').toString('hex');
    // Verify by regenerating and comparing (simplified - in production use JWT)
    const expected = generateUnsubscribeToken(contactId, accountId, channel);
    return token === expected || true; // For now, accept any token with valid contact lookup
  } catch (e) {
    return false;
  }
};

const updateAccountTemplates = async (accountId, templates) => {
  const sharedTemplatesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'templates.json');
  return await safeWriteJsonFile(sharedTemplatesPath, templates);
};

const updateAccountImages = async (accountId, images) => {
  const sharedImagesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'images.json');
  return await safeWriteJsonFile(sharedImagesPath, images);
};

const updateAccountInvoices = async (accountId, invoices) => {
  const sharedInvoicesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'invoices.json');
  return await safeWriteJsonFile(sharedInvoicesPath, invoices);
};

// Token synchronization functions
const updateAccountTokens = async (accountId, tokenUpdates) => {
  try {
    // Update shared tokens file
    const sharedTokensPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'tokens.json');
    const currentTokens = await getAccountTokens(accountId);
    
    const updatedTokens = {
      ...currentTokens,
      ...tokenUpdates,
      lastUpdated: Date.now()
    };
    
    await fsPromises.writeFile(sharedTokensPath, JSON.stringify(updatedTokens, null, 2), 'utf8');
    
    // Update account holder's tokens to keep them in sync
    const accountHolder = await findUserById(accountId);
    if (accountHolder) {
      accountHolder.smsTokens = updatedTokens.smsTokens;
      accountHolder.emailTokens = updatedTokens.emailTokens;
      accountHolder.aiTokens = updatedTokens.aiTokens;
      await writeIndividualUserFile(accountId, accountHolder);
    }
    
    return updatedTokens;
  } catch (error) {
    throw error;
  }
};

const deductAccountTokens = async (accountId, tokenType, amount) => {
  try {
    const currentTokens = await getAccountTokens(accountId);
    
    if (currentTokens[tokenType] < amount) {
      throw new Error(`Insufficient ${tokenType}. Available: ${currentTokens[tokenType]}, Required: ${amount}`);
    }
    
    const updatedTokens = {
      ...currentTokens,
      [tokenType]: currentTokens[tokenType] - amount,
      lastUpdated: Date.now()
    };
    
    return await updateAccountTokens(accountId, updatedTokens);
  } catch (error) {
    throw error;
  }
};

// Individual data access functions
const getIndividualMessages = async (userId) => {
  try {
    const individualMessagesPath = path.join(__dirname, 'data', 'individual-data', userId, 'messages.json');
    const data = await fsPromises.readFile(individualMessagesPath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    if (error.code === 'ENOENT') {
      return [];
    }
    return [];
  }
};

const getIndividualAnalytics = async (userId) => {
  try {
    const individualAnalyticsPath = path.join(__dirname, 'data', 'individual-data', userId, 'analytics.json');
    const data = await fsPromises.readFile(individualAnalyticsPath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    if (error.code === 'ENOENT') {
      return {};
    }
    return {};
  }
};

// Team management functions
const getTeamMembers = async (accountId) => {
  try {
    // Get all users that belong to this account using new data structure
    const userIds = await getAllUserIds();
    const teamMembers = [];
    
    for (const userId of userIds) {
      try {
        const user = await findUserById(userId);
        if (user && user.accountId === accountId) {
          teamMembers.push({
            id: user.id,
            email: user.email,
            personalInfo: user.personalInfo,
            userType: user.userType,
            permissions: user.permissions,
            lastLoginAt: user.lastLoginAt,
            createdAt: user.createdAt
          });
        }
      } catch (error) {
      }
    }
    
    return teamMembers;
  } catch (error) {
    return [];
  }
};

const getTeamAnalytics = async (accountId) => {
  try {
    const teamMembers = await getTeamMembers(accountId);
    const teamAnalytics = {
      totalMembers: teamMembers.length,
      memberAnalytics: [],
      combinedStats: {
        totalMessages: 0,
        totalCampaigns: 0,
        totalContacts: 0,
        totalTemplates: 0
      }
    };
    
    // Get analytics from each team member
    for (const member of teamMembers) {
      try {
        const analytics = await getIndividualAnalytics(member.id);
        const messages = await getIndividualMessages(member.id);
        
        teamAnalytics.memberAnalytics.push({
          userId: member.id,
          email: member.email,
          personalInfo: member.personalInfo,
          analytics: analytics,
          messageCount: messages.length,
          lastActivity: member.lastLoginAt
        });
        
        // Aggregate stats
        teamAnalytics.combinedStats.totalMessages += messages.length;
        if (analytics.campaigns) teamAnalytics.combinedStats.totalCampaigns += analytics.campaigns;
        if (analytics.contacts) teamAnalytics.combinedStats.totalContacts += analytics.contacts;
        if (analytics.templates) teamAnalytics.combinedStats.totalTemplates += analytics.templates;
      } catch (error) {
      }
    }
    
    return teamAnalytics;
  } catch (error) {
    return { totalMembers: 0, memberAnalytics: [], combinedStats: {} };
  }
};

// Helper function to get user's effective account ID
const getUserAccountId = (user) => {
  // App owners and admin users don't have account restrictions
  if (user.userType === 'app_owner' || user.isAdmin === true) return null;
  return user.accountId;
};

// Invitation system functions
const invitationsDir = path.join(__dirname, 'data', 'invitations');

const ensureInvitationsDir = async () => {
  try {
    await fsPromises.access(invitationsDir);
  } catch (error) {
    if (error.code === 'ENOENT') {
      await fsPromises.mkdir(invitationsDir, { recursive: true });
    }
  }
};

const createInvitation = async (inviteData) => {
  await ensureInvitationsDir();
  const invitationId = Date.now().toString();
  const invitationToken = crypto.randomBytes(32).toString('hex');
  
  const invitation = {
    id: invitationId,
    token: invitationToken,
    accountId: inviteData.accountId,
    invitedBy: inviteData.invitedBy,
    email: inviteData.email,
    userType: 'user', // All invited users start as 'user' type
    status: 'pending', // pending, accepted, expired
    createdAt: Date.now(),
    expiresAt: Date.now() + (7 * 24 * 60 * 60 * 1000), // 7 days
    acceptedAt: null
  };
  
  const invitationPath = path.join(invitationsDir, `${invitationId}.json`);
  await fsPromises.writeFile(invitationPath, JSON.stringify(invitation, null, 2));
  
  return invitation;
};

const getInvitation = async (invitationId) => {
  try {
    const invitationPath = path.join(invitationsDir, `${invitationId}.json`);
    const data = await fsPromises.readFile(invitationPath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    return null;
  }
};

const getInvitationByToken = async (token) => {
  try {
    await ensureInvitationsDir();
    const files = await fsPromises.readdir(invitationsDir);
    
    for (const file of files) {
      if (file.endsWith('.json')) {
        const invitation = await getInvitation(file.replace('.json', ''));
        if (invitation && invitation.token === token) {
          return invitation;
        }
      }
    }
    return null;
  } catch (error) {
    return null;
  }
};

const updateInvitation = async (invitationId, updates) => {
  try {
    const invitation = await getInvitation(invitationId);
    if (!invitation) return null;
    
    const updatedInvitation = { ...invitation, ...updates };
    const invitationPath = path.join(invitationsDir, `${invitationId}.json`);
    await fsPromises.writeFile(invitationPath, JSON.stringify(updatedInvitation, null, 2));
    
    return updatedInvitation;
  } catch (error) {
    return null;
  }
};

const getAccountInvitations = async (accountId) => {
  try {
    await ensureInvitationsDir();
    const files = await fsPromises.readdir(invitationsDir);
    const invitations = [];
    
    for (const file of files) {
      if (file.endsWith('.json')) {
        const invitation = await getInvitation(file.replace('.json', ''));
        if (invitation && invitation.accountId === accountId) {
          invitations.push(invitation);
        }
      }
    }
    
    return invitations.sort((a, b) => b.createdAt - a.createdAt);
  } catch (error) {
    return [];
  }
};

// Helper functions
const findUserById = async (userId) => {
  // Only use individual-data structure (new system)
  return await readIndividualUserData(userId);
};

// Create requireActiveAccount middleware instance (Phase 0 refactoring)
// This is a neutral replacement for requireActiveSubscription
// It uses account status instead of subscription status
const requireActiveAccount = accountMiddleware.requireActiveAccount(findUserById, redirectToLogin);

// Create election middleware instances (Phase 3)
const requireElectionMode = electionMiddleware.requireElectionMode(findUserById, {
  fs: fsPromises,
  path: path,
  SHARED_DATA_DIR: SHARED_DATA_DIR,
  dbHelpers: { isPostgresReady, getAdapter: () => require('./db').getAdapter() }
});
const requireElectionPermission = (permission) => electionMiddleware.requireElectionPermission(permission, findUserById);

// Initialize default template and image for a new account
const initializeDefaultTemplateForAccount = async (accountId) => {
  try {
    const DEFAULT_HEADER_IMAGE_URL = 'https://images.unsplash.com/photo-1557804506-669a67965ba0?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2074&q=80';
    
    // Default Basic Marketing Template
    const defaultTemplate = {
      id: 'default',
      name: 'Basic Marketing Template',
      headerText: 'Campaign Builder',
      headerImage: DEFAULT_HEADER_IMAGE_URL,
      bannerImage: '',
      category: 'marketing',
      tags: ['newsletter', 'promotional'],
      bodyElements: [
        {
          type: 'text',
          content: 'Thank you for being a valued customer. We appreciate your business.'
        },
        {
          type: 'button',
          text: 'Visit Our Website',
          url: 'https://campaignbuilder.ca'
        }
      ],
      footerImage: '',
      footerText: 'Contact: info@campaignbuilder.ca | Phone: (555) 123-4567\nFollow us: @campaignbuilder\nÂ© 2025 Campaign Builder. All rights reserved.',
      footerLinks: [
        {
          text: 'Privacy Policy',
          url: '#'
        },
        {
          text: 'Contact Us',
          url: '#'
        }
      ],
      style: {
        headerOverlay: 'bg-gradient-to-r from-indigo-900 to-indigo-600 mix-blend-multiply',
        headerTextColor: 'text-white'
      },
      updatedAt: new Date().toISOString(),
      isDefault: true
    };

    // Default header image
    const defaultHeaderImage = {
      id: 'default_header_001',
      userId: 'system',
      url: DEFAULT_HEADER_IMAGE_URL,
      name: 'Default Header Image',
      description: 'System default header image for Basic Marketing Template',
      tags: ['default', 'header', 'system'],
      section: 'header',
      size: 0,
      createdAt: new Date().toISOString(),
      source: 'system',
      isDefault: true
    };

    // Initialize templates.json
    const templatesPath = path.join(SHARED_DATA_DIR, accountId, 'templates.json');
    await fsPromises.writeFile(templatesPath, JSON.stringify([defaultTemplate], null, 2));
    
    // Initialize images.json
    const imagesPath = path.join(SHARED_DATA_DIR, accountId, 'images.json');
    await fsPromises.writeFile(imagesPath, JSON.stringify([defaultHeaderImage], null, 2));
    
  } catch (error) {
  }
};

// Read individual user data (email, password, personal settings)
const readIndividualUserData = async (userId) => {
  try {
    // Normalize to string so path is consistent (JWT may give number; dir names are string)
    const id = userId != null ? String(userId) : '';
    if (!id) return null;
    // First try the new directory structure: userId/user.json
    let filePath = path.join(INDIVIDUAL_DATA_DIR, id, 'user.json');
    let stats;
    try {
      stats = await fsPromises.stat(filePath);
    } catch (statError) {
      // If that doesn't exist, try the old file structure: userId.json
      filePath = path.join(INDIVIDUAL_DATA_DIR, `${id}.json`);
      try {
        stats = await fsPromises.stat(filePath);
      } catch (oldStatError) {
        // Neither exists
        return null;
      }
    }
    
    // Read the file
    const data = await fsPromises.readFile(filePath, 'utf8');
    try {
      const userData = JSON.parse(data);
      // Ensure id is always set (some user files use directory name as id)
      if (!userData.id) userData.id = id;
      return userData;
    } catch (parseError) {
      throw new Error(`Invalid user data format: ${parseError.message}`);
    }
  } catch (error) {
    if (error.code === 'ENOENT') {
      return null;
    }
    throw new Error(`Failed to read user data: ${error.message}`);
  }
};

const writeIndividualUserFile = async (userId, userData) => {
  const individualDir = path.join(INDIVIDUAL_DATA_DIR, userId);
  await fsPromises.mkdir(individualDir, { recursive: true });
  
  const filePath = path.join(individualDir, 'user.json');
  
  // Encrypt sensitive fields on write if present and not already encrypted
  const safeData = { ...userData };
  if (safeData.twoFactorSecret) {
    const current = safeData.twoFactorSecret;
    const looksEncrypted = typeof current === 'string' && current.includes(':') && !current.startsWith('plain:');
    if (!looksEncrypted) {
      const value = typeof current === 'string' && current.startsWith('plain:') ? current.slice('plain:'.length) : String(current);
      const encrypted = encryptField(value);
      if (encrypted) {
        safeData.twoFactorSecret = encrypted;
      }
    }
  }
  
  await fsPromises.writeFile(filePath, JSON.stringify(safeData, null, 2), 'utf8');
};

const deleteUserFile = async (userId) => {
  try {
    // First, get the user to determine if they're a team member or account holder
    const user = await findUserById(userId);
    
    const individualDir = path.join(INDIVIDUAL_DATA_DIR, userId);
    
    // Always delete individual user data
    if (await fsPromises.access(individualDir).then(() => true).catch(() => false)) {
      // Remove the entire user directory
      await fsPromises.rm(individualDir, { recursive: true, force: true });
    }
    
    // For account holders, delete their shared-data directory (their accountId = userId)
    // For team members, don't touch shared-data (it belongs to the account holder's accountId)
    if (user && (user.userType === 'account_holder' || user.userType === 'app_owner')) {
      const sharedDir = path.join(SHARED_DATA_DIR, userId);
      if (await fsPromises.access(sharedDir).then(() => true).catch(() => false)) {
        await fsPromises.rm(sharedDir, { recursive: true, force: true });
      }
    }
    
    return true;
  } catch (error) {
    throw error;
  }
};

// Helper function to write account file
const writeAccountFile = async (userId, accountData) => {
  const accountFilePath = path.join(ACCOUNTS_DIR, `${userId}.json`);
  await fsPromises.writeFile(accountFilePath, JSON.stringify(accountData, null, 2));
};

const findUserByEmail = async (email) => {
  try {
    // Get all entries from individual-data (both files and directories)
    const entries = await fsPromises.readdir(INDIVIDUAL_DATA_DIR);
    
    // Search through each entry
    for (const entry of entries) {
      try {
        // Check if it's a directory or file
        const entryPath = path.join(INDIVIDUAL_DATA_DIR, entry);
        const stats = await fsPromises.stat(entryPath);
        
        let userId;
        if (stats.isDirectory()) {
          // New structure: directory name is userId
          userId = entry;
        } else if (stats.isFile() && entry.endsWith('.json')) {
          // Old structure: filename is userId.json
          userId = entry.replace(/\.json$/, '');
        } else {
          // Skip non-user entries
          continue;
        }
        
        const userData = await readIndividualUserData(userId);
        if (userData && userData.email === email) {
          // Ensure the user object has an id field for compatibility
          userData.id = userId;
          return userData;
        }
      } catch (userError) {
        // Continue searching other users - silently skip errors
        continue;
      }
    }
    
    // If we get here, no user was found
    return null;
  } catch (error) {
    throw new Error('Failed to search for user: ' + error.message);
  }
};

// Find all users with a given email (for login - same email can be in multiple accounts)
const findAllUsersByEmail = async (email) => {
  try {
    const allUsers = [];
    // Get all entries from individual-data (both files and directories)
    const entries = await fsPromises.readdir(INDIVIDUAL_DATA_DIR);
    
    // Search through each entry
    for (const entry of entries) {
      try {
        // Check if it's a directory or file
        const entryPath = path.join(INDIVIDUAL_DATA_DIR, entry);
        const stats = await fsPromises.stat(entryPath);
        
        let userId;
        if (stats.isDirectory()) {
          // New structure: directory name is userId
          userId = entry;
        } else if (stats.isFile() && entry.endsWith('.json')) {
          // Old structure: filename is userId.json
          userId = entry.replace(/\.json$/, '');
        } else {
          // Skip non-user entries
          continue;
        }
        
        const userData = await readIndividualUserData(userId);
        if (userData && userData.email && userData.email.toLowerCase() === email.toLowerCase()) {
          // Ensure the user object has an id field for compatibility
          userData.id = userId;
          allUsers.push(userData);
        }
      } catch (userError) {
        // Continue searching other users - silently skip errors
        continue;
      }
    }
    
    return allUsers;
  } catch (error) {
    throw new Error('Failed to search for users: ' + error.message);
  }
};

// Middleware for authentication
const auth = async (req, res, next) => {
  const isApi = req.originalUrl?.startsWith('/api/') || req.path?.startsWith('/api/');
  const wantsJson = (req.get('accept') || '').includes('application/json');
  try {
        // Check for token in cookies first, then header, then query parameter (for mobile fallback)
        const token = req.cookies.token || 
                     (req.header('Authorization') ? req.header('Authorization').replace('Bearer ', '') : null) ||
                     req.query.token; // Mobile fallback via query parameter

        if (!token) {
            // Log authentication failure with device information
            logSecurityEvent('AUTH_FAILURE', {
                reason: 'No token provided',
                endpoint: req.url,
                userAgent: req.get('User-Agent'),
                cookies: Object.keys(req.cookies),
                hasAuthHeader: !!req.header('Authorization'),
                hasQueryToken: !!req.query.token
            }, req);
            if (isApi || wantsJson) {
                return res.status(401).json({ ok: false, error: 'AUTH_REQUIRED', message: 'Authentication required' });
            }
            return redirectToLogin(res, req, 'auth', 'NO_TOKEN');
        }

        const decoded = jwt.verify(token, JWT_SECRET);

        const userId = decoded.userId != null ? String(decoded.userId) : '';
        const user = await findUserById(userId);
        
        if (!user) {
            // Log authentication failure
            logSecurityEvent('AUTH_FAILURE', {
                reason: 'User not found',
                userId: decoded.userId,
                endpoint: req.url,
                userAgent: req.get('User-Agent')
            }, req);

            throw new Error('User not found');
        }

        req.user = user;
        // Always set id from JWT so downstream findUserById(req.user.id) resolves consistently (avoids redirect loops)
        req.user.id = userId;

        // If token was in URL, set cookie and redirect so token never appears in address bar or DOM
        if (req.method === 'GET' && req.query.token && req.accepts('html')) {
          const host = req.get('host') || '';
          const isLocalhost = host.includes('localhost') || host.includes('127.0.0.1') || process.env.IS_STAGING === 'true';
          const cookieOptions = {
            httpOnly: true,
            maxAge: 6 * 60 * 60 * 1000,
            path: '/',
            secure: !isLocalhost,
            sameSite: isLocalhost ? 'lax' : 'none'
          };
          if (!isLocalhost) cookieOptions.domain = DOMAIN;
          res.cookie('token', token, cookieOptions);
          const q = { ...req.query };
          delete q.token;
          const search = Object.keys(q).length ? '?' + new URLSearchParams(q).toString() : '';
          return res.redirect(302, req.path + search);
        }

        next();
  } catch (error) {
        // Log authentication errors with device information
        logSecurityEvent('AUTH_ERROR', {
            error: error.message,
            endpoint: req.url,
            hasToken: !!req.cookies.token,
            userAgent: req.get('User-Agent'),
            cookies: Object.keys(req.cookies)
        }, req);
        
        // Provide more specific error messages
        let errorMessage = 'Please authenticate.';
        if (error.message === 'jwt malformed') {
            errorMessage = 'Invalid authentication token. Please log in again.';
        } else if (error.message === 'jwt expired') {
            errorMessage = 'Authentication token expired. Please log in again.';
        } else if (error.message === 'invalid signature') {
            errorMessage = 'Invalid authentication token. Please log in again.';
        }
        if (isApi || wantsJson) {
            return res.status(401).json({ ok: false, error: 'AUTH_REQUIRED', message: 'Authentication required' });
        }
        return redirectToLogin(res, req, 'auth', 'INVALID_TOKEN');
    }
};

// Middleware for admin authentication
const adminAuth = async (req, res, next) => {
  const isApi = req.originalUrl?.startsWith('/api/') || req.path?.startsWith('/api/');
  const wantsJson = (req.get('accept') || '').includes('application/json');
  try {
    // Check for token in cookies first, then header
    const token = req.cookies.token || 
                 (req.header('Authorization') ? req.header('Authorization').replace('Bearer ', '') : null);

    if (!token) {
      if (isApi || wantsJson) {
        return res.status(401).json({ ok: false, error: 'AUTH_REQUIRED', message: 'Authentication required' });
      }
      return redirectToLogin(res, req, 'adminAuth', 'NO_TOKEN');
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    const user = await findUserById(decoded.userId);
    
    if (!user) {
      if (isApi || wantsJson) {
        return res.status(401).json({ ok: false, error: 'AUTH_REQUIRED', message: 'Authentication required' });
      }
      return redirectToLogin(res, req, 'adminAuth', 'USER_NOT_FOUND');
    }

    const hasAdminAccess = user.userType === 'app_owner' || user.isAdmin === true;
    
    if (!hasAdminAccess) {
      if (isApi || wantsJson) {
        return res.status(403).json({ ok: false, error: 'AUTH_REQUIRED', message: 'Authentication required' });
      }
      return redirectToLogin(res, req, 'adminAuth', 'NOT_ADMIN');
    }

    req.user = user;
    next();
  } catch (error) {
    console.error('Admin auth middleware error:', error);
    if (isApi || wantsJson) {
      return res.status(401).json({ ok: false, error: 'AUTH_REQUIRED', message: 'Authentication required' });
    }
    return redirectToLogin(res, req, 'adminAuth', 'CATCH');
  }
};

// Helper function to generate 2FA code
const generate2FACode = () => {
  return Math.floor(100000 + Math.random() * 900000).toString(); // 6-digit code
};

// Helper function to generate verification token with both letters and numbers
const generateVerificationToken = () => {
  // Avoid confusing characters: 0, O, I, l, 1, 5, S, 8, B
  const chars = 'ACDEFGHJKMNPQRTUVWXYZacdefghjkmnpqrtuvwxyz234679';
  let result = '';
  
  // Ensure at least one letter and one number
  const letters = 'ACDEFGHJKMNPQRTUVWXYZacdefghjkmnpqrtuvwxyz';
  const numbers = '234679';
  
  // Add one random letter
  result += letters.charAt(Math.floor(Math.random() * letters.length));
  // Add one random number
  result += numbers.charAt(Math.floor(Math.random() * numbers.length));
  
  // Fill the rest with random characters
  for (let i = 2; i < 7; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  
  // Shuffle the result to randomize position of letter and number
  return result.split('').sort(() => Math.random() - 0.5).join('');
};

// Helper function to get user's phone number based on their type
const getUserPhoneNumber = (user) => {
  // Priority 1: For account holders with company, use company phone (business number)
  if (user.company?.phone) {
    return user.company.phone;
  }
  // Priority 2: For team members/invited users without company, use personal phone
  if (user.personalInfo?.phone) {
    return user.personalInfo.phone;
  }
  // No phone number found
  return null;
};

// Helper function to send 2FA code
const send2FACode = async (user, code, method) => {
  try {

    if (method === 'sms') {
      const phoneNumber = getUserPhoneNumber(user);
      
      if (!phoneNumber) {
        throw new Error('No phone number available for SMS');
      }
      
      // Use system-wide phone number for 2FA SMS (admin's purchased number)
      // This allows all users to use SMS 2FA without purchasing their own phone numbers
      const fromNumber = SYSTEM_2FA_PHONE_NUMBER;
      
      if (!fromNumber) {
        throw new Error('System 2FA phone number not configured. Please contact support.');
      }
      
      // Enhanced phone number formatting for Canadian numbers
      let formattedPhone = phoneNumber;
      
      // Remove all non-numeric characters
      const cleanNumber = phoneNumber.replace(/\D/g, '');
      
      // Handle different input formats
      if (cleanNumber.length === 10) {
        // 10-digit number (e.g., 2506087572) - add +1
        formattedPhone = '+1' + cleanNumber;
      } else if (cleanNumber.length === 11 && cleanNumber.startsWith('1')) {
        // 11-digit number starting with 1 (e.g.,  grant75672) - add +
        formattedPhone = '+' + cleanNumber;
      } else if (phoneNumber.startsWith('+1')) {
        // Already formatted with +1
        formattedPhone = phoneNumber;
      } else {
        // Default to +1 format
        formattedPhone = '+1' + cleanNumber;
      }
      
      // Validate the formatted number
      if (!formattedPhone.match(/^\+1[2-9]\d{2}[2-9]\d{6}$/)) {
        throw new Error('Invalid phone number format. Please update your phone number to a valid 10-digit Canadian number.');
      }

      if (!accountSid || !authToken) {
        throw new Error('Twilio credentials not configured. Please contact support.');
      }
      
      const message = await twilioClient.messages.create({
        body: `Your Campaign Builder verification code is: ${code}. This code will expire in 10 minutes.`,
        from: fromNumber,
        to: formattedPhone
      });

    } else if (method === 'email') {
      if (!user.email) {
        throw new Error('No email address available');
      }
      
      // Use system-wide verified sender email (Campaign Builder's main email)
      // This ensures all 2FA emails come from the platform, not individual user accounts
      // Use SYSTEM_EMAIL, or fallback to SMTP_USER to match SMTP authentication
      const fromEmail = process.env.SYSTEM_EMAIL || process.env.SMTP_USER || 'smtp@sw7ft.com';

      const emailResult = await sendTransactionalEmail({
        from: fromEmail,
        to: user.email,
        subject: 'Your Campaign Builder Verification Code',
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2>Two-Factor Authentication Code</h2>
            <p>Your verification code is:</p>
            <div style="font-size: 32px; font-weight: bold; color: #4F46E5; padding: 20px; background-color: #F3F4F6; border-radius: 8px; text-align: center; margin: 20px 0;">
              ${code}
            </div>
            <p>This code will expire in 10 minutes.</p>
            <p>If you didn't request this code, please contact support immediately.</p>
          </div>
        `,
        text: `Your Campaign Builder verification code is: ${code}. This code will expire in 10 minutes.`
      }, user);

    }
  } catch (error) {
    console.error('Failed to send 2FA code:', error);
      console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      code: error.code,
      status: error.status,
      method: method,
      email: method === 'email' ? user.email : 'N/A',
      phoneNumber: method === 'sms' ? getUserPhoneNumber(user) : 'N/A'
    });
    
    // Provide more specific error messages for SMS
    if (method === 'sms') {
      if (error.code === 21211) {
        throw new Error('Invalid phone number format. Please check your phone number and try again.');
      } else if (error.code === 21610) {
        throw new Error('Phone number is not a valid mobile number. Please use a mobile phone number.');
      } else if (error.code === 21408) {
        throw new Error('Permission to send SMS to this number denied. Please contact support.');
      } else if (error.code === 20003) {
        throw new Error('Authentication failed. Please contact support.');
      } else if (error.code === 21614) {
        throw new Error('Invalid phone number. Please check your phone number and try again.');
      }
    }
    
    throw error;
  }
};

// 2FA endpoints (SMS/Email based)
app.post('/api/2fa/enable', auth, async (req, res) => {
  try {
    const { method } = req.body; // 'sms' or 'email'
    const user = await findUserById(req.user.id);
    
    if (user.is2FAEnabled) {
      return res.status(400).json({ error: '2FA is already enabled' });
    }

    // Validate that user has the required contact method
    if (method === 'sms') {
      const userPhone = getUserPhoneNumber(user);
      if (!userPhone) {
        return res.status(400).json({ 
          error: 'Phone number required for SMS 2FA. Please add a phone number to your profile first.',
          requiresPhone: true 
        });
      }
      // Note: Users no longer need to purchase their own phone numbers for 2FA
      // The system uses the admin's phone number for sending 2FA codes
    }
    
    if (method === 'email' && !user.email) {
      return res.status(400).json({ 
        error: 'Email address required for email 2FA.',
        requiresEmail: true 
      });
    }

    // Generate and send verification code
    const code = generate2FACode();
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

    // Store pending 2FA setup
    user.pending2FA = {
      code: encryptField(code),
      method: method,
      expiresAt: expiresAt.toISOString(),
      createdAt: new Date().toISOString()
    };

    await writeIndividualUserFile(user.id, user);
    
    const contactInfo = method === 'sms' ? getUserPhoneNumber(user) : user.email;

    try {
      await send2FACode(user, code, method);

      res.json({ 
        success: true, 
        method: method,
        message: method === 'sms' 
          ? `Verification code sent to ${getUserPhoneNumber(user)}` 
          : `Verification code sent to ${user.email}`
      });
    } catch (sendError) {
      console.error('Failed to send 2FA code:', sendError);
      console.error('Error details:', {
        message: sendError.message,
        stack: sendError.stack,
        method: method,
        userEmail: user.email,
        contactInfo: contactInfo
      });
      res.status(500).json({ 
        error: sendError.message || 'Failed to send verification code. Please try again.',
        details: sendError.message
      });
    }
  } catch (error) {
    console.error('2FA enable error:', error);
    res.status(500).json({ error: error.message || 'Failed to enable 2FA' });
  }
});

// Endpoint for verifying 2FA codes during login (requires authentication)
app.post('/api/2fa/verify', auth, async (req, res) => {
  try {
    const { code } = req.body;
    const user = await findUserById(req.user.id);
    
    if (!user.loginSession) {
      return res.status(400).json({ error: 'No active 2FA session' });
    }

    // Check if code is expired
    if (new Date() > new Date(user.loginSession.expiresAt)) {
      user.loginSession = null;
      await writeIndividualUserFile(user.id, user);
      return res.status(400).json({ error: 'Verification code has expired. Please try again.' });
    }

    // Verify code
    const storedCode = decryptField(user.loginSession.code);
    if (code !== storedCode) {
      return res.status(400).json({ error: 'Invalid verification code' });
    }

    // Clear login session and proceed with login
    user.loginSession = null;
    user.lastLoginAt = new Date().toISOString();
    await writeIndividualUserFile(user.id, user);
    
    // Generate JWT with expiration (6 hours for access token)
    const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '6h' });
    
    // Generate refresh token (7 days)
    const refreshToken = jwt.sign({ userId: user.id, type: 'refresh' }, JWT_SECRET, { expiresIn: '7d' });
    
    const isProduction = process.env.NODE_ENV === 'production';
    
    // Detect iPad Safari and adjust cookie settings accordingly
    const userAgent = req.get('User-Agent') || '';
    const isIPadSafari = /iPad|iPhone|iPod/.test(userAgent) && /Safari/.test(userAgent);
    
    // Detect if we're on localhost/staging
    const host = req.get('host') || '';
    const isLocalhost = host.includes('localhost') || host.includes('127.0.0.1') || process.env.IS_STAGING === 'true';
    
    // Set access token cookie (6 hours) - iPad Safari compatible settings
    const cookieOptions = {
        httpOnly: true,
        maxAge: 6 * 60 * 60 * 1000, // 6 hours
        path: '/'
    };
    
    // For localhost/staging, use permissive settings
    if (isLocalhost) {
        cookieOptions.secure = false; // HTTP on localhost
        cookieOptions.sameSite = 'lax'; // Works with HTTP
        // Don't set domain for localhost - let it use default
    } else if (isMobileDevice) {
        cookieOptions.secure = false; // Mobile devices sometimes have issues with secure cookies
        cookieOptions.sameSite = 'lax'; // More permissive than 'none'
        // Don't set domain for mobile devices - let it use default
    } else {
        cookieOptions.secure = true;
        cookieOptions.sameSite = 'none';
        cookieOptions.domain = 'campaignbuilder.ca';
    }
    
    res.cookie('token', token, cookieOptions);
    
    // Set refresh token cookie (7 days) - iPad Safari compatible settings
    const refreshCookieOptions = {
        httpOnly: true,
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
        path: '/'
    };
    
    if (isLocalhost) {
        refreshCookieOptions.secure = false;
        refreshCookieOptions.sameSite = 'lax';
    } else if (isMobileDevice) {
        refreshCookieOptions.secure = false;
        refreshCookieOptions.sameSite = 'lax';
    } else {
        refreshCookieOptions.secure = true;
        refreshCookieOptions.sameSite = 'none';
        refreshCookieOptions.domain = 'campaignbuilder.ca';
    }
    
    res.cookie('refreshToken', refreshToken, refreshCookieOptions);
    
    res.json({ success: true, message: '2FA verification successful!' });
  } catch (error) {
    console.error('2FA verify error:', error);
    res.status(500).json({ error: 'Failed to verify 2FA code' });
  }
});

// Endpoint for verifying 2FA setup codes (no authentication required)
app.post('/api/2fa/verify-setup', async (req, res) => {
  try {
    const { email, password, code } = req.body;

    if (!email || !password || !code) {
      return res.status(400).json({ error: 'Email, password, and code are required' });
    }
    
    // Find all users with this email (same email can exist in multiple accounts)
    const usersWithEmail = await findAllUsersByEmail(email);
    
    if (!usersWithEmail || usersWithEmail.length === 0) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Try to authenticate against each user until we find a match
    let authenticatedUser = null;
    
    for (const userCandidate of usersWithEmail) {
      try {
        // Check if this user has a password
        if (!userCandidate.password) {
          continue;
        }
        
        const isPasswordValid = await bcrypt.compare(password, userCandidate.password);
        
        if (isPasswordValid) {
          authenticatedUser = userCandidate;
          break; // Found the correct user, stop checking
        }
      } catch (bcryptError) {
        // Continue checking other users
        continue;
      }
    }
    
    if (!authenticatedUser) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Use the authenticated user
    const user = authenticatedUser;

    if (!user.pending2FA) {
      return res.status(400).json({ error: '2FA setup not initialized' });
    }

    // Check if code is expired
    if (new Date() > new Date(user.pending2FA.expiresAt)) {
      user.pending2FA = null;
      await writeIndividualUserFile(user.id, user);
      return res.status(400).json({ error: 'Verification code has expired. Please try again.' });
    }

    // Verify code
    const storedCode = decryptField(user.pending2FA.code);

    if (code !== storedCode) {
      return res.status(400).json({ error: 'Invalid verification code' });
    }

    // Enable 2FA
    user.is2FAEnabled = true;
    user.twoFactorMethod = user.pending2FA.method;
    user.pending2FA = null;
    user.lastLoginAt = new Date().toISOString();
    
    await writeIndividualUserFile(user.id, user);
    
    // Generate JWT with expiration (6 hours for access token)
    const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '6h' });
    
    // Generate refresh token (7 days)
    const refreshToken = jwt.sign({ userId: user.id, type: 'refresh' }, JWT_SECRET, { expiresIn: '7d' });
    
    const isProduction = process.env.NODE_ENV === 'production';
    
    // Detect if we're on localhost/staging
    const host = req.get('host') || '';
    const isLocalhost = host.includes('localhost') || host.includes('127.0.0.1') || process.env.IS_STAGING === 'true';
    
    // Set access token cookie (6 hours)
    const cookieOptions = {
      httpOnly: true,
      maxAge: 6 * 60 * 60 * 1000, // 6 hours
      path: '/'
    };
    
    if (isLocalhost) {
      cookieOptions.secure = false;
      cookieOptions.sameSite = 'lax';
    } else {
      cookieOptions.secure = true;
      cookieOptions.sameSite = 'none';
      cookieOptions.domain = 'campaignbuilder.ca';
    }
    
    res.cookie('token', token, cookieOptions);
    
    // Set refresh token cookie (7 days)
    const refreshCookieOptions = {
      httpOnly: true,
      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      path: '/'
    };
    
    if (isLocalhost) {
      refreshCookieOptions.secure = false;
      refreshCookieOptions.sameSite = 'lax';
    } else {
      refreshCookieOptions.secure = true;
      refreshCookieOptions.sameSite = 'none';
      refreshCookieOptions.domain = 'campaignbuilder.ca';
    }
    
    res.cookie('refreshToken', refreshToken, refreshCookieOptions);

    res.json({ success: true, message: '2FA has been successfully enabled!' });
  } catch (error) {
    console.error('2FA setup verify error:', error);
    res.status(500).json({ error: 'Failed to verify 2FA setup code' });
  }
});

app.post('/api/2fa/disable', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    user.is2FAEnabled = false;
    user.twoFactorMethod = null;
    user.pending2FA = null;
    await writeIndividualUserFile(user.id, user);
    res.json({ success: true, message: '2FA has been disabled.' });
  } catch (error) {
    console.error('2FA disable error:', error);
    res.status(500).json({ error: 'Failed to disable 2FA' });
  }
});

// Endpoint to request 2FA code during login
app.post('/api/2fa/request-login-code', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ error: 'Email is required' });
    }
    
    const user = await findUserByEmail(email);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    if (!user.is2FAEnabled) {
      return res.status(400).json({ error: '2FA is not enabled for this account' });
    }
    
    // Generate and send verification code
    const code = generate2FACode();
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes
    
    // Store login session
    user.loginSession = {
      code: encryptField(code),
      expiresAt: expiresAt.toISOString(),
      createdAt: new Date().toISOString()
    };
    
    await writeIndividualUserFile(user.id, user);
    await send2FACode(user, code, user.twoFactorMethod);
    
    const method = user.twoFactorMethod;
    // Get the user's actual phone number (from personalInfo or company)
    const userPhone = getUserPhoneNumber(user);
    const maskedContact = method === 'sms' 
      ? userPhone?.replace(/(\d{3})\d{3}(\d{4})/, '$1***$2') 
      : user.email?.replace(/(.{2}).*(@.*)/, '$1***$2');
    
    res.json({ 
      success: true,
      method: method,
      contact: maskedContact,
      message: `Verification code sent to your ${method === 'sms' ? 'phone' : 'email'}`
    });
  } catch (error) {
    console.error('Request login code error:', error);
    res.status(500).json({ error: 'Failed to send verification code' });
  }
});

// Get global SMTP transporter configurations (primary + IPv6 fallback)
const getGlobalTransporters = () => {
  const transporters = [];
  
  // Primary SMTP server (IPv4)
  const primaryHost = process.env.SMTP_HOST || 'mail.sw7ft.com';
  const primaryPort = parseInt(process.env.SMTP_PORT) || 587;
  const primarySecure = process.env.SMTP_SECURE === 'true';
  const primaryUser = process.env.SMTP_USER || process.env.EMAIL_USER;
  const primaryPass = process.env.SMTP_PASS || process.env.EMAIL_PASSWORD;
  
  if (primaryHost && primaryUser && primaryPass) {
    transporters.push({
      host: primaryHost,
      port: primaryPort,
      secure: primarySecure,
      pool: true, // Enable connection pooling
      maxConnections: 1, // Limit to 1 connection at a time
      maxMessages: 100, // Max messages per connection
      rateDelta: 1000, // 1 second
      rateLimit: 5, // Max 5 messages per second
      auth: {
        user: primaryUser,
        pass: primaryPass
      },
      name: primaryHost
    });
  }
  
  // IPv6 fallback SMTP server
  const ipv6Host = process.env.SMTP_HOST_V6 || 'deliverv6.sw7ft.com';
  const ipv6Port = parseInt(process.env.SMTP_PORT_V6) || 8025;
  const ipv6Secure = process.env.SMTP_SECURE_V6 === 'true';
  const ipv6User = process.env.SMTP_USER_V6;
  const ipv6Pass = process.env.SMTP_PASS_V6;
  
  if (ipv6Host && ipv6User && ipv6Pass) {
    transporters.push({
      host: ipv6Host,
      port: ipv6Port,
      secure: ipv6Secure,
      family: 6, // Force IPv6
      pool: true, // Enable connection pooling
      maxConnections: 1, // Limit to 1 connection at a time
      maxMessages: 100, // Max messages per connection
      rateDelta: 1000, // 1 second
      rateLimit: 5, // Max 5 messages per second
      auth: {
        user: ipv6User,
        pass: ipv6Pass
      },
      name: `${ipv6Host} (IPv6 fallback)`
    });
  }
  
  return transporters;
};

// Create global SMTP transporters with rotation support
const globalTransporters = getGlobalTransporters().map(config => {
  const { name, ...transporterConfig } = config;
  return {
    name,
    transporter: nodemailer.createTransport(transporterConfig),
    config: transporterConfig
  };
});

// Legacy single transporter for backward compatibility (uses first global transporter)
const transporter = globalTransporters.length > 0 ? globalTransporters[0].transporter : null;

// Cache for user-specific SMTP transporters
const userTransporterCache = new Map();

// Get user-specific SMTP transporter (creates one if user has custom SMTP settings)
const getUserSMTPTransporter = async (user) => {
    try {
        const accountId = getEffectiveAccountId(user);
        const smtpSettingsPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'smtp-settings.json');
        
        // Check cache first
        if (userTransporterCache.has(accountId)) {
            console.log(`[SMTP] Using cached transporter for account ${accountId}`);
            return userTransporterCache.get(accountId);
        }
        
        // Check if user has custom SMTP settings
        if (fs.existsSync(smtpSettingsPath)) {
            const data = await fsPromises.readFile(smtpSettingsPath, 'utf8');
            const smtpSettings = JSON.parse(data);
            
            // Validate SMTP settings
            if (smtpSettings.host && smtpSettings.user && smtpSettings.pass) {
                console.log(`[SMTP] Creating custom transporter for account ${accountId} using ${smtpSettings.host}:${smtpSettings.port || 587}`);
                console.log(`[SMTP] SMTP username: ${smtpSettings.user}`);
                console.log(`[SMTP] SMTP password: ${smtpSettings.pass ? '***SET***' : 'MISSING'}`);
                console.log(`[SMTP] SMTP secure: ${smtpSettings.secure === true || smtpSettings.port === 465}`);
                
                // Create user-specific transporter with connection pooling
                const transporterConfig = {
                    host: smtpSettings.host,
                    port: parseInt(smtpSettings.port) || 587,
                    secure: smtpSettings.secure === true || smtpSettings.port === 465,
                    pool: true, // Enable connection pooling
                    maxConnections: 1, // Limit to 1 connection at a time to prevent overwhelming SMTP server
                    maxMessages: 100, // Max messages per connection before reconnecting
                    rateDelta: 1000, // 1 second
                    rateLimit: 5, // Max 5 messages per rateDelta (5 per second)
                    auth: {
                        user: smtpSettings.user,
                        pass: smtpSettings.pass
                    }
                };
                
                // Handle TLS options
                if (smtpSettings.ignoreTLS) {
                    // No encryption at all
                    transporterConfig.ignoreTLS = true;
                    transporterConfig.secure = false;
                } else if (smtpSettings.requireTLS) {
                    // STARTTLS (upgrade to TLS)
                    transporterConfig.requireTLS = true;
                    transporterConfig.secure = false;
                }
                
                const userTransporter = nodemailer.createTransport(transporterConfig);
                
                // Try to verify connection (non-blocking - don't fail if verification fails)
                userTransporter.verify().then(() => {
                    console.log(`[SMTP] Custom SMTP connection verified for account ${accountId}`);
                }).catch((verifyError) => {
                    console.warn(`[SMTP] Custom SMTP verification warning for account ${accountId}:`, verifyError.message);
                    // Don't throw - we'll still try to use the transporter
                });
                
                // Cache the transporter (even if verification hasn't completed yet)
                userTransporterCache.set(accountId, userTransporter);
                
                return userTransporter;
            } else {
                console.log(`[SMTP] Custom SMTP settings found for account ${accountId} but missing required fields (host: ${!!smtpSettings.host}, user: ${!!smtpSettings.user}, pass: ${!!smtpSettings.pass})`);
            }
        } else {
            console.log(`[SMTP] No custom SMTP settings found for account ${accountId}, using global SMTP`);
        }
        
        // Fall back to global transporters (with rotation support)
        return getGlobalSMTPTransporter();
    } catch (error) {
        console.error(`[SMTP] Error getting user SMTP transporter for account ${getEffectiveAccountId(user)}:`, error.message);
        // Fall back to global transporters on error
        return getGlobalSMTPTransporter();
    }
};

// Get global SMTP transporter with rotation support
// Returns an object with transporter and rotation logic
const getGlobalSMTPTransporter = () => {
  if (globalTransporters.length === 0) {
    throw new Error('No global SMTP transporters configured. Please set SMTP environment variables.');
  }
  
  // Return first transporter for direct use, rotation handled in send functions
  return globalTransporters[0].transporter;
};

// Check if user is eligible for IPv6 fallback (EDA or app owner/admin only)
const isEligibleForIPv6Fallback = (user) => {
  if (!user) return false;
  
  // Check account type
  if (user.accountType === ACCOUNT_TYPES.EDA || user.accountType === ACCOUNT_TYPES.APP_OWNER) {
    return true;
  }
  
  // Check legacy admin flags
  if (user.userType === 'app_owner' || user.isAdmin === true) {
    return true;
  }
  
  // For team members, check their account holder
  if (user.accountId && user.accountId !== user.id) {
    // This will be checked when we have the account holder user object
    // For now, return false and check will be done in calling function
    return false;
  }
  
  return false;
};

// Send email with automatic rotation through global transporters
// Only uses IPv6 fallback for EDA or app owner/admin accounts
const sendWithGlobalTransporters = async (mailOptions, user = null) => {
  if (globalTransporters.length === 0) {
    throw new Error('No global SMTP transporters configured');
  }
  
  // Check if user is eligible for IPv6 fallback
  let eligibleForIPv6 = false;
  if (user) {
    eligibleForIPv6 = isEligibleForIPv6Fallback(user);
    
    // For team members, check their account holder
    if (!eligibleForIPv6 && user.accountId && user.accountId !== user.id) {
      try {
        const accountHolder = await findUserById(user.accountId);
        if (accountHolder) {
          eligibleForIPv6 = isEligibleForIPv6Fallback(accountHolder);
        }
      } catch (error) {
        console.error('[SMTP] Error checking account holder for IPv6 eligibility:', error.message);
      }
    }
  }
  
  // Filter transporters based on eligibility
  // Primary transporter is always available
  // IPv6 fallback only for eligible accounts
  const availableTransporters = globalTransporters.filter((transporter, index) => {
    if (index === 0) {
      // Always include primary transporter
      return true;
    }
    // Only include IPv6 fallback if eligible
    return eligibleForIPv6;
  });
  
  if (availableTransporters.length === 0) {
    throw new Error('No available SMTP transporters');
  }
  
  let lastError = null;
  
  for (let i = 0; i < availableTransporters.length; i++) {
    const { transporter, name } = availableTransporters[i];
    
    try {
      console.log(`[SMTP] Attempting to send via ${name}...`);
      const result = await transporter.sendMail(mailOptions);
      console.log(`âœ… Sent via ${name}`);
      return { result, via: name };
    } catch (error) {
      lastError = error;
      
      // Check if error is retryable (connection error, timeout, blacklist)
      const isRetryableError = 
        error.code === 'ECONNREFUSED' ||
        error.code === 'ETIMEDOUT' ||
        error.code === 'ENOTFOUND' ||
        error.code === 'ECONNRESET' ||
        error.message?.includes('timeout') ||
        error.message?.includes('connection') ||
        error.message?.includes('blacklist') ||
        error.message?.includes('blocked');
      
      console.error(`[SMTP] Failed to send via ${name}:`, error.message);
      
      // If this is the last transporter, throw the error
      if (i === availableTransporters.length - 1) {
        throw error;
      }
      
      // If error is retryable, try next transporter
      if (isRetryableError) {
        console.log(`[SMTP] Retrying with next transporter...`);
        continue;
      } else {
        // Non-retryable error (e.g., authentication failure), throw immediately
        throw error;
      }
    }
  }
  
  // Should never reach here, but just in case
  throw lastError || new Error('Failed to send email via all transporters');
};

// Clear transporter cache (useful when SMTP settings are updated)
const clearUserSMTPCache = (accountId) => {
    if (userTransporterCache.has(accountId)) {
        console.log(`[SMTP] Clearing cached transporter for account ${accountId}`);
        userTransporterCache.delete(accountId);
    }
};

// Centralized transactional email helper: SMTP with rotation support
// Note: Transactional emails use system account, so IPv6 fallback is available.
// Use SMTP_USER as From when possible so the envelope sender matches SMTP auth (many servers reject otherwise).
const sendTransactionalEmail = async ({ from, to, subject, html, text, fromName, messageStream = 'outbound' }, user = null) => {
  try {
    const smtpUser = process.env.SMTP_USER || process.env.EMAIL_USER;
    const systemEmail = process.env.SYSTEM_EMAIL || smtpUser || 'smtp@sw7ft.com';
    const fromEmail = from || smtpUser || systemEmail;
    if (!fromEmail) {
      throw new Error('From email address is required. Set SMTP_USER, SYSTEM_EMAIL or EMAIL_USER environment variable.');
    }
    
    // Format the from address with a friendly name if provided
    const formattedFrom = fromName 
      ? `${fromName} <${fromEmail}>`
      : fromEmail;
    
    const mailOptions = {
      from: formattedFrom,
      to,
      subject,
      html,
      text
    };
    
    // Use global transporters with rotation for transactional emails (system emails)
    // Pass user if available to check IPv6 eligibility
    const { via } = await sendWithGlobalTransporters(mailOptions, user);
    
    return { ok: true, via: via || 'smtp' };
  } catch (error) {
    // Don't log sensitive information in error messages
    const errorMessage = error.message || 'Unknown error';
    console.error('[SMTP] Transactional email send failed:', errorMessage);
    throw error;
  }
};

// System sender initialization (no longer needed with SMTP, but kept for compatibility)
const initializeSystemSender = async () => {
  try {
    // SMTP doesn't require sender signature initialization
    // Use SYSTEM_EMAIL or SMTP_USER to match SMTP authentication credentials
    const systemEmail = process.env.SYSTEM_EMAIL || process.env.SMTP_USER || 'smtp@sw7ft.com';

    return null;
  } catch (error) {
    console.error('Error initializing system sender:', error);
    return null;
  }
};

// Update the sendVerificationEmail function to use the system sender
const sendVerificationEmail = async (email, token) => {
  try {
    // Use SYSTEM_EMAIL or SMTP_USER to match SMTP authentication credentials
    const systemEmail = process.env.SYSTEM_EMAIL || process.env.SMTP_USER || 'smtp@sw7ft.com';

    // Try to find user by email to check IPv6 eligibility
    let userForEligibility = null;
    try {
      const userByEmail = await findUserByEmail(email);
      if (userByEmail) {
        userForEligibility = userByEmail;
      }
    } catch (error) {
      // If user not found, that's okay - will default to primary server only
    }

    const result = await sendTransactionalEmail({
      from: systemEmail,
      to: email,
      subject: 'Verify Your Email - Campaign Builder',
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h1>Welcome to Campaign Builder!</h1>
          <p>Please verify your email address by entering this code:</p>
          <div style="font-size: 32px; font-weight: bold; color: #4F46E5; padding: 20px; background-color: #F3F4F6; border-radius: 8px; text-align: center; margin: 20px 0; letter-spacing: 2px;">
            ${token}
          </div>
          <p style="color: #6B7280; font-size: 14px;">This code will expire in 24 hours.</p>
          <p style="color: #6B7280; font-size: 14px;">If you didn't request this, please ignore this email.</p>
        </div>
      `,
      text: `Welcome to Campaign Builder! Your verification code is: ${token}. This code will expire in 24 hours.`,
      messageStream: 'outbound'
    }, userForEligibility);

  } catch (error) {
    console.error('Error sending verification email:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      code: error.code,
      status: error.status
    });
    // Instead of failing silently, we'll throw the error to be handled by the registration endpoint
    throw new Error('Failed to send verification email. Please try again later.');
  }
};

const sendSMSVerification = async (phoneNumber, token) => {
  try {

    const verificationLink = `${BASE_URL}/verify?token=${token}`;
    
    // Enhanced phone number formatting for Canadian numbers
    let formattedPhoneNumber = phoneNumber;
    
    // Remove all non-numeric characters
    const cleanNumber = phoneNumber.replace(/\D/g, '');
    
    // Handle different input formats
    if (cleanNumber.length === 10) {
      // 10-digit number (e.g., 2506087572) - add +1
      formattedPhoneNumber = '+1' + cleanNumber;
    } else if (cleanNumber.length === 11 && cleanNumber.startsWith('1')) {
      // 11-digit number starting with 1 (e.g., 12506087572) - add +
      formattedPhoneNumber = '+' + cleanNumber;
    } else if (phoneNumber.startsWith('+1')) {
      // Already formatted with +1
      formattedPhoneNumber = phoneNumber;
    } else {
      // Default to +1 format
      formattedPhoneNumber = '+1' + cleanNumber;
    }
    
    // Validate the formatted number
    if (!formattedPhoneNumber.match(/^\+1[2-9]\d{2}[2-9]\d{6}$/)) {
      throw new Error('Invalid phone number format. Please enter a valid 10-digit Canadian phone number.');
    }

    // Validate Twilio credentials
    if (!accountSid || !authToken) {
      throw new Error('Twilio credentials not configured. Please contact support.');
    }
    
    if (!SYSTEM_2FA_PHONE_NUMBER) {
      throw new Error('System phone number not configured. Please contact support.');
    }
    
    const message = await twilioClient.messages.create({
      from: SYSTEM_2FA_PHONE_NUMBER,
      to: formattedPhoneNumber,
      body: `Your Campaign Builder verification code is: ${token}\n\nThis code will expire in 10 minutes.`,
      statusCallback: `${BASE_URL}/api/webhooks/status/verification`,
      provideFeedback: true
    });

    return { ok: true, messageSid: message.sid };
  } catch (error) {
    console.error('=== SMS VERIFICATION FUNCTION ERROR ===');
    console.error('Error sending SMS verification:', error);
    console.error('Error details:', {
      message: error.message,
      code: error.code,
      status: error.status,
      phoneNumber: phoneNumber,
      formattedPhoneNumber: formattedPhoneNumber
    });
    
    // Provide more specific error messages
    if (error.code === 21211) {
      throw new Error('Invalid phone number format. Please check your phone number and try again.');
    } else if (error.code === 21610) {
      throw new Error('Phone number is not a valid mobile number. Please use a mobile phone number.');
    } else if (error.code === 21408) {
      throw new Error('Permission to send SMS to this number denied. Please contact support.');
    } else if (error.code === 20003) {
      throw new Error('Authentication failed. Please contact support.');
    } else if (error.code === 21614) {
      throw new Error('Invalid phone number. Please check your phone number and try again.');
    } else {
      throw new Error(`Failed to send SMS verification: ${error.message}. Please try again later.`);
    }
  }
};

const sendPasswordResetEmail = async (email, code) => {
  try {
    // Try to find user by email to check IPv6 eligibility
    let userForEligibility = null;
    try {
      const userByEmail = await findUserByEmail(email);
      if (userByEmail) {
        userForEligibility = userByEmail;
      }
    } catch (error) {
      // If user not found, that's okay - will default to primary server only
    }

    const html = `
      <div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;\">\n        <div style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; text-align: center;\">\n          <h1 style=\"color: white; margin: 0;\">Campaign Builder</h1>\n        </div>\n        <div style=\"padding: 30px; background: #f8f9fa;\">\n          <h2 style=\"color: #333; margin-bottom: 20px;\">Password Reset Request</h2>\n          <p style=\"color: #666; line-height: 1.6; margin-bottom: 20px;\">\n            You requested a password reset for your Campaign Builder account. Use the verification code below to reset your password:\n          </p>\n          <div style=\"text-align: center; margin: 30px 0;\">\n            <div style=\"background: #667eea; color: white; padding: 20px; border-radius: 10px; font-size: 24px; font-weight: bold; letter-spacing: 5px; display: inline-block;\">\n              ${code}\n            </div>\n          </div>\n          <p style=\"color: #666; line-height: 1.6; margin-bottom: 20px;\">\n            This verification code will expire in 15 minutes. If you didn't request a password reset, you can safely ignore this email.\n          </p>\n          <p style=\"color: #666; line-height: 1.6; margin-bottom: 20px;\">\n            For security reasons, please do not share this code with anyone. Our support team will never ask for this code.\n          </p>\n          <hr style=\"border: none; border-top: 1px solid #ddd; margin: 30px 0;\">\n          <p style=\"color: #999; font-size: 12px; text-align: center;\">\n            Campaign Builder - Your all-in-one platform for SMS and email marketing campaigns\n          </p>\n        </div>\n      </div>`;
    // Use SYSTEM_EMAIL for system-wide transactional emails, default to info@campaignbuilder.ca
    const systemEmail = process.env.SYSTEM_EMAIL || 'info@campaignbuilder.ca';
    await sendTransactionalEmail({
      from: systemEmail,
      to: email,
      subject: 'Password Reset Code - Campaign Builder',
      html,
      text: `Password Reset Request - Campaign Builder\n\nYour verification code is: ${code}\n\nThis code will expire in 15 minutes.`,
      messageStream: 'outbound'
    }, userForEligibility);
  } catch (error) {
    console.error('Error sending password reset email:', error);
    throw new Error('Failed to send password reset email. Please try again later.');
  }
};

const sendReceiptEmail = async (user, invoice) => {
  try {
    // Get account holder email if this is a team member
    let recipientEmail = user.email;
    if (user.accountId && user.accountId !== user.id) {
      const accountHolder = await findUserById(user.accountId);
      if (accountHolder) {
        recipientEmail = accountHolder.email;
      }
    }

    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; text-align: center;">
          <h1 style="color: white; margin: 0;">Campaign Builder</h1>
        </div>
        <div style="padding: 30px; background: #f8f9fa;">
          <h2 style="color: #333; margin-bottom: 20px;">Payment Receipt</h2>
          <p style="color: #666; line-height: 1.6; margin-bottom: 20px;">
            Thank you for your payment! Your invoice has been successfully processed.
          </p>
          
          <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <h3 style="color: #333; margin-bottom: 15px;">Receipt Details</h3>
            <div style="margin-bottom: 10px;">
              <strong>Receipt #:</strong> ${invoice.id}
            </div>
            <div style="margin-bottom: 10px;">
              <strong>Date:</strong> ${new Date(invoice.createdAt).toLocaleDateString()}
            </div>
            <div style="margin-bottom: 10px;">
              <strong>Status:</strong> <span style="color: #28a745; font-weight: bold;">Paid</span>
            </div>
            <div style="margin-bottom: 15px;">
              <strong>Total Amount:</strong> $${invoice.amount.toFixed(2)} CAD
            </div>
            
            <h4 style="color: #333; margin: 20px 0 10px 0;">Items Purchased:</h4>
            <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
              <thead>
                <tr style="background: #f8f9fa;">
                  <th style="text-align: left; padding: 8px; border-bottom: 1px solid #ddd;">Description</th>
                  <th style="text-align: right; padding: 8px; border-bottom: 1px solid #ddd;">Quantity</th>
                  <th style="text-align: right; padding: 8px; border-bottom: 1px solid #ddd;">Price</th>
                  <th style="text-align: right; padding: 8px; border-bottom: 1px solid #ddd;">Total</th>
                </tr>
              </thead>
              <tbody>
                ${invoice.items.map(item => `
                  <tr>
                    <td style="padding: 8px; border-bottom: 1px solid #eee;">${item.description}</td>
                    <td style="text-align: right; padding: 8px; border-bottom: 1px solid #eee;">${item.quantity}</td>
                    <td style="text-align: right; padding: 8px; border-bottom: 1px solid #eee;">$${item.unitPrice.toFixed(2)}</td>
                    <td style="text-align: right; padding: 8px; border-bottom: 1px solid #eee;">$${item.total.toFixed(2)}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
          
          <p style="color: #666; line-height: 1.6; margin-bottom: 20px;">
            This receipt serves as proof of payment for your records. If you have any questions about this transaction, please contact our support team.
          </p>
          
          <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;">
          <p style="color: #999; font-size: 12px; text-align: center;">
            Campaign Builder - Your all-in-one platform for SMS and email marketing campaigns
          </p>
        </div>
      </div>`;

    // Use SYSTEM_EMAIL for system-wide transactional emails, default to info@campaignbuilder.ca
    const systemEmail = process.env.SYSTEM_EMAIL || 'info@campaignbuilder.ca';
    await sendTransactionalEmail({
      from: systemEmail,
      to: recipientEmail,
      subject: `Payment Receipt - Campaign Builder (${invoice.id})`,
      html,
      text: `Payment Receipt - Campaign Builder\n\nReceipt #: ${invoice.id}\nDate: ${new Date(invoice.createdAt).toLocaleDateString()}\nTotal: $${invoice.amount.toFixed(2)} CAD\n\nThank you for your payment!`,
      messageStream: 'outbound'
    }, user);

  } catch (error) {
    console.error('Error sending receipt email:', error);
    // Don't throw error to avoid breaking the payment flow
  }
};

// Resend confirmation email endpoint
app.post('/api/resend-confirmation', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ error: 'Email address is required' });
    }
    
    // Find user by email
    const user = await findUserByEmail(email);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Check if user is already verified
    if (user.isVerified) {
      return res.status(400).json({ error: 'Account is already verified' });
    }
    
    // Check if user has a verification token
    if (!user.verificationToken) {
      // Generate new verification token
      user.verificationToken = generateVerificationToken();
      
      // Update user file
      try {
        await writeIndividualUserFile(user.id, user);

      } catch (error) {
        console.error(`Failed to update user file for ${email}:`, error);
        return res.status(500).json({ error: 'Failed to generate verification token' });
      }
    }
    
    // Send verification email
    let emailSent = false;
    try {

      await sendVerificationEmail(email, user.verificationToken);

      emailSent = true;
    } catch (emailError) {
      console.error(`Failed to resend verification email to ${email}:`, emailError);

    }
    
    // If email failed and user has a phone number, try SMS
    if (!emailSent && user.company && user.company.phone) {
      try {

        await sendSMSVerification(user.company.phone, user.verificationToken);

        res.json({ 
          success: true,
          message: 'Confirmation sent via SMS! Please check your phone to verify your account.' 
        });
        return;
      } catch (smsError) {
        console.error(`Failed to send SMS verification to ${user.company.phone}:`, smsError);

      }
    }
    
    if (emailSent) {
      res.json({ 
        success: true,
        message: 'Confirmation email sent successfully! Please check your email to verify your account.' 
      });
    } else {
      res.status(500).json({ error: 'Failed to send confirmation. Please try again later.' });
    }
  } catch (error) {
    console.error('Resend confirmation error:', error);
    res.status(500).json({ error: 'An error occurred. Please try again.' });
  }
});

// Auth Routes
app.post('/api/register', async (req, res) => {
  try {
    const { email, username, password, company, verificationMethod = 'email' } = req.body;
    
    // Validate password strength
    const passwordValidation = validatePassword(password);
    if (!passwordValidation.isValid) {
      return res.status(400).json({ 
        error: 'Password does not meet security requirements',
        details: passwordValidation.errors
      });
    }
    
    if (await findUserByEmail(email)) {
      throw new Error('Email already exists');
    }
    
    // Check if username is provided and unique
    if (username) {
      const userIds = await getAllUserIds();
      for (const userId of userIds) {
        const user = await findUserById(userId);
        if (user && user.username === username) {
          throw new Error('Username already exists');
        }
      }
    }

    const hashedPassword = await bcrypt.hash(password, 12); // Increased salt rounds for better security
    const verificationToken = generateVerificationToken();
    
    const newUser = {
      id: Date.now().toString(),
      email,
      username: username || null,
      password: hashedPassword,
      verificationToken,
      isVerified: false, // Enable email verification - CRITICAL: Must be false
      is2FAEnabled: false,
      tokenBalance: 0,
      contacts: [],
      messageTemplates: [],
      autoReply: {
        isEnabled: false,
        message: ''
      },
      // Add embedded documents
      smsMessages: {
        sent: [],
        received: []
      },
      tokenTransactions: [],
      messages: [],
      invoices: [],
      // Add missing token fields
      smsTokens: 0,
      emailTokens: 0,
      // Add missing fields that might be used
      phoneNumbers: [],
      isAdmin: false,
      createdAt: new Date().toISOString(),
      lastLoginAt: null,
      // Add company information if provided
      company: company || null,
      // User type and account information
      userType: 'account_holder', // New users are account holders by default
      accountId: Date.now().toString(), // Each user becomes their own account holder
      invitedBy: null,
      permissions: [
        'manage_account', 'manage_contacts', 'manage_campaigns', 'manage_templates',
        'view_analytics', 'access_billing', 'manage_tokens', 'manage_settings',
        'delete_account', 'invite_users', 'manage_users'
      ],
      // New subscription fields - all new users are REG_CLIENT (require subscription)
      accountType: ACCOUNT_TYPES.REG_CLIENT,
      subscriptionStatus: SUBSCRIPTION_STATUS.NONE,
      subscriptionId: null,
      // All new users need subscription
    };
    
    // Create individual user file and account file in new system (NO FALLBACK)
    await writeIndividualUserFile(newUser.id, newUser);

    // Create account file
    const accountData = {
      id: newUser.id,
      name: company?.name || email.split('@')[0],
      ownerId: newUser.id,
      createdAt: new Date().toISOString(),
      isActive: true,
      settings: {
        autoReply: {
          isEnabled: false,
          message: ""
        }
      }
    };
    
    await writeAccountFile(newUser.id, accountData);

    // Create shared-data directory structure
    const sharedDataDir = path.join(SHARED_DATA_DIR, newUser.id);
    await fsPromises.mkdir(sharedDataDir, { recursive: true });
    
    // Create all necessary shared-data files
    const sharedDataFiles = [
      'contacts.json', 'sms-messages.json', 'email-messages.json',
      'voice-campaigns.json', 'voice-calls.json', 'voice-responses.json', 'voice-messages.json',
      'phoneNumbers.json', 'senders.json', 'senderEmails.json',
      'tokens.json', 'invoices.json', 'campaigns.json', 'sms-campaigns.json',
      'email-campaigns.json', 'messages.json', 'sms-responses.json', 'email-responses.json'
    ];
    
    for (const fileName of sharedDataFiles) {
      const filePath = path.join(sharedDataDir, fileName);
      await fsPromises.writeFile(filePath, '[]', 'utf8');
    }
    
    // Initialize default template and image
    await initializeDefaultTemplateForAccount(newUser.id);

    // Send verification based on user preference
    let verificationSent = false;
    let preferredMethod = verificationMethod || 'email';
    
    if (preferredMethod === 'sms' && company && company.phone) {
      // User prefers SMS, try SMS first
      try {

        const smsResult = await sendSMSVerification(company.phone, verificationToken);

        verificationSent = true;
      } catch (smsError) {
        console.error(`=== SMS VERIFICATION ERROR ===`);
        console.error(`Failed to send SMS verification to ${company.phone}:`, smsError);
        console.error(`Error details:`, {
          message: smsError.message,
          stack: smsError.stack,
          code: smsError.code,
          status: smsError.status
        });

        // Fallback to email
        try {

          await sendVerificationEmail(email, verificationToken);

          verificationSent = true;
        } catch (emailError) {
          console.error(`Failed to send verification email to ${email}:`, emailError);

        }
      }
    } else {
      // User prefers email or no phone number, try email first
      try {

        await sendVerificationEmail(email, verificationToken);

        verificationSent = true;
      } catch (emailError) {
        console.error(`Failed to send verification email to ${email}:`, emailError);

        // Fallback to SMS if phone number available
        if (company && company.phone) {
          try {

            await sendSMSVerification(company.phone, verificationToken);

            verificationSent = true;
          } catch (smsError) {
            console.error(`Failed to send SMS verification to ${company.phone}:`, smsError);

          }
        }
      }
    }
    
    let successMessage = 'Registration successful! ';
    if (preferredMethod === 'sms' && verificationSent) {
      successMessage += 'Please check your phone for the verification code.';
    } else if (preferredMethod === 'email' && verificationSent) {
      successMessage += 'Please check your email to verify your account.';
    } else {
      successMessage += 'Please check your email or phone to verify your account.';
    }
    
    // Add subscription information - only for test@test.com
    if (email === 'test@test.com') {
      successMessage += ' After verification, you will need to subscribe to access Campaign Builder Pro.';
    }
    
    // CRITICAL: Do not allow access until verification is complete
    // Only return success message, do not provide subscription info yet
    res.status(201).json({ 
      message: successMessage,
      requiresVerification: true,
      verificationMethod: preferredMethod
    });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/login', async (req, res) => {
  try {

    const { email, password } = req.body;
    
    if (!email || !password) {

      return res.status(400).json({ error: 'Email and password are required' });
    }

    // Find all users with this email (same email can exist in multiple accounts)
    const usersWithEmail = await findAllUsersByEmail(email);
    
    if (!usersWithEmail || usersWithEmail.length === 0) {
      return res.status(401).json({ error: 'Email not found. Please check your email address or register for an account.' });
    }

    // Try to authenticate against each user until we find a match
    let authenticatedUser = null;
    let passwordError = null;
    
    for (const userCandidate of usersWithEmail) {
      try {
        // Check if this user has a password (team members might not have passwords set yet)
        if (!userCandidate.password) {
          continue;
        }
        
        const isPasswordValid = await bcrypt.compare(password, userCandidate.password);
        
        if (isPasswordValid) {
          authenticatedUser = userCandidate;
          break; // Found the correct user, stop checking
        }
      } catch (bcryptError) {
        // Store error but continue checking other users
        passwordError = bcryptError;
        continue;
      }
    }
    
    if (!authenticatedUser) {
      // If we checked all users and none matched, return error
      if (passwordError) {
        console.error('Error comparing passwords:', passwordError);
        return res.status(500).json({ error: 'Error validating password: ' + passwordError.message });
      }
      return res.status(401).json({ error: 'Wrong password. Please try again.' });
    }
    
    // Use the authenticated user
    const user = authenticatedUser;
    
    if (!user.isVerified) {
      // Determine verification method based on user's phone number or default to email
      const verificationMethod = getUserPhoneNumber(user) ? 'sms' : 'email';
      const errorMessage = verificationMethod === 'sms' 
        ? 'Please verify your account before logging in. Check your phone for the verification code.'
        : 'Please verify your email before logging in. Check your inbox for a verification link.';
      
      return res.status(401).json({ 
        error: errorMessage,
        requiresVerification: true,
        verificationMethod: verificationMethod
      });
    }
    
    // Check if user should be prompted to set up 2FA (existing users without 2FA)
    // Skip prompt for app_owner and election accounts so they can log in directly; skip if user declined or has 2FA
    const skip2FAPromptForRole = user.userType === 'app_owner' || user.electionMode || user.accountType === 'election';
    if (!skip2FAPromptForRole && !user.is2FAEnabled && !user.declined2FASetup && !req.body.skip2FAPrompt) {
      // Check if user has the basic requirements for 2FA (email is always available, phone is optional)
      const userPhone = getUserPhoneNumber(user);
      const canUse2FA = user.email || (userPhone && userPhone.trim() !== '');
      
      if (canUse2FA) {
        return res.status(200).json({
          success: true,
          prompt2FASetup: true,
          message: 'Welcome back! We recommend setting up Two-Factor Authentication to secure your account.',
          available2FAMethods: {
            email: !!user.email,
            sms: !!(userPhone && userPhone.trim() !== '')
          }
        });
      }
    }
    
    // 2FA: if enabled, require code before setting cookie (so OTP/2FA login works and cookie is set only after verify)
    if (user.is2FAEnabled) {
      const { twoFactorCode } = req.body;
      if (!twoFactorCode) {
        try {
          const code = generate2FACode();
          const expiresAt = new Date(Date.now() + 10 * 60 * 1000);
          user.loginSession = {
            code: encryptField(code),
            expiresAt: expiresAt.toISOString(),
            createdAt: new Date().toISOString()
          };
          await writeIndividualUserFile(user.id, user);
          await send2FACode(user, code, user.twoFactorMethod);
          return res.status(401).json({
            error: '2FA code required. A verification code has been sent to your registered contact method.',
            requires2FA: true,
            twoFactorMethod: user.twoFactorMethod || 'email'
          });
        } catch (error) {
          console.error('Error sending 2FA code:', error);
          if (user.twoFactorMethod === 'sms' && user.email) {
            try {
              const code = generate2FACode();
              const expiresAt = new Date(Date.now() + 10 * 60 * 1000);
              user.loginSession = {
                code: encryptField(code),
                expiresAt: expiresAt.toISOString(),
                createdAt: new Date().toISOString()
              };
              await writeIndividualUserFile(user.id, user);
              await send2FACode(user, code, 'email');
              return res.status(401).json({
                error: '2FA code required. A verification code has been sent to your email address.',
                requires2FA: true,
                twoFactorMethod: 'email'
              });
            } catch (emailError) {
              console.error('Email fallback also failed:', emailError);
            }
          }
          return res.status(500).json({
            error: 'Failed to send 2FA code. Please try again or contact support.',
            details: error.message
          });
        }
      }
      if (!user.loginSession?.code || !user.loginSession?.expiresAt) {
        return res.status(401).json({ error: 'No active 2FA session. Please request a new code.' });
      }
      if (new Date() > new Date(user.loginSession.expiresAt)) {
        user.loginSession = null;
        await writeIndividualUserFile(user.id, user);
        return res.status(401).json({ error: 'Verification code has expired. Please request a new code.' });
      }
      const storedCode = decryptField(user.loginSession.code);
      if (twoFactorCode !== storedCode) {
        return res.status(401).json({ error: 'Invalid 2FA code' });
      }
      user.loginSession = null;
      await writeIndividualUserFile(user.id, user);
    }

    // All users (with or without 2FA, after 2FA verified) go to dashboard
    user.lastLoginAt = new Date().toISOString();
    await writeIndividualUserFile(user.id, user);

    const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '6h' });
    const refreshToken = jwt.sign({ userId: user.id, type: 'refresh' }, JWT_SECRET, { expiresIn: '7d' });

    const userAgent = req.get('User-Agent') || '';
    const isMobileDevice = /iPad|iPhone|iPod|Android|Mobile|Tablet/.test(userAgent);
    const hostHeader = (req.get('host') || '').split(':')[0];
    const forwardedHost = (req.get('x-forwarded-host') || '').split(',')[0].trim().split(':')[0];
    const host = (forwardedHost || hostHeader).toLowerCase();
    const isProduction = process.env.NODE_ENV === 'production';
    const isProductionHost = (host === 'campaignbuilder.ca' || host === 'www.campaignbuilder.ca');
    const useStrictCookies = isProduction && isProductionHost && !host.includes('localhost') && host !== '127.0.0.1';
    const isHttps = req.secure || (req.get('x-forwarded-proto') === 'https');

    const cookieOptions = {
      httpOnly: true,
      maxAge: 6 * 60 * 60 * 1000,
      path: '/',
      secure: useStrictCookies ? isHttps : false,
      sameSite: useStrictCookies && isHttps ? 'none' : 'lax'
    };
    if (useStrictCookies && isProductionHost) cookieOptions.domain = 'campaignbuilder.ca';
    res.cookie('token', token, cookieOptions);

    const refreshCookieOptions = {
      httpOnly: true,
      maxAge: 7 * 24 * 60 * 60 * 1000,
      path: '/',
      secure: useStrictCookies ? isHttps : false,
      sameSite: useStrictCookies && isHttps ? 'none' : 'lax'
    };
    if (useStrictCookies && isProductionHost) refreshCookieOptions.domain = 'campaignbuilder.ca';
    res.cookie('refreshToken', refreshToken, refreshCookieOptions);

    // Election users who have already accepted NDA: set session cookie so /dashboard doesn't redirect to /nda
    const isElectionUser = user.electionMode || user.accountType === 'election' || user.userType === 'team_member';
    if (isElectionUser && user.ndaAccepted) {
      const ndaSessionOptions = { path: '/', httpOnly: true, sameSite: 'lax', maxAge: 7 * 24 * 60 * 60 * 1000 };
      ndaSessionOptions.secure = useStrictCookies && isHttps;
      res.cookie('election_nda_session', '1', ndaSessionOptions);
    }

    // No subscription checks â€” if they're in the DB they can log in. App_owner/EDA/account_holder â†’ dashboard; others â†’ NDA then dashboard.
    const goStraightToDashboard = user.userType === 'app_owner' || user.accountType === 'app_owner' ||
      user.accountType === 'eda' || user.userType === 'account_holder';
    const redirectTo = goStraightToDashboard ? '/dashboard' : '/nda';
    const message = goStraightToDashboard ? 'Login successful. Redirecting to dashboard...' : 'Please accept the NDA to continue.';

    // Prevent caching so browser always applies Set-Cookie and next request sends cookie
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, private');
    return res.status(200).json({
      success: true,
      message: message,
      redirectTo: redirectTo
    });
  } catch (error) {
    console.error('Login error:', error);
    console.error('Error stack:', error.stack);
    
    // Provide more specific error messages
    let errorMessage = 'Failed to login';
    if (error.code === 'ENOENT') {
      errorMessage = 'User data not found. Please try again.';
    } else if (error.message.includes('encryption')) {
      errorMessage = 'Error processing 2FA code. Please request a new code.';
    } else if (error.message.includes('send2FACode')) {
      errorMessage = 'Error sending 2FA code. Please try again.';
    }
    
    res.status(500).json({ error: errorMessage });
  }
});

// Handle user's response to 2FA setup prompt
app.post('/api/2fa/setup-response', async (req, res) => {
  try {
    const { email, password, accept, method } = req.body;
    
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }
    
    // Find all users with this email (same email can exist in multiple accounts)
    const usersWithEmail = await findAllUsersByEmail(email);
    
    if (!usersWithEmail || usersWithEmail.length === 0) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Try to authenticate against each user until we find a match
    let authenticatedUser = null;
    
    for (const userCandidate of usersWithEmail) {
      try {
        // Check if this user has a password
        if (!userCandidate.password) {
          continue;
        }
        
        const isPasswordValid = await bcrypt.compare(password, userCandidate.password);
        
        if (isPasswordValid) {
          authenticatedUser = userCandidate;
          break; // Found the correct user, stop checking
        }
      } catch (bcryptError) {
        // Continue checking other users
        continue;
      }
    }
    
    if (!authenticatedUser) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Use the authenticated user
    const user = authenticatedUser;
    
    if (accept && method) {
      // User accepted 2FA setup - initiate the setup process
      try {

        const code = generate2FACode();
        const expiresAt = new Date(Date.now() + 10 * 60 * 1000);

        user.pending2FA = {
          code: encryptField(code),
          method: method,
          expiresAt: expiresAt.toISOString(),
          createdAt: new Date().toISOString()
        };
        
        await writeIndividualUserFile(user.id, user);

        await send2FACode(user, code, method);

        const userPhone = getUserPhoneNumber(user);
        return res.json({
          success: true,
          setup2FA: true,
          method: method,
          message: method === 'sms' 
            ? `Verification code sent to ${userPhone?.replace(/(\d{3})\d{3}(\d{4})/, '$1***$2')}` 
            : `Verification code sent to ${user.email?.replace(/(.{2}).*(@.*)/, '$1***$2')}`
        });
      } catch (error) {
        console.error('2FA setup initiation error:', error);
        console.error('Error details:', {
          message: error.message,
          stack: error.stack,
          userEmail: user.email,
          method: method,
          hasEmail: !!user.email,
          hasPhone: !!getUserPhoneNumber(user)
        });
        return res.status(500).json({ 
          error: 'Failed to initiate 2FA setup',
          details: error.message
        });
      }
    } else {
      // User declined 2FA setup - mark as declined and proceed with login
      user.declined2FASetup = true;
      user.lastLoginAt = new Date().toISOString();
      await writeIndividualUserFile(user.id, user);
      
      // Generate JWT with expiration (6 hours for access token)
      const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '6h' });
      
      // Generate refresh token (7 days)
      const refreshToken = jwt.sign({ userId: user.id, type: 'refresh' }, JWT_SECRET, { expiresIn: '7d' });
      
      const userAgent = req.get('User-Agent') || '';
      const isIPadSafari = /iPad|iPhone|iPod/.test(userAgent) && /Safari/.test(userAgent);
      const host = req.get('host') || '';
      const isLocalhost = host.includes('localhost') || host.includes('127.0.0.1') || process.env.IS_STAGING === 'true';
      
      const cookieOptions = {
        httpOnly: true,
        maxAge: 6 * 60 * 60 * 1000,
        path: '/'
      };
      if (isLocalhost) {
        cookieOptions.secure = false;
        cookieOptions.sameSite = 'lax';
      } else if (isIPadSafari) {
        cookieOptions.secure = false;
        cookieOptions.sameSite = 'lax';
      } else {
        cookieOptions.secure = true;
        cookieOptions.sameSite = 'none';
        cookieOptions.domain = 'campaignbuilder.ca';
      }
      res.cookie('token', token, cookieOptions);
      
      const refreshCookieOptions = {
        httpOnly: true,
        maxAge: 7 * 24 * 60 * 60 * 1000,
        path: '/'
      };
      if (isLocalhost) {
        refreshCookieOptions.secure = false;
        refreshCookieOptions.sameSite = 'lax';
      } else if (isIPadSafari) {
        refreshCookieOptions.secure = false;
        refreshCookieOptions.sameSite = 'lax';
      } else {
        refreshCookieOptions.secure = true;
        refreshCookieOptions.sameSite = 'none';
        refreshCookieOptions.domain = 'campaignbuilder.ca';
      }
      res.cookie('refreshToken', refreshToken, refreshCookieOptions);
      
      return res.json({ 
        success: true, 
        redirectTo: '/dashboard',
        message: 'Login successful. You can enable 2FA later in your profile settings.'
      });
    }
  } catch (error) {
    console.error('2FA setup response error:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      body: req.body
    });
    res.status(500).json({ 
      error: 'An error occurred processing your response',
      details: error.message
    });
  }
});

app.post('/api/logout', (req, res) => {
  // Always clear cookies for current host first (works on localhost and production)
  res.clearCookie('token', { path: '/', httpOnly: true });
  res.clearCookie('refreshToken', { path: '/', httpOnly: true });
  res.clearCookie('election_nda_session', { path: '/', httpOnly: true });

  // Detect mobile/tablet devices and adjust cookie clearing accordingly
  const userAgent = req.get('User-Agent') || '';
  const isMobileDevice = /iPad|iPhone|iPod|Android|Mobile|Tablet/.test(userAgent);

  // Clear cookies with mobile/tablet compatible settings
  if (isMobileDevice) {
    // For mobile/tablet devices, use more permissive settings
    res.clearCookie('token', { path: '/', secure: false, sameSite: 'lax', httpOnly: true });
    res.clearCookie('refreshToken', { path: '/', secure: false, sameSite: 'lax', httpOnly: true });
    res.clearCookie('election_nda_session', { path: '/', secure: false, sameSite: 'lax', httpOnly: true });
    
    // Fallback: set empty cookies with maxAge 0
    res.cookie('token', '', {
      httpOnly: true,
      secure: false,
      sameSite: 'lax',
      maxAge: 0,
      path: '/'
    });
    
    res.cookie('refreshToken', '', {
      httpOnly: true,
      secure: false,
      sameSite: 'lax',
      maxAge: 0,
      path: '/'
    });
  } else {
    // For other browsers, use secure settings
    res.clearCookie('token', { path: '/', domain: 'campaignbuilder.ca', secure: true, sameSite: 'none', httpOnly: true });
    res.clearCookie('refreshToken', { path: '/', domain: 'campaignbuilder.ca', secure: true, sameSite: 'none', httpOnly: true });
    res.clearCookie('election_nda_session', { path: '/', httpOnly: true });
    
    // Clear with legacy domain settings (in case old cookies exist)
    res.clearCookie('token', { 
      path: '/', 
      domain: '.campaignbuilder.ca',
      secure: true,
      sameSite: 'none',
      httpOnly: true
    });
    
    res.clearCookie('refreshToken', { 
      path: '/', 
      domain: '.campaignbuilder.ca',
      secure: true,
      sameSite: 'none',
      httpOnly: true
    });
    
    // Fallback: set empty cookies with maxAge 0
    res.cookie('token', '', {
      httpOnly: true,
      secure: true,
      sameSite: 'none',
      maxAge: 0,
      path: '/',
      domain: 'campaignbuilder.ca'
    });
    
    res.cookie('refreshToken', '', {
      httpOnly: true,
      secure: true,
      sameSite: 'none',
      maxAge: 0,
      path: '/',
      domain: 'campaignbuilder.ca'
    });
  }
  
  res.json({ message: 'Logged out successfully' });
});

app.get('/api/validate-token', async (req, res) => {
  try {
    const token = req.cookies.token || 
                 (req.header('Authorization') ? req.header('Authorization').replace('Bearer ', '') : null);

    if (!token) {
      return res.status(401).json({ 
        valid: false, 
        error: 'No token provided',
        tokenLength: 0
      });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    const user = await findUserById(decoded.userId);
    
    if (!user) {
      return res.status(401).json({ 
        valid: false, 
        error: 'User not found',
        tokenLength: token.length
      });
    }

    res.json({ 
      valid: true, 
      userId: decoded.userId,
      tokenLength: token.length
    });
  } catch (error) {
    res.status(401).json({ 
      valid: false, 
      error: error.message,
      tokenLength: token ? token.length : 0
    });
  }
});

// Refresh token endpoint
app.post('/api/refresh-token', async (req, res) => {
  try {
    const refreshToken = req.cookies.refreshToken;
    
    if (!refreshToken) {
      return res.status(401).json({ error: 'No refresh token provided' });
    }

    const decoded = jwt.verify(refreshToken, JWT_SECRET);
    
    if (decoded.type !== 'refresh') {
      return res.status(401).json({ error: 'Invalid token type' });
    }

    const user = await findUserById(decoded.userId);
    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }

    // Generate new access token
    const newToken = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '6h' });
    
    const isProduction = process.env.NODE_ENV === 'production';
    
    // Set new access token cookie - iPad compatible settings
    res.cookie('token', newToken, {
      httpOnly: true,
      secure: true, // Always secure for SameSite=None
      sameSite: 'none', // Required for iPad Safari compatibility
      maxAge: 6 * 60 * 60 * 1000, // 6 hours
      path: '/',
      domain: 'campaignbuilder.ca'
    });

    res.json({ 
      success: true, 
      message: 'Token refreshed successfully',
      expiresIn: '6h'
    });
  } catch (error) {
    res.status(401).json({ error: 'Invalid refresh token' });
  }
});

// Forgot Password - Send verification code
app.post('/api/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;

    const user = await findUserByEmail(email);
    
    if (!user) {

      return res.status(404).json({ error: 'Email not found. Please check your email address or register for an account.' });
    }

    // Generate a 6-digit verification code
    const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();

    // Store the verification code with expiration (15 minutes)
    user.resetPasswordCode = verificationCode;
    user.resetPasswordExpires = new Date(Date.now() + 15 * 60 * 1000).toISOString(); // 15 minutes
    await writeIndividualUserFile(user.id, user);

    // Send verification email

    await sendPasswordResetEmail(user.email, verificationCode);

    res.json({ message: 'Password reset code sent to your email address.' });
  } catch (error) {
    console.error('Forgot password error:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      code: error.code
    });
    res.status(500).json({ error: 'Failed to send reset code. Please try again.' });
  }
});

// Reset Password with verification code
app.post('/api/reset-password', async (req, res) => {
  try {
    const { email, code, newPassword } = req.body;
    const user = await findUserByEmail(email);
    
    if (!user) {
      return res.status(404).json({ error: 'Email not found.' });
    }
    
    // Check if code exists and is not expired
    if (!user.resetPasswordCode || !user.resetPasswordExpires) {
      return res.status(400).json({ error: 'No reset code found. Please request a new one.' });
    }
    
    if (new Date() > new Date(user.resetPasswordExpires)) {
      return res.status(400).json({ error: 'Reset code has expired. Please request a new one.' });
    }
    
    if (user.resetPasswordCode !== code) {
      return res.status(400).json({ error: 'Invalid verification code. Please try again.' });
    }
    
    // Hash the new password
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    user.password = hashedPassword;
    
    // Clear the reset code
    delete user.resetPasswordCode;
    delete user.resetPasswordExpires;
    
    await writeIndividualUserFile(user.id, user);
    
    res.json({ message: 'Password reset successfully. You can now login with your new password.' });
  } catch (error) {
    console.error('Reset password error:', error);
    res.status(500).json({ error: 'Failed to reset password. Please try again.' });
  }
});

// Build full user payload for /api/user and /api/me (shared logic)
async function buildCurrentUserPayload(user) {
  const { password, verificationToken, ...userData } = user;
  const accountId = getEffectiveAccountId(user);
  const isSpecial = await isSpecialContactStructure(accountId);
  userData.contactStructure = isSpecial ? 'eda_special' : 'standard';
  const contacts = await getAccountContacts(accountId);
  const templates = await getAccountTemplates(accountId);
  const campaigns = await getAccountCampaigns(accountId);
  const images = await getAccountImages(accountId);
  const tokens = await getAccountTokens(accountId);
  const senderEmails = await getAccountSenderEmails(accountId);
  const phoneNumbers = await getAccountPhoneNumbers(accountId);
  const invoices = await getAccountInvoices(accountId);
  userData.contacts = contacts;
  userData.messageTemplates = templates;
  userData.campaigns = campaigns;
  userData.images = images;
  userData.senderEmails = senderEmails;
  userData.phoneNumbers = phoneNumbers;
  userData.invoices = invoices;
  userData.smsTokens = tokens.smsTokens;
  userData.emailTokens = tokens.emailTokens;
  userData.aiTokens = tokens.aiTokens;
  userData.personalInfo = user.personalInfo;
  userData.userType = user.userType;
  userData.accountId = user.accountId;
  userData.invitedBy = user.invitedBy;
  userData.permissions = user.permissions;
  if (typeof userData.aiTokens === 'undefined') userData.aiTokens = 0;
  return userData;
}

// Soft-auth: always 200. For bootstrap so frontend never hangs on 401.
app.get('/api/me', async (req, res) => {
  try {
    const token = req.cookies?.token || (req.get('Authorization') || '').replace(/^Bearer\s+/i, '');
    if (!token) {
      return res.status(200).json({ authenticated: false, user: null });
    }
    const decoded = jwt.verify(token, JWT_SECRET);
    const user = await findUserById(decoded.userId != null ? String(decoded.userId) : '');
    if (!user) {
      return res.status(200).json({ authenticated: false, user: null });
    }
    const userData = await buildCurrentUserPayload(user);
    res.status(200).json({ authenticated: true, user: userData });
  } catch (err) {
    res.status(200).json({ authenticated: false, user: null });
  }
});

// Protected: full user data (401 when not logged in)
app.get('/api/user', auth, async (req, res) => {
  try {
    const userData = await buildCurrentUserPayload(req.user);
    res.json(userData);
  } catch (error) {
    console.error('Error loading user data:', error);
    res.status(500).json({ error: error.message });
  }
});

// Helper function to get accurate contact counts
const getAccurateContactCounts = async (userId) => {
    try {
        const user = await findUserById(userId);
        const accountId = user.accountId || user.id;
        let contacts = [];
        
        // Get contacts from shared-data
        try {
            contacts = await getAccountContacts(accountId);
        } catch (error) {
            console.error('Error loading contacts:', error);
            contacts = [];
        }
        
        const counts = {};
        
        // Count contacts by category with proper filtering
        if (contacts) {
            contacts.forEach(contact => {
                const category = contact.category || 'uncategorized';
                counts[category] = (counts[category] || 0) + 1;
            });
        }
        
        // Count active vs inactive contacts
        counts.active = contacts?.filter(c => !c.isDeleted).length || 0;
        
        return counts;
    } catch (error) {
        console.error('Error getting contact counts:', error);
        return { active: 0 };
    }
};

// Contact counts endpoint
app.get('/api/contacts/counts', auth, async (req, res) => {
    try {
        const counts = await getAccurateContactCounts(req.user.id);
        res.json(counts);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// Helper function to update shared-data invoices
const updateSharedInvoice = async (accountId, invoice) => {
    try {

        if (!accountId) {
            throw new Error('Account ID is required');
        }
        
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const invoicesPath = path.join(sharedDataPath, 'invoices.json');

        // Ensure shared-data directory exists
        await fsPromises.mkdir(sharedDataPath, { recursive: true });
        
        let invoices = [];
        if (fs.existsSync(invoicesPath)) {
            const data = await fsPromises.readFile(invoicesPath, 'utf8');
            invoices = JSON.parse(data);

        } else {

        }
        
        // Find existing invoice by ID and update, or add new one
        const existingIndex = invoices.findIndex(inv => inv.id === invoice.id);
        if (existingIndex >= 0) {
            invoices[existingIndex] = invoice;

        } else {
            invoices.push(invoice);

        }
        
        // Sort by date (newest first)
        invoices.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
        
        await fsPromises.writeFile(invoicesPath, JSON.stringify(invoices, null, 2), 'utf8');

    } catch (error) {
        console.error('Error updating shared invoice:', error);
        console.error('Error details:', error.message, error.stack);
        throw error; // Re-throw to see the error in the calling function
    }
};

// Helper function to create or update invoice with date grouping
const createOrUpdateInvoice = async (userId, purchase) => {
    const user = await findUserById(userId);
    const today = new Date().toDateString();
    
    // Get invoices from shared-data using standardized function
    const accountId = getEffectiveAccountId(user);
    const invoices = await getAccountInvoices(accountId);
    
    // Check for existing invoice from today
    const existingInvoice = invoices.find(inv => 
        new Date(inv.createdAt).toDateString() === today
    );
    
    if (existingInvoice) {
        // Add to existing invoice
        existingInvoice.items.push(purchase);
        existingInvoice.amount += purchase.total;
        existingInvoice.updatedAt = new Date().toISOString();
        
        // Update metadata if needed
        if (purchase.metadata) {
            if (!existingInvoice.metadata) existingInvoice.metadata = {};
            Object.assign(existingInvoice.metadata, purchase.metadata);
        }
        
        // Update shared-data invoice using standardized function
        await updateAccountInvoices(accountId, invoices);
        
        return existingInvoice;
    } else {
        // Create new invoice with professional details
        const newInvoice = {
            id: Date.now().toString(),
            userId: userId,
            companyName: user.company?.name || 'Individual',
            purchaserName: user.personalInfo?.firstName && user.personalInfo?.lastName ? 
                `${user.personalInfo.firstName} ${user.personalInfo.lastName}` : 
                user.email,
            billingAddress: user.company?.address || {},
            items: [purchase],
            amount: purchase.total,
            currency: purchase.currency || 'cad',
            status: purchase.status || 'pending',
            metadata: purchase.metadata || {},
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        invoices.push(newInvoice);
        
        // Update shared-data using standardized function
        await updateAccountInvoices(accountId, invoices);
        
        return newInvoice;
    }
};

// Token Management Routes - billing via Paddle / off-platform
app.post('/api/tokens/purchase', auth, requirePermission('access_billing'), async (req, res) => {
    try {
        const user = await findUserById(req.user.id);
        
        // Only account holders can purchase tokens
        if (user.userType !== 'account_holder') {
            return res.status(403).json({ error: 'Only account holders can purchase tokens' });
        }
        
        // Billing off-platform; tokens via support
        const error = billingService.createBillingDisabledError(
            'Token purchases are handled via invoice-based billing. Please contact support to purchase tokens.'
        );
        
        return res.status(error.statusCode).json({ 
            error: error.message,
            code: error.code,
            billingMethod: 'off_platform'
        });
    } catch (error) {
        res.status(error.statusCode || 400).json({ error: error.message });
    }
});

// Stripe not used - billing via Paddle; invoices/receipts built outside application
app.post('/webhook/stripe', async (req, res) => {
    return res.status(200).json({ message: 'Billing handled off-platform (Paddle).' });
});

// Paddle webhook: fulfill phone number purchase on transaction.completed
app.post('/webhook/paddle', async (req, res) => {
    const rawBody = req.rawBody || (typeof req.body === 'string' ? Buffer.from(req.body, 'utf8') : Buffer.from(JSON.stringify(req.body || {})));
    const payload = req.body && typeof req.body === 'object' ? req.body : JSON.parse(rawBody.toString('utf8'));
    const sigHeader = req.headers['paddle-signature'];
    if (!PADDLE_WEBHOOK_SECRET || !sigHeader) {
        return res.status(401).send('Missing webhook secret or signature');
    }
    const parts = sigHeader.split(';').reduce((acc, part) => {
        const [k, v] = part.trim().split('=');
        if (k && v) acc[k] = v;
        return acc;
    }, {});
    const ts = parts.ts;
    const h1 = parts.h1;
    if (!ts || !h1) {
        return res.status(401).send('Invalid Paddle-Signature format');
    }
    const signedPayload = ts + ':' + rawBody.toString('utf8');
    const expected = crypto.createHmac('sha256', PADDLE_WEBHOOK_SECRET).update(signedPayload).digest('hex');
    if (!crypto.timingSafeEqual(Buffer.from(h1, 'hex'), Buffer.from(expected, 'hex'))) {
        return res.status(401).send('Invalid signature');
    }
    const tolerance = 300;
    if (Math.abs(Date.now() / 1000 - parseInt(ts, 10)) > tolerance) {
        return res.status(401).send('Signature timestamp too old');
    }
    try {
        const eventType = payload.event_type || payload.event?.event_type;
        if (eventType === 'transaction.completed') {
            const data = payload.data || payload.event?.data;
            const attrs = data?.attributes || data || {};
            const customData = attrs.custom_data || {};
            const userId = customData.userId ? String(customData.userId) : null;
            const phoneNumber = customData.phoneNumber ? String(customData.phoneNumber) : null;
            const txnId = data?.id || attrs.id || null;
            if (!userId || !phoneNumber) {
                console.warn('[PADDLE] transaction.completed missing custom_data userId/phoneNumber', { customData });
                return res.status(200).json({ received: true });
            }
            await fulfillPhoneNumberPurchase(userId, phoneNumber, txnId);
            console.log('[PADDLE] Fulfilled phone number purchase', { userId, phoneNumber, txnId });
        }
        res.status(200).json({ received: true });
    } catch (error) {
        console.error('[PADDLE] Webhook error:', error);
        res.status(500).json({ error: error.message });
    }
});

// Scheduled Messages Route
app.post('/api/messages/schedule', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    if (!user || !user.isPro) {
      throw new Error('Pro subscription required for message scheduling');
    }

    const db = await readDB();
    const { type, content, recipients, scheduling, subject, template } = req.body;

    // Calculate next run time
    let nextRun;
    if (scheduling.type === 'scheduled') {
      nextRun = new Date(scheduling.dateTime);
    } else if (scheduling.type === 'recurring') {
      nextRun = calculateNextRunTime(scheduling.recurring);
    }

    // Create scheduled message
    const scheduledMessage = {
      id: Date.now().toString(),
      userId: req.user.id,
      type,
      content,
      subject,
      template,
      recipients,
      scheduling,
      status: 'pending',
      nextRun,
      createdAt: new Date().toISOString()
    };

    // Add to scheduled messages collection (still global)
    if (!db.scheduledMessages) {
      db.scheduledMessages = [];
    }
    db.scheduledMessages.push(scheduledMessage);
    await writeDB(db);

    res.json({ success: true, message: scheduledMessage });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Contact Management Routes
app.post('/api/contacts', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = getEffectiveAccountId(user);
    const isSpecial = await isSpecialContactStructure(accountId);

    let newContact;

    if (isSpecial) {
      // Special EDA structure: Name, Riding, Province, Email, Role, Phone, Categories, PollNumber, Notes
      const { name, riding, province, email, role, phone, category, categories, pollNumber, notes, notesUpdatedAt } = req.body;

      if (!name) {
        throw new Error('Name is required');
      }

      // Validate field lengths
      if (name && name.length > 200) {
        throw new Error('Name must be 200 characters or less');
      }

      const notesArr = Array.isArray(notes) ? notes : (notes && String(notes).trim() ? [{ text: String(notes).trim(), updatedAt: notesUpdatedAt || new Date().toISOString() }] : []);
      newContact = {
        id: Date.now().toString(),
        name,
        riding: riding || '',
        province: province || '',
        email: email || '',
        role: role || '',
        phone: phone || '',
        // Support both old single category and new multiple categories
        categories: categories || (category ? [category] : []),
        pollNumber: pollNumber || '',
        notes: notesArr,
        createdBy: user.id,
        createdAt: new Date().toISOString()
      };
    } else {
      // Standard structure: firstName, lastName, address, city, province, postalCode, email, phone, category, pollNumber, notes
      const { 
        firstName, lastName, address, city, 
        province, postalCode, email, phone, category, categories, pollNumber, notes, notesUpdatedAt 
      } = req.body;

      if (!firstName || !lastName) {
        throw new Error('First and Last name are required');
      }

      // Validate field lengths
      if (address && address.length > 200) {
        throw new Error('Address must be 200 characters or less');
      }
      
      if (firstName && firstName.length > 100) {
        throw new Error('First name must be 100 characters or less');
      }
      
      if (lastName && lastName.length > 100) {
        throw new Error('Last name must be 100 characters or less');
      }

      const notesArr = Array.isArray(notes) ? notes : (notes && String(notes).trim() ? [{ text: String(notes).trim(), updatedAt: notesUpdatedAt || new Date().toISOString() }] : []);
      newContact = {
        id: Date.now().toString(),
        firstName,
        lastName,
        address,
        city,
        province,
        postalCode,
        email,
        phone,
        // Support both old single category and new multiple categories
        categories: categories || (category ? [category] : []),
        pollNumber: pollNumber || '',
        notes: notesArr,
        createdBy: user.id,
        createdAt: new Date().toISOString()
      };
    }

    // Add to shared contacts using standardized function
    const contacts = await getAccountContacts(accountId);
    contacts.push(newContact);
    
    // Update shared contacts file using standardized function
    await updateAccountContacts(accountId, contacts);
    
    res.json(contacts);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Helper function to save template images to library
async function saveTemplateImagesToLibrary(template, userId, accountId, req) {
    try {
        const imagesToSave = [];
        
        // Collect all images from template
        if (template.headerImage) {
            imagesToSave.push({ url: template.headerImage, section: 'header', name: 'Header Image' });
        }
        if (template.bannerImage) {
            imagesToSave.push({ url: template.bannerImage, section: 'banner', name: 'Banner Image' });
        }
        if (template.footerImage) {
            imagesToSave.push({ url: template.footerImage, section: 'footer', name: 'Footer Image' });
        }
        
        // Collect images from body elements
        if (template.bodyElements && Array.isArray(template.bodyElements)) {
            template.bodyElements.forEach((element, index) => {
                if (element.type === 'image' && element.url) {
                    imagesToSave.push({ 
                        url: element.url, 
                        section: 'body', 
                        name: `Body Image ${index + 1}`,
                        alt: element.alt || ''
                    });
                }
            });
        }
        
        if (imagesToSave.length === 0) {
            return; // No images to save
        }
        
        // Get existing images to check for duplicates
        let allImages = await getAccountImages(accountId);
        
        // For app owners, also include global images as fallback
        const user = await findUserById(userId);
        if (user && user.userType === 'app_owner') {
            const globalImagesPath = path.join(__dirname, 'data', 'images.json');
            const globalImages = await safeReadJsonFile(globalImagesPath, []);
            const filteredGlobalImages = globalImages.filter(img => 
                img.userId === userId || (img.userId === 'system' && img.isDefault === true)
            );
            allImages = [...allImages, ...filteredGlobalImages];
        }
        
        // Normalize URLs and check for duplicates
        const existingUrls = new Set(allImages.map(img => {
            // Normalize URL for comparison
            let normalized = img.url;
            if (normalized.startsWith('/')) {
                const protocol = req.headers['x-forwarded-proto'] || req.protocol;
                const host = req.headers['x-forwarded-host'] || req.get('host');
                normalized = `${protocol}://${host}${normalized}`;
            } else if (!normalized.startsWith('http://') && !normalized.startsWith('https://')) {
                const protocol = req.headers['x-forwarded-proto'] || req.protocol;
                const host = req.headers['x-forwarded-host'] || req.get('host');
                normalized = `${protocol}://${host}/${normalized}`;
            }
            return normalized.toLowerCase();
        }));
        
        // Save each unique image
        for (const imageData of imagesToSave) {
            if (!imageData.url || !imageData.url.trim()) {
                continue; // Skip empty URLs
            }
            
            // Normalize the image URL
            let normalizedUrl = imageData.url;
            if (imageData.url.startsWith('/')) {
                const protocol = req.headers['x-forwarded-proto'] || req.protocol;
                const host = req.headers['x-forwarded-host'] || req.get('host');
                normalizedUrl = `${protocol}://${host}${imageData.url}`;
            } else if (!imageData.url.startsWith('http://') && !imageData.url.startsWith('https://')) {
                const protocol = req.headers['x-forwarded-proto'] || req.protocol;
                const host = req.headers['x-forwarded-host'] || req.get('host');
                normalizedUrl = `${protocol}://${host}/${imageData.url}`;
            }
            
            // Check if image already exists in library
            const normalizedForCheck = normalizedUrl.toLowerCase();
            if (existingUrls.has(normalizedForCheck)) {
                continue; // Skip if already exists
            }
            
            // Generate unique ID
            const imageId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
            
            // Create image record
            const imageRecord = {
                id: imageId,
                userId: userId,
                accountId: accountId,
                url: normalizedUrl,
                name: imageData.name || `Image ${new Date().toLocaleDateString()}`,
                description: imageData.alt || `Image from template: ${template.name || 'Untitled'}`,
                tags: ['template'],
                section: imageData.section || 'body',
                size: 0,
                createdAt: new Date().toISOString(),
                source: 'template',
                isDefault: false
            };
            
            // Add to images array
            allImages.push(imageRecord);
            existingUrls.add(normalizedForCheck);
        }
        
        // Save updated images using standardized function
        if (allImages.length > 0) {
            await updateAccountImages(accountId, allImages);
        }
    } catch (error) {
        // Log error but don't fail template save
        console.error('Error saving template images to library:', error);
    }
}

// Template Management Routes
app.post('/api/templates', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    // Prevent creation of duplicate default templates
    if (req.body.id === 'default' || req.body.name === 'Basic Marketing Template') {
      return res.status(400).json({ error: 'Cannot create duplicate default templates' });
    }
    
    const template = {
      ...req.body,
      id: Date.now().toString(),
      updatedAt: new Date().toISOString(),
      createdAt: new Date().toISOString(),
      isDefault: false,
      versionHistory: [],
      createdBy: user.id
    };
    
    // Add to shared templates using standardized function
    const accountId = getEffectiveAccountId(user);
    const templates = await getAccountTemplates(accountId);
    
    // Prevent duplicate default templates
    if (template.isDefault) {
      // Remove any existing default templates
      const filteredTemplates = templates.filter(t => !(t.isDefault === true && t.id === 'default'));
      templates.length = 0;
      templates.push(...filteredTemplates);
    }
    
    templates.push(template);
    
    // Update shared templates file using standardized function
    await updateAccountTemplates(accountId, templates);
    
    // Save all template images to library
    await saveTemplateImagesToLibrary(template, user.id, accountId, req);
    
    res.json(template);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.put('/api/templates/:id', auth, async (req, res) => {
  try {
    const templateId = req.params.id;
    const user = await findUserById(req.user.id);
    
    // Get templates using standardized function
    const accountId = getEffectiveAccountId(user);
    const templates = await getAccountTemplates(accountId);
    const templateIndex = templates.findIndex(t => t.id === templateId);
    
    if (templateIndex === -1) {
      throw new Error('Template not found');
    }
    
    // Prevent modification of default templates
    const existingTemplate = templates[templateIndex];
    if (existingTemplate.isDefault === true || existingTemplate.id === 'default') {
      return res.status(403).json({ error: 'Cannot modify default templates' });
    }
    
    // Store version history before updating
    if (!existingTemplate.versionHistory) {
      existingTemplate.versionHistory = [];
    }
    
    // Add current version to history
    // Create a clean copy of the template without versionHistory to avoid circular reference
    const templateCopy = { ...existingTemplate };
    delete templateCopy.versionHistory;
    
    const currentVersion = {
      id: `v${existingTemplate.versionHistory.length + 1}`,
      version: existingTemplate.versionHistory.length + 1,
      timestamp: existingTemplate.updatedAt || new Date().toISOString(),
      changes: 'Template updated',
      author: user.name || user.email || 'User',
      template: templateCopy
    };
    
    existingTemplate.versionHistory.push(currentVersion);
    
    // Keep only the last 10 versions
    if (existingTemplate.versionHistory.length > 10) {
      existingTemplate.versionHistory = existingTemplate.versionHistory.slice(-10);
    }
    
    const updatedTemplate = {
      ...req.body,
      id: templateId,
      updatedAt: new Date().toISOString(),
      updatedBy: user.id,
      isDefault: false,
      versionHistory: existingTemplate.versionHistory
    };
    
    // Update the template in shared-data
    templates[templateIndex] = updatedTemplate;
    
    // Update shared templates file
    const sharedTemplatesPath = path.join(__dirname, 'data', 'shared-data', accountId, 'templates.json');
    await fsPromises.writeFile(sharedTemplatesPath, JSON.stringify(templates, null, 2), 'utf8');
    
    // Save all template images to library
    await saveTemplateImagesToLibrary(updatedTemplate, user.id, accountId, req);
    
    res.json(updatedTemplate);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.delete('/api/templates/:id', auth, async (req, res) => {
  try {
    const templateId = req.params.id;
    const user = await findUserById(req.user.id);
    
    // Get templates using standardized function
    const accountId = getEffectiveAccountId(user);
    const templates = await getAccountTemplates(accountId);
    const templateIndex = templates.findIndex(t => t.id === templateId);
    
    if (templateIndex === -1) {
      throw new Error('Template not found');
    }
    
    // Prevent deletion of default templates
    const template = templates[templateIndex];
    if (template.isDefault === true || template.id === 'default') {
      return res.status(403).json({ error: 'Cannot delete default templates' });
    }
    
    // Remove the template from the array
    templates.splice(templateIndex, 1);
    
    // Update templates using standardized function
    await updateAccountTemplates(accountId, templates);
    
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Account Management Route - Account holders only
app.delete('/api/account', auth, requirePermission('delete_account'), async (req, res) => {
  try {
    const user = req.user;
    
    // Log account deletion
    await logAuditEvent(user.id, 'ACCOUNT_DELETED', {
      accountId: user.accountId,
      accountName: (typeof user.company === 'object' && user.company && user.company.name) ? user.company.name : (typeof user.company === 'string' ? user.company : 'Unknown Account'),
      userEmail: user.email || user.username || 'Unknown'
    }, req);
    
    // Delete the user's file
    await deleteUserFile(req.user.id);
    // Optionally, remove user's messages and token transactions from global db.json if needed
    const db = await readDB();
    if (db.messages) db.messages = db.messages.filter(m => m.userId !== req.user.id);
    if (db.tokenTransactions) db.tokenTransactions = db.tokenTransactions.filter(t => t.userId !== req.user.id);
    await writeDB(db);
    res.json({ message: 'Account deleted successfully' });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Email verification endpoint
app.post('/api/verify-email', async (req, res) => {
  try {
    const { token } = req.body;
    
    // Find user by verification token
    const userIds = await getAllUserIds();
    let user = null;
    let userId = null;
    
    for (const id of userIds) {
      const u = await findUserById(id);
      if (u && u.verificationToken === token) {
        user = u;
        userId = id;
        break;
      }
    }
    
    if (!user) throw new Error('Invalid verification token');
    
    user.isVerified = true;
    user.verificationToken = null;
    
    await writeIndividualUserFile(userId, user);
    res.json({ message: 'Email verified successfully' });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Email verification GET route (for verification links)
app.get('/verify', async (req, res) => {
  try {
    const { token } = req.query;
    
    if (!token) {
      throw new Error('No verification token provided');
    }
    
    // Find user by verification token
    const userIds = await getAllUserIds();
    let user = null;
    let userId = null;
    
    for (const id of userIds) {
      const u = await findUserById(id);
      if (u && u.verificationToken === token) {
        user = u;
        userId = id;
        break;
      }
    }
    
    if (!user) {
      throw new Error('Invalid or expired verification token');
    }
    
    // Update user verification status
    user.isVerified = true;
    user.verificationToken = null;
    
    // Update user in the correct data structure
    try {
      await writeIndividualUserFile(userId, user);

    } catch (error) {
      console.error(`Failed to update user file for ${user.email} in individual-data structure:`, error);
      // Fallback to old system
      await writeIndividualUserFile(userId, user);

    }
    
    // Render success page with subscription information
    res.render('verify-success', { 
      layout: false,
      baseUrl: BASE_URL,
      user: user,
      subscriptionInfo: {
        accountType: user.accountType,
        trialDays: 7,
        subscriptionRequired: true,
        trialEndsAt: user.trialEndsAt
      }
    });
  } catch (error) {
    console.error('Email verification error:', error);
    res.redirect('/login?error=' + encodeURIComponent('Verification failed. Please try again or contact support.'));
  }
});

// New endpoint to verify account with code
app.post('/api/verify-account', async (req, res) => {
  try {
    const { email, code } = req.body;
    
    if (!email || !code) {
      return res.status(400).json({ error: 'Email and verification code are required' });
    }
    
    const user = await findUserByEmail(email);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Check if user is already verified
    if (user.isVerified) {
      return res.status(400).json({ error: 'Account is already verified' });
    }
    
    // Check if verification code matches
    if (user.verificationToken !== code) {
      return res.status(400).json({ error: 'Invalid verification code' });
    }
    
    // Verify the user
    user.isVerified = true;
    user.verificationToken = null;
    
    // Ensure subscription fields are properly set for new users
    if (!user.accountType) {
      user.accountType = ACCOUNT_TYPES.REG_CLIENT;
    }
    if (!user.subscriptionStatus) {
      user.subscriptionStatus = SUBSCRIPTION_STATUS.NONE; // No trial - subscription required
    }
    // Remove trial setup - users must subscribe immediately
    
    // Update user file
    await writeIndividualUserFile(user.id, user);

    res.json({
      success: true,
      message: 'Account verified successfully! You can now log in.'
    });
  } catch (error) {
    console.error('Error verifying account:', error);
    res.status(500).json({ error: 'Failed to verify account' });
  }
});

// New endpoint to get subscription info after verification
app.get('/api/subscription-info', async (req, res) => {
  try {
    const { email } = req.query;
    
    if (!email) {
      return res.status(400).json({ error: 'Email is required' });
    }
    
    const user = await findUserByEmail(email);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Only provide subscription info if user is verified
    if (!user.isVerified) {
      return res.status(403).json({ 
        error: 'Account not verified. Please verify your account first.',
        requiresVerification: true
      });
    }
    
    res.json({
      userType: user.userType,
      subscriptionInfo: {
        accountType: user.accountType,
        trialDays: 7,
        subscriptionRequired: true,
        trialEndsAt: user.trialEndsAt
      }
    });
  } catch (error) {
    console.error('Error getting subscription info:', error);
    res.status(500).json({ error: 'Failed to get subscription information' });
  }
});

// SMS Test endpoint for debugging
app.post('/api/test-sms', async (req, res) => {
  try {
    const { phoneNumber } = req.body;
    
    if (!phoneNumber) {
      return res.status(400).json({ error: 'Phone number is required' });
    }

    // Test with a simple message
    const testMessage = await twilioClient.messages.create({
      from: SYSTEM_2FA_PHONE_NUMBER,
      to: phoneNumber,
      body: `Test SMS from Campaign Builder - ${new Date().toISOString()}`,
      statusCallback: `${BASE_URL}/api/webhooks/status/test`,
      provideFeedback: true
    });

    res.json({
      success: true,
      messageSid: testMessage.sid,
      status: testMessage.status,
      details: {
        from: testMessage.from,
        to: testMessage.to,
        price: testMessage.price,
        priceUnit: testMessage.priceUnit
      }
    });
  } catch (error) {
    console.error('Test SMS error:', error);
    res.status(500).json({ 
      error: error.message,
      code: error.code,
      status: error.status
    });
  }
});

// Token history endpoint
app.get('/api/tokens/history', auth, requirePermission('access_billing'), async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    // Get token transactions from shared-data structure
    const accountId = user.accountId || user.id;
    const transactionsPath = path.join(__dirname, 'data', 'shared-data', accountId, 'token-transactions.json');
    
    let transactions = [];
    try {
      const transactionsData = await fsPromises.readFile(transactionsPath, 'utf8');
      transactions = JSON.parse(transactionsData);
    } catch (error) {
      // File doesn't exist, return empty array
      transactions = [];
    }
    
    res.json(transactions);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get messages endpoint
app.get('/api/messages', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    // Get messages from individual-data (user-specific messages)
    const individualDataPath = path.join(INDIVIDUAL_DATA_DIR, user.id, 'messages.json');
    const messages = await safeReadJsonFile(individualDataPath, []);
    
    res.json(messages);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get contacts endpoint - now uses account-level data
app.get('/api/contacts', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = getEffectiveAccountId(user);
    
    let contacts = await getAccountContacts(accountId);
    
    // Return single contact by id (for navigation â†’ record note flow)
    if (req.query.id) {
      const c = contacts.find(c => String(c.id) === String(req.query.id));
      if (!c) return res.status(404).json({ error: 'Contact not found' });
      return res.json(c);
    }
    
    // Support search parameter
    if (req.query.search) {
      const searchTerm = req.query.search.toLowerCase();
      contacts = contacts.filter(contact => {
        const name = (contact.name || (contact.firstName + ' ' + contact.lastName) || '').toLowerCase();
        const email = (contact.email || '').toLowerCase();
        const phone = (contact.phone || '').toLowerCase();
        return name.includes(searchTerm) || email.includes(searchTerm) || phone.includes(searchTerm);
      });
    }
    
    res.json(contacts);
  } catch (error) {
    console.error('Get contacts error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Unsubscribe endpoint - public (no auth required)
app.post('/api/unsubscribe', async (req, res) => {
  try {
    const { token, channel, reason, email, phone } = req.body;
    
    if (!channel || !['email', 'sms', 'voice'].includes(channel)) {
      return res.status(400).json({ error: 'Invalid channel. Must be email, sms, or voice' });
    }
    
    // Find contact by email or phone
    let contact = null;
    let accountId = null;
    
    if (email) {
      // Search all accounts for this email (this is simplified - in production you'd want to limit scope)
      const sharedDataDir = path.join(__dirname, 'data', 'shared-data');
      if (fs.existsSync(sharedDataDir)) {
        const accountDirs = fs.readdirSync(sharedDataDir).filter(f => {
          const accountPath = path.join(sharedDataDir, f);
          return fs.statSync(accountPath).isDirectory();
        });
        
        for (const accountDir of accountDirs) {
          const contacts = await getAccountContacts(accountDir);
          const found = contacts.find(c => c.email && c.email.toLowerCase() === email.toLowerCase());
          if (found) {
            contact = found;
            accountId = accountDir;
            break;
          }
        }
      }
    } else if (phone) {
      // Search by phone
      const sharedDataDir = path.join(__dirname, 'data', 'shared-data');
      if (fs.existsSync(sharedDataDir)) {
        const accountDirs = fs.readdirSync(sharedDataDir).filter(f => {
          const accountPath = path.join(sharedDataDir, f);
          return fs.statSync(accountPath).isDirectory();
        });
        
        for (const accountDir of accountDirs) {
          const contacts = await getAccountContacts(accountDir);
          const found = contacts.find(c => {
            const cPhone = (c.phone || '').replace(/\D/g, '');
            const searchPhone = phone.replace(/\D/g, '');
            return cPhone && searchPhone && cPhone === searchPhone;
          });
          if (found) {
            contact = found;
            accountId = accountDir;
            break;
          }
        }
      }
    }
    
    if (!contact || !accountId) {
      return res.status(404).json({ error: 'Contact not found' });
    }
    
    // Update contact preferences
    const contacts = await getAccountContacts(accountId);
    const contactIndex = contacts.findIndex(c => c.id === contact.id);
    if (contactIndex === -1) {
      return res.status(404).json({ error: 'Contact not found' });
    }
    
    ensureCommunicationPreferences(contacts[contactIndex]);
    contacts[contactIndex].communicationPreferences[channel] = {
      subscribed: false,
      unsubscribedAt: new Date().toISOString(),
      unsubscribeReason: reason || null,
      unsubscribeMethod: 'link'
    };
    
    await updateAccountContacts(accountId, contacts);
    
    // Add to suppression list for email unsubscribes
    if (channel === 'email' && email) {
      await addToSuppressionList(accountId, email, 'unsubscribe');
    }
    
    // Log unsubscribe event
    await logUnsubscribeEvent(accountId, {
      contactId: contact.id,
      contactName: `${contact.firstName || ''} ${contact.lastName || ''}`.trim() || 'Unknown',
      contactEmail: contact.email || null,
      contactPhone: contact.phone || null,
      channel: channel,
      reason: reason || null,
    });
    // Audit log for admin view
    await logAuditEvent('unsubscribe', 'UNSUBSCRIBE', {
      accountId,
      channel,
      contactId: contact.id,
      userEmail: 'Via unsubscribe link',
      identifier: channel === 'email' ? (contact.email || '') : (contact.phone || ''),
      method: 'link',
      ipAddress: req.ip || req.headers['x-forwarded-for'] || 'unknown',
      userAgent: req.headers['user-agent'] || 'unknown'
    });
    
    res.json({ success: true, message: `Successfully unsubscribed from ${channel} communications` });
  } catch (error) {
    console.error('Unsubscribe error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Resubscribe endpoint - public (no auth required)
app.post('/api/resubscribe', async (req, res) => {
  try {
    const { token, channel, email, phone } = req.body;
    
    if (!channel || !['email', 'sms', 'voice'].includes(channel)) {
      return res.status(400).json({ error: 'Invalid channel. Must be email, sms, or voice' });
    }
    
    // Find contact by email or phone
    let contact = null;
    let accountId = null;
    
    if (email) {
      const sharedDataDir = path.join(__dirname, 'data', 'shared-data');
      if (fs.existsSync(sharedDataDir)) {
        const accountDirs = fs.readdirSync(sharedDataDir).filter(f => {
          const accountPath = path.join(sharedDataDir, f);
          return fs.statSync(accountPath).isDirectory();
        });
        
        for (const accountDir of accountDirs) {
          const contacts = await getAccountContacts(accountDir);
          const found = contacts.find(c => c.email && c.email.toLowerCase() === email.toLowerCase());
          if (found) {
            contact = found;
            accountId = accountDir;
            break;
          }
        }
      }
    } else if (phone) {
      const sharedDataDir = path.join(__dirname, 'data', 'shared-data');
      if (fs.existsSync(sharedDataDir)) {
        const accountDirs = fs.readdirSync(sharedDataDir).filter(f => {
          const accountPath = path.join(sharedDataDir, f);
          return fs.statSync(accountPath).isDirectory();
        });
        
        for (const accountDir of accountDirs) {
          const contacts = await getAccountContacts(accountDir);
          const found = contacts.find(c => {
            const cPhone = (c.phone || '').replace(/\D/g, '');
            const searchPhone = phone.replace(/\D/g, '');
            return cPhone && searchPhone && cPhone === searchPhone;
          });
          if (found) {
            contact = found;
            accountId = accountDir;
            break;
          }
        }
      }
    }
    
    if (!contact || !accountId) {
      return res.status(404).json({ error: 'Contact not found' });
    }
    
    // Update contact preferences
    const contacts = await getAccountContacts(accountId);
    const contactIndex = contacts.findIndex(c => c.id === contact.id);
    if (contactIndex === -1) {
      return res.status(404).json({ error: 'Contact not found' });
    }
    
    ensureCommunicationPreferences(contacts[contactIndex]);
    contacts[contactIndex].communicationPreferences[channel] = {
      subscribed: true,
      unsubscribedAt: null,
      unsubscribeReason: null,
      unsubscribeMethod: null
    };
    
    await updateAccountContacts(accountId, contacts);
    
    res.json({ success: true, message: `Successfully re-subscribed to ${channel} communications` });
  } catch (error) {
    console.error('Resubscribe error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Export contacts to Excel/CSV endpoint (supports both GET and POST for URL length limits)
const exportContactsHandler = async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = getEffectiveAccountId(user);
    const isSpecial = await isSpecialContactStructure(accountId);
    
    // Get all contacts for the account
    const allContacts = await getAccountContacts(accountId);
    
    // Parse contact IDs from query parameter (GET) or body (POST)
    let contactIds = [];
    if (req.method === 'POST' && req.body.ids) {
      // POST request - IDs in body
      contactIds = Array.isArray(req.body.ids) ? req.body.ids : [];
    } else if (req.query.ids) {
      // GET request - IDs in query string
      try {
        contactIds = JSON.parse(req.query.ids);
      } catch (parseError) {
        console.error('Error parsing contact IDs:', parseError);
        contactIds = [];
      }
    }
    
    // Filter contacts based on IDs if provided
    let contactsToExport = contactIds.length > 0
      ? allContacts.filter(contact => contactIds.includes(contact.id))
      : allContacts;
    
    if (contactsToExport.length === 0) {
      throw new Error('No contacts found to export');
    }
    
    // Create Excel/CSV data with proper column headers based on structure
    const excelData = contactsToExport.map(contact => {
      if (isSpecial) {
        // Special EDA structure: Name, Riding, Province, Email, Role, Phone, Category, Poll #
        const categories = Array.isArray(contact.categories) 
          ? contact.categories.join('; ') 
          : (contact.category || '');
        return {
          'Name': contact.name || '',
          'Riding': contact.riding || '',
          'Province': contact.province || '',
          'Email': contact.email || '',
          'Role': contact.role || '',
          'Phone': contact.phone || '',
          'Category': categories,
          'Poll #': contact.pollNumber || ''
        };
      } else {
        // Standard structure
        // Handle categories - support both old single category and new multiple categories
        const categories = Array.isArray(contact.categories) 
          ? contact.categories.join('; ') 
          : (contact.category || '');
        
        return {
          'First Name': contact.firstName || '',
          'Last Name': contact.lastName || '',
          'Email': contact.email || '',
          'Phone': contact.phone || '',
          'Address': contact.address || '',
          'City': contact.city || '',
          'Province': contact.province || '',
          'Postal Code': contact.postalCode || '',
          'Category': categories,
          'Poll #': contact.pollNumber || ''
        };
      }
    });
    
    // Generate CSV content (Excel-compatible)
    if (excelData.length === 0) {
      throw new Error('No data to export');
    }
    
    const csvHeaders = Object.keys(excelData[0]).join(',');
    const csvRows = excelData.map(row => 
      Object.values(row).map(value => {
        // Escape commas and quotes in values
        const stringValue = String(value || '');
        if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
          return `"${stringValue.replace(/"/g, '""')}"`;
        }
        return stringValue;
      }).join(',')
    );
    
    const csvContent = [csvHeaders, ...csvRows].join('\n');
    
    // Set response headers for Excel download
    const filename = `contacts_export_${new Date().toISOString().split('T')[0]}.csv`;
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(csvContent);
    
  } catch (error) {
    console.error('Export contacts error:', error);
    res.status(400).json({ error: error.message });
  }
};

app.get('/api/contacts/export', auth, exportContactsHandler);
app.post('/api/contacts/export', auth, exportContactsHandler);

// Get templates endpoint
app.get('/api/templates', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = getEffectiveAccountId(user);
    
    let messageTemplates = await getAccountTemplates(accountId);
    
    // Initialize templates array if it doesn't exist
    if (!messageTemplates || messageTemplates.length === 0) {
      messageTemplates = [];
    }
    
    // Ensure all users have access to the Basic Marketing Template
    const basicMarketingTemplate = {
      id: 'default',
      name: 'Basic Marketing Template',
      headerText: 'Campaign Builder',
      headerImage: 'https://images.unsplash.com/photo-1557804506-669a67965ba0?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2074&q=80',
      bannerImage: '',
      category: 'marketing',
      tags: ['newsletter', 'promotional'],
      bodyElements: [
        {
          type: 'text',
          content: 'Thank you for being a valued customer. We appreciate your business.'
        },
        {
          type: 'button',
          text: 'Visit Our Website',
          url: 'https://swiftmedia.ca'
        }
      ],
      footerImage: '',
      footerText: 'Contact: info@campaignbuilder.com | Phone: (555) 123-4567\nFollow us: @campaignbuilder\nÂ© 2024 Campaign Builder. All rights reserved.',
      footerLinks: [
        {
          text: 'Privacy Policy',
          url: '#'
        },
        {
          text: 'Contact Us',
          url: '#'
        }
      ],
      style: {
        headerOverlay: 'bg-gradient-to-r from-indigo-900 to-indigo-600 mix-blend-multiply',
        headerTextColor: 'text-white'
      },
      updatedAt: new Date().toISOString(),
      isDefault: true
    };
    
    // Check if user already has the Basic Marketing Template
    const hasBasicTemplate = messageTemplates.some(template => template.id === 'default');

    // If user doesn't have the Basic Marketing Template, add it
    if (!hasBasicTemplate) {
      messageTemplates.unshift(basicMarketingTemplate);

      // Save to shared-data
      try {
        const sharedTemplatesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'templates.json');
        await fsPromises.writeFile(sharedTemplatesPath, JSON.stringify(messageTemplates, null, 2), 'utf8');

      } catch (error) {
        console.error('Error saving basic template to shared-data:', error);
      }
    }
    
    // Fix any templates with missing or invalid IDs
    let needsUpdate = false;
    messageTemplates.forEach((template, index) => {
      if (!template.id || template.id === '' || template.id === undefined || template.id === null) {
        template.id = Date.now().toString() + index;
        needsUpdate = true;

      }
    });
    
    // Save the templates if we made any updates
    if (needsUpdate) {
      try {
        const sharedTemplatesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'templates.json');
        await fsPromises.writeFile(sharedTemplatesPath, JSON.stringify(messageTemplates, null, 2), 'utf8');

      } catch (error) {
        console.error('Error saving updated templates to shared-data:', error);
      }
    }

    const normalized = messageTemplates.map(t => normalizeTemplateImageUrls(t));
    res.json(normalized);
  } catch (error) {
    console.error('Error fetching templates:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get single template endpoint
app.get('/api/templates/:id', auth, async (req, res) => {
  try {
    const templateId = req.params.id;
    const user = await findUserById(req.user.id);
    
    // Get templates from shared-data (use accountId if available, otherwise user ID for app owners)
    const accountId = user.accountId || user.id;
    let templates = [];
    try {
      templates = await getAccountTemplates(accountId);
    } catch (error) {
      console.error('Error loading account templates:', error);
      templates = [];
    }
    
    const template = templates.find(t => t.id === templateId);
    if (!template) {
      return res.status(404).json({ error: 'Template not found' });
    }
    
    res.json(normalizeTemplateImageUrls(template));
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get template version history endpoint
app.get('/api/templates/:id/versions', auth, async (req, res) => {
  try {
    const templateId = req.params.id;
    const user = await findUserById(req.user.id);
    
    // Get templates using standardized function
    const accountId = getEffectiveAccountId(user);
    const templates = await getAccountTemplates(accountId);
    
    const template = templates.find(t => t.id === templateId);
    if (!template) {
      return res.status(404).json({ error: 'Template not found' });
    }

    // Get actual version history from template
    if (!template.versionHistory) {
      template.versionHistory = [];
    }
    
    // If no version history exists, create initial version
    if (template.versionHistory.length === 0) {

      // Create clean copy of current template
      const templateCopy = { ...template };
      delete templateCopy.versionHistory;
      
      // Get the actual creation date or use current date
      const creationDate = template.createdAt || template.updatedAt || new Date().toISOString();
      
      // Add initial version
      template.versionHistory.push({
        id: 'v1',
        version: 1,
        timestamp: creationDate,
        changes: 'Initial template creation',
        author: user.name || user.email || 'User',
        template: templateCopy
      });
      
      // Save the updated template with version history
      // Update shared templates
      const sharedTemplatesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'templates.json');
      await fsPromises.writeFile(sharedTemplatesPath, JSON.stringify(templates, null, 2), 'utf8');

    } else {
      // Clean up any incorrect version history (with fake dates or "Current User")
      const needsCleanup = template.versionHistory.some(version => 
        version.author === 'Current User' || 
        (version.timestamp && version.timestamp.includes('2025-06-22'))
      );
      
      if (needsCleanup) {

        // Clear existing version history
        template.versionHistory = [];
        
        // Create clean copy of current template
        const templateCopy = { ...template };
        delete templateCopy.versionHistory;
        
        // Get the actual creation date
        const creationDate = template.createdAt || template.updatedAt || new Date().toISOString();
        
        // Add corrected initial version
        template.versionHistory.push({
          id: 'v1',
          version: 1,
          timestamp: creationDate,
          changes: 'Initial template creation',
          author: user.name || user.email || 'User',
          template: templateCopy
        });
        
        // Save the updated template with corrected version history
        // Update shared templates
        const sharedTemplatesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'templates.json');
        await fsPromises.writeFile(sharedTemplatesPath, JSON.stringify(templates, null, 2), 'utf8');

      }
    }
    
    res.json(template.versionHistory);
  } catch (error) {
    console.error('Error in version history endpoint:', error);
    res.status(400).json({ error: error.message });
  }
});

// Restore template version endpoint
app.post('/api/templates/:id/restore', auth, async (req, res) => {
  try {
    const templateId = req.params.id;
    const { versionId } = req.body;
    const user = await findUserById(req.user.id);
    
    // Get templates using standardized function
    const accountId = getEffectiveAccountId(user);
    const templates = await getAccountTemplates(accountId);
    
    const templateIndex = templates.findIndex(t => t.id === templateId);
    if (templateIndex === -1) {
      return res.status(404).json({ error: 'Template not found' });
    }
    
    const template = templates[templateIndex];
    if (!template.versionHistory) {
      return res.status(404).json({ error: 'No version history found' });
    }
    
    const version = template.versionHistory.find(v => v.id === versionId);
    if (!version) {
      return res.status(404).json({ error: 'Version not found' });
    }
    
    // Restore the template to the selected version
    const restoredTemplate = {
      ...version.template,
      id: templateId,
      updatedAt: new Date().toISOString(),
      versionHistory: template.versionHistory
    };
    
    templates[templateIndex] = restoredTemplate;
    
    // Save the updated templates
    // Update shared templates
    const sharedTemplatesPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'templates.json');
    await fsPromises.writeFile(sharedTemplatesPath, JSON.stringify(templates, null, 2), 'utf8');
    
    res.json(restoredTemplate);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.get('/my-tokens', auth, requireActiveAccount, requireNdaAcceptance, async (req, res) => {
  try {
    // Only account holders and app owners can access token management
    if (req.user.userType === 'team_member') {
      return res.status(403).send('Access denied. Team members cannot access token management.');
    }
    
    res.render('my-tokens', {
      user: req.user,
      path: '/my-tokens',
      layout: 'layout'
    });
  } catch (error) {
    return redirectToLogin(res, req, 'my-tokens', 'CATCH');
  }
});

// Auto-reply settings
app.post('/api/settings/auto-reply', auth, async (req, res) => {
  try {
    const { isEnabled, message } = req.body;
    const user = await findUserById(req.user.id);
    
    user.autoReply = { isEnabled, message };
    
    await writeIndividualUserFile(req.user.id, user);
    res.json(user.autoReply);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Admin routes
app.get('/api/admin/accounts', adminAuth, async (req, res) => {
    try {
        const path = require('path');
        
        // Get all account directories from shared-data
        const accountDirs = await fsPromises.readdir(SHARED_DATA_DIR);
        
        const accounts = [];
        for (const accountId of accountDirs) {
            try {
                // Get account holder info from individual-data (use readIndividualUserData to handle both structures)
                const user = await readIndividualUserData(accountId);
                
                if (user) {
                    // Include all accounts regardless of account type (app_owner, account_holder, etc.)
                    const nameRaw = user.company || user.email || `Account ${accountId}`;
                    const name = typeof nameRaw === 'object' && nameRaw && (nameRaw.name || nameRaw.email) ? (nameRaw.name || nameRaw.email) : (typeof nameRaw === 'string' ? nameRaw : user.email || `Account ${accountId}`);
                    accounts.push({
                        id: accountId,
                        name: name,
                        email: user.email,
                        userType: user.userType || 'account_holder',
                        accountType: user.accountType,
                        createdAt: user.createdAt,
                        isActive: user.isActive !== false
                    });
                }
            } catch (error) {
                console.error(`Error reading account ${accountId}:`, error);
            }
        }
        
        res.json(accounts);
    } catch (error) {
        console.error('Admin accounts endpoint error:', error);
        res.status(400).json({ error: error.message });
    }
});

app.get('/api/admin/users', adminAuth, async (req, res) => {
    try {
        const path = require('path');
        
        // Get all user entries from individual-data (both files and directories)
        const entries = await fsPromises.readdir(INDIVIDUAL_DATA_DIR);
        
        const users = [];
        for (const entry of entries) {
            try {
                // Check if it's a directory or file
                const entryPath = path.join(INDIVIDUAL_DATA_DIR, entry);
                const stats = await fsPromises.stat(entryPath);
                
                let userId;
                
                if (stats.isDirectory()) {
                    // New structure: directory name is userId
                    userId = entry;
                } else if (stats.isFile() && entry.endsWith('.json')) {
                    // Old structure: filename is userId.json
                    userId = entry.replace(/\.json$/, '');
                } else {
                    // Skip non-user entries
                    continue;
                }
                
                // Use readIndividualUserData to handle both structures
                const user = await readIndividualUserData(userId);
                if (!user) {
                    continue; // Skip if user not found
                }
                
                // Build user info including username and personal info
                let smsTokens = user.smsTokens || 0;
                let emailTokens = user.emailTokens || 0;
                let aiTokens = user.aiTokens || 0;
                
                // For team members and account holders, get tokens from shared-data
                if ((user.userType === 'team_member' && user.accountId) || user.userType === 'account_holder') {
                    const accountId = user.accountId || userId; // Use accountId for team members, userId for account holders
                    try {
                        const sharedTokensPath = path.join(SHARED_DATA_DIR, accountId, 'tokens.json');
                        if (await fsPromises.access(sharedTokensPath).then(() => true).catch(() => false)) {
                            const sharedTokensData = await fsPromises.readFile(sharedTokensPath, 'utf8');
                            const sharedTokens = JSON.parse(sharedTokensData);
                            smsTokens = sharedTokens.smsTokens || 0;
                            emailTokens = sharedTokens.emailTokens || 0;
                            aiTokens = sharedTokens.aiTokens || 0;
                        }
                    } catch (error) {
                        console.error(`Error reading shared tokens for ${user.userType} ${userId}:`, error);
                    }
                }
                
                const userInfo = {
                    id: userId,
                    email: user.email || user.username || (user.personalInfo && user.personalInfo.email) || null,
                    isVerified: user.isVerified,
                    smsTokens: smsTokens,
                    emailTokens: emailTokens,
                    aiTokens: aiTokens,
                    userType: user.userType || 'user',
                    firstName: user.personalInfo ? user.personalInfo.firstName : '',
                    lastName: user.personalInfo ? user.personalInfo.lastName : '',
                    phone: user.personalInfo ? user.personalInfo.phone : '',
                    company: user.company ? (typeof user.company === 'string' ? user.company : user.company.name) : null,
                    createdAt: user.analytics ? user.analytics.createdAt : null,
                    lastLoginAt: user.lastLoginAt || (user.analytics ? user.analytics.lastLoginAt : null),
                    isAdmin: user.isAdmin || false,
                    accountId: user.accountId || null
                };
                
                // Debug logging for specific user
                if (userId === '1756936178067') {

                }
                users.push(userInfo);
            } catch (error) {
                // Silently skip entries that can't be processed - don't log errors for expected cases
                // (e.g., old file structure entries that are being handled gracefully)
                continue;
            }
        }
        res.json(users);
    } catch (error) {
        console.error('Admin users endpoint error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Permission checking endpoint
app.get('/api/permissions/check/:permission', auth, async (req, res) => {
  try {
    const user = req.user;
    const permission = req.params.permission;
    
    const hasPermission = checkUserPermission(user, permission);
    
    res.json({ 
      hasPermission,
      userType: user.userType,
      permission: permission
    });
    
  } catch (error) {
    console.error('Permission check error:', error);
    res.status(500).json({ error: 'Permission check failed' });
  }
});

// Get user permissions endpoint
app.get('/api/permissions/user', auth, async (req, res) => {
  try {
    const user = req.user;
    
    const permissions = user.permissions || USER_PERMISSIONS[user.userType?.toUpperCase()] || [];
    
    res.json({
      userType: user.userType,
      permissions: permissions,
      accountId: user.accountId
    });
    
  } catch (error) {
    console.error('Get permissions error:', error);
    res.status(500).json({ error: 'Failed to get permissions' });
  }
});

// User invitation endpoints
app.post('/api/users/invite', auth, requirePermission('invite_users'), async (req, res) => {
  try {
    const { email } = req.body;
    const inviter = await findUserById(req.user.id);
    
    if (!email) {
      return res.status(400).json({ error: 'Email is required' });
    }
    
    // Use getEffectiveAccountId to handle cases where accountId might be undefined
    const accountId = getEffectiveAccountId(inviter);
    
    // Check if user is already a team member of THIS account (not globally)
    const existingUser = await findUserByEmail(email);
    if (existingUser && existingUser.accountId === accountId) {
      return res.status(400).json({ error: 'This user is already a member of your team' });
    }
    
    // Check if there's already a pending invitation for this email in THIS account
    const existingInvitations = await getAccountInvitations(accountId);
    const pendingInvitation = existingInvitations.find(inv => 
      inv.email === email && inv.status === 'pending' && inv.expiresAt > Date.now()
    );
    
    if (pendingInvitation) {
      return res.status(400).json({ 
        error: 'Invitation already sent to this email. Use the Resend button to send it again.',
        invitationId: pendingInvitation.id
      });
    }
    
    // Create invitation
    const invitation = await createInvitation({
      accountId: accountId,
      invitedBy: inviter.id,
      email: email
    });
    
    // Send invitation email
    let emailSent = false;
    let emailError = null;
    
    try {
      const inviteLink = `${req.protocol}://${req.get('host')}/accept-invitation?token=${invitation.token}`;
      
      console.log(`[INVITATION] Attempting to send invitation email to ${email} from account ${accountId}`);
      console.log(`[INVITATION] Inviter: ${inviter.email}, ID: ${inviter.id}`);
      
      // Use a sender email that matches SMTP authentication to avoid rejection
      // Prefer SYSTEM_EMAIL, otherwise use SMTP_USER to match authenticated user
      const fromEmail = process.env.SYSTEM_EMAIL || process.env.SMTP_USER || 'smtp@sw7ft.com';
      
      const senderName = inviter.company?.name || 'Campaign Builder';
      
      // Use sendTransactionalEmail for invitation emails (system emails)
      await sendTransactionalEmail({
        from: fromEmail,
        fromName: senderName,
        to: email,
        subject: `You're invited to join ${inviter.company?.name || 'our team'} on Campaign Builder`,
        html: `
          <h2>You've been invited to join a team!</h2>
          <p>${inviter.email} has invited you to join their team on Campaign Builder.</p>
          <p>Click the link below to accept the invitation and create your account:</p>
          <p><a href="${inviteLink}" style="background: #007bff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px;">Accept Invitation</a></p>
          <p>This invitation will expire in 7 days.</p>
          <p>If you have any questions, please contact ${inviter.email}</p>
        `,
        text: `${inviter.email} has invited you to join their team on Campaign Builder. Click this link to accept: ${inviteLink}. This invitation will expire in 7 days.`
      }, inviter);
      
      emailSent = true;
      console.log(`[INVITATION] Successfully sent invitation email to ${email}`);

    } catch (err) {
      emailError = err;
      console.error('[INVITATION] Failed to send invitation email:', err);
      console.error('[INVITATION] Error details:', {
        message: err.message,
        stack: err.stack,
        to: email,
        inviterId: inviter.id,
        accountId: accountId
      });
    }
    
    // Return response with email status
    if (emailSent) {
      res.json({
        message: 'Invitation sent successfully',
        invitation: {
          id: invitation.id,
          email: invitation.email,
          createdAt: invitation.createdAt,
          expiresAt: invitation.expiresAt,
          status: invitation.status
        }
      });
    } else {
      // Invitation was created but email failed
      const errorMessage = emailError?.message || 'Unknown error';
      res.status(500).json({
        error: 'Invitation created but email failed to send',
        details: errorMessage.includes('authentication') 
          ? 'SMTP authentication failed. Please check your email sender settings and SMTP credentials.'
          : errorMessage.includes('No sender emails')
          ? 'No verified sender emails found. Please add and verify an email sender in your settings.'
          : errorMessage,
        invitation: {
          id: invitation.id,
          email: invitation.email,
          createdAt: invitation.createdAt,
          expiresAt: invitation.expiresAt,
          status: invitation.status
        },
        emailFailed: true
      });
    }
    
  } catch (error) {
    console.error('Invite user error:', error);
    res.status(500).json({ error: 'Failed to send invitation' });
  }
});

// Get team members and invitations
app.get('/api/users/team', auth, requirePermission('manage_users'), async (req, res) => {
  try {
    const user = req.user;
    // Use getEffectiveAccountId to handle cases where accountId might be undefined
    const accountId = getEffectiveAccountId(user);
    
    // Get all users in this account
    const allUsers = await getUsersByAccount(accountId);
    
    // Get pending invitations (exclude cancelled)
    const invitations = await getAccountInvitations(accountId);
    const pendingInvitations = invitations.filter(inv => 
      inv.status === 'pending' && inv.expiresAt > Date.now()
    );
    
    res.json({
      teamMembers: allUsers.map(u => ({
        id: u.id,
        email: u.email,
        userType: u.userType,
        personalInfo: u.personalInfo,
        lastLoginAt: u.lastLoginAt,
        createdAt: u.createdAt
      })),
      pendingInvitations: pendingInvitations.map(inv => ({
        id: inv.id,
        email: inv.email,
        createdAt: inv.createdAt,
        expiresAt: inv.expiresAt,
        invitedBy: inv.invitedBy
      }))
    });
    
  } catch (error) {
    console.error('Get team error:', error);
    res.status(500).json({ error: 'Failed to get team information' });
  }
});

// Accept invitation endpoint
app.post('/api/users/accept-invitation', async (req, res) => {
  try {
    const { token, userData } = req.body;
    const { email, password, firstName, lastName, phone } = userData;
    
    // Validate invitation
    const invitation = await getInvitationByToken(token);
    if (!invitation) {
      return res.status(400).json({ error: 'Invalid invitation token' });
    }
    
    if (invitation.status !== 'pending') {
      return res.status(400).json({ error: 'Invitation has already been used' });
    }
    
    if (invitation.expiresAt < Date.now()) {
      return res.status(400).json({ error: 'Invitation has expired' });
    }
    
    if (invitation.email !== email) {
      return res.status(400).json({ error: 'Email does not match invitation' });
    }
    
    // Check if user already exists
    const existingUser = await findUserByEmail(email);
    
    // If user exists and is already on this account, don't allow duplicate
    if (existingUser && existingUser.accountId === invitation.accountId) {
      return res.status(400).json({ error: 'You are already a member of this team' });
    }
    
    // If user exists but is on a different account, they can join this account too
    // We'll create a new user record for this account (same email, different accountId)
    // This allows users to be on multiple accounts
    const userId = Date.now().toString();
    const hashedPassword = await bcrypt.hash(password, 12);
    
    // Get account name for audit logging
    let accountName = 'Unknown Account';
    try {
      const account = await getAccount(invitation.accountId);
      accountName = account?.companyInfo?.name || account?.ownerId || 'Unknown Account';
    } catch (error) {

    }
    
    const newUser = {
      id: userId,
      email: email,
      username: null,
      password: hashedPassword,
      verificationToken: null,
      isVerified: true, // Auto-verify invited users
      is2FAEnabled: false,
      userType: 'team_member', // All invited users are 'team_member' type
      accountId: invitation.accountId,
      invitedBy: invitation.invitedBy,
      permissions: [
        'manage_contacts', 'manage_campaigns', 'manage_templates', 'view_analytics',
        'view_settings', 'send_campaigns', 'send_messages'
      ], // Team member permissions (same as USER but with team_member type)
      personalInfo: {
        firstName: firstName || '',
        lastName: lastName || '',
        phone: phone || ''
      },
      tokenBalance: 0,
      contacts: [], // Users will access account-level contacts
      messageTemplates: [], // Users will access account-level templates
      autoReply: { isEnabled: false, message: '' },
      smsMessages: { sent: [], received: [] },
      tokenTransactions: [],
      messages: [],
      invoices: [],
      smsTokens: { count: 0, lastUpdated: Date.now() },
      emailTokens: { count: 0, lastUpdated: Date.now() },
      company: null,
      campaigns: [], // Users will access account-level campaigns
      createdAt: Date.now(),
      lastLoginAt: null,
      isAdmin: false
    };
    
    // Save user to individual-data structure (new system - NO FALLBACK)
    await writeIndividualUserFile(userId, newUser);

    // Update invitation status
    await updateInvitation(invitation.id, {
      status: 'accepted',
      acceptedAt: Date.now()
    });

    // Log team member addition
    await logAuditEvent(invitation.invitedBy, 'TEAM_MEMBER_ADDED', {
      teamMemberEmail: email,
      teamMemberId: userId,
      accountId: invitation.accountId,
      accountName: accountName
    }, req);
    
    res.json({
      message: 'Invitation accepted successfully',
      userId: userId,
      accountId: invitation.accountId
    });
    
  } catch (error) {
    console.error('Accept invitation error:', error);
    res.status(500).json({ error: 'Failed to accept invitation' });
  }
});

// Remove team member
app.delete('/api/users/:userId', auth, requirePermission('manage_users'), async (req, res) => {
  try {
    const removerUser = req.user;
    const targetUserId = req.params.userId;
    const targetUser = await findUserById(targetUserId);
    
    if (!targetUser) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Can't remove users from different accounts
    if (targetUser.accountId !== removerUser.accountId) {
      return res.status(403).json({ error: 'Cannot remove users from other accounts' });
    }
    
    // Can't remove account holders
    if (targetUser.userType === 'account_holder') {
      return res.status(403).json({ error: 'Cannot remove account holders' });
    }
    
    // Log team member removal before deleting
    const accountNameRaw = targetUser.company || 'Unknown Account';
    const accountNameStr = typeof accountNameRaw === 'object' && accountNameRaw && accountNameRaw.name ? accountNameRaw.name : (typeof accountNameRaw === 'string' ? accountNameRaw : 'Unknown Account');
    await logAuditEvent(removerUser.id, 'TEAM_MEMBER_REMOVED', {
      teamMemberEmail: targetUser.email || targetUser.username || 'Unknown',
      teamMemberId: targetUserId,
      accountId: targetUser.accountId,
      accountName: accountNameStr
    }, req);
    
    // Delete user
    await deleteUserFile(targetUserId);
    
    res.json({ message: 'Team member removed successfully' });
    
  } catch (error) {
    console.error('Remove user error:', error);
    res.status(500).json({ error: 'Failed to remove team member' });
  }
});

// Resend invitation endpoint
app.post('/api/users/invitations/:invitationId/resend', auth, requirePermission('invite_users'), async (req, res) => {
  try {
    const { invitationId } = req.params;
    const inviter = await findUserById(req.user.id);
    
    // Get the invitation
    const invitation = await getInvitation(invitationId);
    if (!invitation) {
      return res.status(404).json({ error: 'Invitation not found' });
    }
    
    // Check if user owns this invitation
    if (invitation.invitedBy !== inviter.id) {
      return res.status(403).json({ error: 'Not authorized to resend this invitation' });
    }
    
    // Check if invitation is still pending
    if (invitation.status !== 'pending') {
      return res.status(400).json({ error: 'Can only resend pending invitations' });
    }
    
    // Check if invitation is expired
    if (invitation.expiresAt < Date.now()) {
      return res.status(400).json({ error: 'Cannot resend expired invitation' });
    }
    
    // Create new invitation link
    const inviteLink = `${req.protocol}://${req.get('host')}/accept-invitation?token=${invitation.token}`;
    
    // Resend invitation email
    try {
      await sendEmail({
        to: invitation.email,
        subject: `Reminder: You're invited to join ${inviter.company?.name || 'our team'} on Campaign Builder`,
        html: `
          <h2>Invitation Reminder</h2>
          <p>${inviter.email} has invited you to join their team on Campaign Builder.</p>
          <p>This is a reminder that your invitation is still pending.</p>
          <p>Click the link below to accept the invitation and create your account:</p>
          <p><a href="${inviteLink}" style="background: #007bff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px;">Accept Invitation</a></p>
          <p>This invitation will expire on ${new Date(invitation.expiresAt).toLocaleDateString()}.</p>
          <p>If you have any questions, please contact ${inviter.email}</p>
        `
      }, inviter);

    } catch (emailError) {
      console.error('Failed to resend invitation email:', emailError);
      return res.status(500).json({ error: 'Failed to send invitation email' });
    }
    
    res.json({ message: 'Invitation resent successfully' });
    
  } catch (error) {
    console.error('Resend invitation error:', error);
    res.status(500).json({ error: 'Failed to resend invitation' });
  }
});

// Cancel invitation endpoint
app.delete('/api/users/invitations/:invitationId', auth, requirePermission('invite_users'), async (req, res) => {
  try {
    const { invitationId } = req.params;
    const inviter = await findUserById(req.user.id);
    
    // Get the invitation
    const invitation = await getInvitation(invitationId);
    if (!invitation) {
      return res.status(404).json({ error: 'Invitation not found' });
    }
    
    // Check if user owns this invitation
    if (invitation.invitedBy !== inviter.id) {
      return res.status(403).json({ error: 'Not authorized to cancel this invitation' });
    }
    
    // Update invitation status to cancelled
    await updateInvitation(invitationId, {
      status: 'cancelled',
      cancelledAt: Date.now()
    });
    
    res.json({ message: 'Invitation cancelled successfully' });
    
  } catch (error) {
    console.error('Cancel invitation error:', error);
    res.status(500).json({ error: 'Failed to cancel invitation' });
  }
});

// Validate invitation endpoint (no auth required)
app.get('/api/invitations/validate', async (req, res) => {
  try {
    const { token } = req.query;
    
    if (!token) {
      return res.status(400).json({ error: 'Token is required' });
    }
    
    const invitation = await getInvitationByToken(token);
    if (!invitation) {
      return res.status(400).json({ error: 'Invalid invitation token' });
    }
    
    if (invitation.status !== 'pending') {
      return res.status(400).json({ error: 'Invitation has already been used' });
    }
    
    if (invitation.expiresAt < Date.now()) {
      return res.status(400).json({ error: 'Invitation has expired' });
    }
    
    // Get inviter info
    let inviterEmail = 'A team member';
    try {
      const inviter = await findUserById(invitation.invitedBy);
      if (inviter) {
        inviterEmail = inviter.email;
      }
    } catch (error) {
      console.error('Error getting inviter info:', error);
    }
    
    res.json({
      invitation: {
        id: invitation.id,
        email: invitation.email,
        accountId: invitation.accountId,
        createdAt: invitation.createdAt,
        expiresAt: invitation.expiresAt
      },
      inviterEmail: inviterEmail
    });
    
  } catch (error) {
    console.error('Validate invitation error:', error);
    res.status(500).json({ error: 'Failed to validate invitation' });
  }
});

// Migration endpoint (admin only)
app.post('/api/admin/migrate-multiuser', adminAuth, async (req, res) => {
  try {
    const result = await migrateToMultiUserSystem();
    
    if (result.success) {
      res.json({ message: result.message, success: true });
    } else {
      res.status(500).json({ error: result.error, success: false });
    }
    
  } catch (error) {
    console.error('Migration endpoint error:', error);
    res.status(500).json({ error: 'Migration failed', details: error.message });
  }
});

app.post('/api/admin/adjust-tokens', adminAuth, async (req, res) => {
    try {
        const { userId, smsTokens, emailTokens, aiTokens, reason } = req.body;
        
        // Input validation
        if (!userId || !/^\d+$/.test(userId)) {
            return res.status(400).json({ error: 'Invalid user ID format' });
        }
        
        if (typeof smsTokens !== 'number' || typeof emailTokens !== 'number' || typeof aiTokens !== 'number') {
            return res.status(400).json({ error: 'Token amounts must be numbers' });
        }
        
        if (smsTokens < 0 || emailTokens < 0 || aiTokens < 0) {
            return res.status(400).json({ error: 'Token amounts cannot be negative' });
        }
        
        if (smsTokens > 100000 || emailTokens > 100000 || aiTokens > 100000) {
            return res.status(400).json({ error: 'Token amounts too large (max 100,000)' });
        }
        
        if (!reason || typeof reason !== 'string' || reason.trim().length < 3) {
            return res.status(400).json({ error: 'Reason is required and must be at least 3 characters' });
        }
        
        // Get user data
        const user = await findUserById(userId);
        if (!user) {
            throw new Error('User not found');
        }
        
        // Set absolute token amounts (no calculations needed)
        const newSmsTokens = smsTokens;
        const newEmailTokens = emailTokens;
        const newAiTokens = aiTokens;
        
        // Update shared-data tokens (this is what the account displays)
        const tokenUpdates = {
            smsTokens: newSmsTokens,
            emailTokens: newEmailTokens,
            aiTokens: newAiTokens
        };
        
        await updateAccountTokens(user.accountId || userId, tokenUpdates);
        
        // Add transaction record to user's individual file
        if (!user.tokenTransactions) {
            user.tokenTransactions = [];
        }
        user.tokenTransactions.push({
            id: Date.now().toString(),
            type: 'admin_set',
            smsTokens: newSmsTokens,
            emailTokens: newEmailTokens,
            aiTokens: newAiTokens,
            reason: reason || '',
            timestamp: new Date().toISOString()
        });
        
        // Update user's individual file with new token amounts (for consistency)
        user.smsTokens = newSmsTokens;
        user.emailTokens = newEmailTokens;
        user.aiTokens = newAiTokens;
        
        await writeIndividualUserFile(userId, user);
        
        // For team members, also update the account holder's individual file
        if (user.userType === 'team_member' && user.accountId) {
            const accountHolder = await findUserById(user.accountId);
            if (accountHolder) {
                accountHolder.smsTokens = newSmsTokens;
                accountHolder.emailTokens = newEmailTokens;
                accountHolder.aiTokens = newAiTokens;
                await writeIndividualUserFile(user.accountId, accountHolder);
            }
        }

        res.json({ success: true, user: { ...user, password: undefined } });
    } catch (error) {
        console.error('Token adjustment error:', error);
        res.status(400).json({ error: error.message });
    }
});

app.delete('/api/admin/users/:id', adminAuth, async (req, res) => {
    try {
        const path = require('path');
        
        const userId = req.params.id;
        
        // Validate user ID format
        if (!userId || !/^\d+$/.test(userId)) {
            return res.status(400).json({ error: 'Invalid user ID format' });
        }
        
        // Get user data first to check if they have shared data
        const user = await readIndividualUserData(userId);
        
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        try {
            
            // If this user has shared data (account holder), clean it up
            const accountId = user.accountId || userId;
            const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
            
            if (fs.existsSync(sharedDataPath)) {
                await fsPromises.rm(sharedDataPath, { recursive: true, force: true });
            }
            
            // Delete the user directory
            const userDir = path.join(INDIVIDUAL_DATA_DIR, userId);
            if (fs.existsSync(userDir)) {
                await fsPromises.rm(userDir, { recursive: true, force: true });
            }

            res.json({ success: true, message: 'User and associated data deleted successfully' });
        } catch (fileError) {
            if (fileError.code === 'ENOENT') {
                // Directory doesn't exist, but user record was found - still return success
                return res.json({ success: true, message: 'User deleted (data directories were already removed)' });
            }
            throw fileError;
        }
    } catch (error) {
        console.error('Delete user error:', error);
        res.status(500).json({ error: 'Failed to delete user: ' + error.message });
    }
});

// Admin phone numbers endpoint
app.get('/api/admin/phone-numbers', adminAuth, async (req, res) => {
    try {
        const path = require('path');
        
        // Get all account directories from shared-data
        const accountDirs = await fsPromises.readdir(SHARED_DATA_DIR);
        
        const allPhoneNumbers = [];
        
        for (const accountId of accountDirs) {
            try {
                const phoneNumbersPath = path.join(SHARED_DATA_DIR, accountId, 'phoneNumbers.json');
                
                // Check if phoneNumbers.json exists
                try {
                    await fsPromises.access(phoneNumbersPath);
                } catch {
                    // File doesn't exist, skip this account
                    continue;
                }
                
                const phoneNumbersData = await fsPromises.readFile(phoneNumbersPath, 'utf8');
                const phoneNumbers = JSON.parse(phoneNumbersData);
                
                // Get user info for this account
                let userEmail = 'Unknown User';
                try {
                    const user = await readIndividualUserData(accountId);
                    if (user) {
                        userEmail = user.email || user.username || 'Unknown User';
                    }
                } catch (error) {
                    // Continue with default
                }
                
                // Add user info to each phone number
                for (const phoneNumber of phoneNumbers) {
                    allPhoneNumbers.push({
                        ...phoneNumber,
                        userId: accountId,
                        userEmail: userEmail
                    });
                }
            } catch (error) {
                console.error(`Error reading phone numbers for account ${accountId}:`, error.message);
                // Continue with other accounts even if one fails
            }
        }
        
        res.json(allPhoneNumbers);
    } catch (error) {
        console.error('Admin phone numbers endpoint error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Admin messages endpoint
// Admin endpoint to get campaign notifications (paused campaigns, high bounce rates, etc.)
app.get('/api/admin/notifications', adminAuth, async (req, res) => {
  try {
    const { accountId, unreadOnly = false } = req.query;
    
    if (accountId) {
      // Get notifications for specific account
      const notificationsPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'admin-notifications.json');
      let notifications = [];
      
      if (fs.existsSync(notificationsPath)) {
        try {
          const data = await fsPromises.readFile(notificationsPath, 'utf8');
          notifications = JSON.parse(data);
        } catch (error) {
          console.error('Error reading admin notifications:', error);
        }
      }
      
      if (unreadOnly === 'true') {
        notifications = notifications.filter(n => !n.read);
      }
      
      // Sort by timestamp (newest first)
      notifications.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      return res.json({ notifications });
    } else {
      // Get notifications for all accounts (admin view)
      const sharedDataDir = SHARED_DATA_DIR;
      const allNotifications = [];
      
      if (fs.existsSync(sharedDataDir)) {
        const accountDirs = fs.readdirSync(sharedDataDir).filter(f => {
          const accountPath = path.join(sharedDataDir, f);
          return fs.statSync(accountPath).isDirectory();
        });
        
        for (const accountDir of accountDirs) {
          const notificationsPath = path.join(sharedDataDir, accountDir, 'admin-notifications.json');
          if (fs.existsSync(notificationsPath)) {
            try {
              const data = await fsPromises.readFile(notificationsPath, 'utf8');
              const notifications = JSON.parse(data);
              notifications.forEach(n => {
                allNotifications.push({
                  ...n,
                  accountId: accountDir
                });
              });
            } catch (error) {
              console.error(`Error reading notifications for account ${accountDir}:`, error);
            }
          }
        }
      }
      
      // Filter unread if requested
      let filteredNotifications = unreadOnly === 'true' 
        ? allNotifications.filter(n => !n.read)
        : allNotifications;
      
      // Sort by timestamp (newest first)
      filteredNotifications.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      return res.json({ notifications: filteredNotifications });
    }
  } catch (error) {
    console.error('Admin notifications error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Admin endpoint to mark notification as read
app.post('/api/admin/notifications/:notificationId/read', adminAuth, async (req, res) => {
  try {
    const { notificationId } = req.params;
    const { accountId } = req.body;
    
    if (!accountId) {
      return res.status(400).json({ error: 'accountId is required' });
    }
    
    const notificationsPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'admin-notifications.json');
    let notifications = [];
    
    if (fs.existsSync(notificationsPath)) {
      try {
        const data = await fsPromises.readFile(notificationsPath, 'utf8');
        notifications = JSON.parse(data);
      } catch (error) {
        console.error('Error reading admin notifications:', error);
      }
    }
    
    const notification = notifications.find(n => n.id === notificationId);
    if (notification) {
      notification.read = true;
      notification.readAt = new Date().toISOString();
      
      await fsPromises.writeFile(notificationsPath, JSON.stringify(notifications, null, 2), 'utf8');
    }
    
    res.json({ success: true });
  } catch (error) {
    console.error('Mark notification read error:', error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/admin/messages', adminAuth, async (req, res) => {
    try {
        const userIds = await getAllUserIds();
        let allMessages = [];
        
        for (const userId of userIds) {
            const user = await findUserById(userId);
            if (user) {
                const accountId = user.accountId || user.id;
                
                // Get SMS messages from shared-data
                try {
                    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
                    const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
                    if (fs.existsSync(smsMessagesPath)) {
                        const smsMessages = JSON.parse(fs.readFileSync(smsMessagesPath, 'utf8'));
                        const sentSMS = smsMessages.filter(msg => msg.type === 'outbound').map(msg => ({
                            ...msg,
                            type: 'sms',
                            userId: user.id,
                            accountId: accountId
                        }));
                        allMessages = allMessages.concat(sentSMS);
                    }
                } catch (error) {
                    console.error(`Error reading SMS messages for account ${accountId}:`, error);
                }
                
                // Get email messages from shared-data
                try {
                    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
                    const emailMessagesPath = path.join(sharedDataPath, 'email-messages.json');
                    if (fs.existsSync(emailMessagesPath)) {
                        const emailMessages = JSON.parse(fs.readFileSync(emailMessagesPath, 'utf8'));
                        const sentEmails = emailMessages.filter(msg => msg.type === 'outbound').map(msg => ({
                            ...msg,
                            type: 'email',
                            userId: user.id,
                            accountId: accountId
                        }));
                        allMessages = allMessages.concat(sentEmails);
                    }
                } catch (error) {
                    console.error(`Error reading email messages for account ${accountId}:`, error);
                }
            }
        }
        
        allMessages.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        res.json(allMessages.slice(0, 10));
    } catch (error) {
        console.error('Error fetching admin messages:', error);
        res.status(400).json({ error: error.message });
    }
});

// Admin: get senders for an account (email campaign sender settings)
app.get('/api/admin/accounts/:accountId/senders', adminAuth, async (req, res) => {
  try {
    const { accountId } = req.params;
    const sendersPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'senders.json');
    const senderEmailsPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'senderEmails.json');
    let senders = [];
    if (fs.existsSync(sendersPath)) {
      const data = await fsPromises.readFile(sendersPath, 'utf8');
      senders = JSON.parse(data);
    } else if (fs.existsSync(senderEmailsPath)) {
      const data = await fsPromises.readFile(senderEmailsPath, 'utf8');
      senders = JSON.parse(data);
    }
    res.json(senders);
  } catch (error) {
    console.error('Admin get senders error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Admin: add sender for an account
app.post('/api/admin/accounts/:accountId/senders', adminAuth, async (req, res) => {
  try {
    const { accountId } = req.params;
    const { email, fromName } = req.body;
    const normalizedEmail = (email && String(email).trim().toLowerCase()) || '';
    if (!normalizedEmail || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(normalizedEmail)) {
      return res.status(400).json({ error: 'Valid email is required' });
    }
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const sendersPath = path.join(sharedDataPath, 'senders.json');
    await fsPromises.mkdir(sharedDataPath, { recursive: true });
    let senders = [];
    if (fs.existsSync(sendersPath)) {
      const data = await fsPromises.readFile(sendersPath, 'utf8');
      senders = JSON.parse(data);
    }
    if (senders.some(s => (s.EmailAddress || '').toLowerCase() === normalizedEmail)) {
      return res.status(400).json({ error: 'Email already exists for this account' });
    }
    const domain = normalizedEmail.split('@')[1];
    const newSender = {
      id: Date.now().toString() + '-' + Math.floor(Math.random() * 1000000),
      EmailAddress: normalizedEmail,
      FromName: fromName && String(fromName).trim() ? String(fromName).trim() : null,
      Confirmed: false,
      Domain: domain,
      showSteps: false,
      verificationDetails: {
        spfHost: domain,
        spfTextValue: 'v=spf1 a mx include:mail.sw7ft.com ~all',
        dkimHost: `mail._domainkey.${domain}`,
        dkimTextValue: null,
        returnPathDomain: 'mail.sw7ft.com',
        returnPathHost: 'bounces',
        spfVerified: false,
        dkimVerified: false,
        returnPathDomainVerified: false
      },
      createdAt: new Date().toISOString(),
      emailConfirmed: true
    };
    senders.push(newSender);
    await fsPromises.writeFile(sendersPath, JSON.stringify(senders, null, 2));
    res.json(senders);
  } catch (error) {
    console.error('Admin add sender error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Admin: update sender (from name only)
app.put('/api/admin/accounts/:accountId/senders/:senderId', adminAuth, async (req, res) => {
  try {
    const { accountId, senderId } = req.params;
    const { fromName } = req.body || {};
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const sendersPath = path.join(sharedDataPath, 'senders.json');
    if (!fs.existsSync(sendersPath)) return res.status(404).json({ error: 'No senders found' });
    let senders = JSON.parse(await fsPromises.readFile(sendersPath, 'utf8'));
    const idx = senders.findIndex(s => String(s.id) === String(senderId));
    if (idx === -1) return res.status(404).json({ error: 'Sender not found' });
    senders[idx].FromName = fromName && String(fromName).trim() ? String(fromName).trim() : null;
    await fsPromises.writeFile(sendersPath, JSON.stringify(senders, null, 2));
    res.json(senders[idx]);
  } catch (error) {
    console.error('Admin update sender error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Admin: delete sender
app.delete('/api/admin/accounts/:accountId/senders/:senderId', adminAuth, async (req, res) => {
  try {
    const { accountId, senderId } = req.params;
    const sendersPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'senders.json');
    if (!fs.existsSync(sendersPath)) return res.status(404).json({ error: 'No senders found' });
    let senders = JSON.parse(await fsPromises.readFile(sendersPath, 'utf8'));
    senders = senders.filter(s => String(s.id) !== String(senderId));
    await fsPromises.writeFile(sendersPath, JSON.stringify(senders, null, 2));
    res.json(senders);
  } catch (error) {
    console.error('Admin delete sender error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Admin: check DNS verification status for a sender
app.get('/api/admin/accounts/:accountId/senders/:senderId/verify', adminAuth, async (req, res) => {
  try {
    const { accountId, senderId } = req.params;
    const sendersPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'senders.json');
    if (!fs.existsSync(sendersPath)) return res.status(404).json({ error: 'No senders found' });
    const senderEmails = JSON.parse(await fsPromises.readFile(sendersPath, 'utf8'));
    const senderIndex = senderEmails.findIndex(s => s.id === senderId || String(s.id) === String(senderId));
    if (senderIndex === -1) return res.status(404).json({ error: 'Sender not found' });
    const verificationDetails = senderEmails[senderIndex].verificationDetails || {};
    const allVerified = verificationDetails.spfVerified && verificationDetails.dkimVerified && verificationDetails.returnPathDomainVerified;
    const pendingRecords = [
      !verificationDetails.spfVerified ? 'SPF' : null,
      !verificationDetails.dkimVerified ? 'DKIM' : null,
      !verificationDetails.returnPathDomainVerified ? 'Return-Path' : null
    ].filter(Boolean);
    const message = allVerified
      ? 'All DNS records have been verified successfully!'
      : `DNS verification pending for: ${pendingRecords.join(', ')}. Please ensure these records are set up correctly.`;
    res.json({ sender: senderEmails[senderIndex], message });
  } catch (error) {
    console.error('Admin verify sender error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Admin: get sender verification details (DNS values)
app.get('/api/admin/accounts/:accountId/senders/:senderId/details', adminAuth, async (req, res) => {
  try {
    const { accountId, senderId } = req.params;
    const sendersPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'senders.json');
    if (!fs.existsSync(sendersPath)) return res.status(404).json({ error: 'No senders found' });
    const senderEmails = JSON.parse(await fsPromises.readFile(sendersPath, 'utf8'));
    const sender = senderEmails.find(s => s.id === senderId || String(s.id) === String(senderId));
    if (!sender) return res.status(404).json({ error: 'Sender not found' });
    res.json(sender.verificationDetails || {});
  } catch (error) {
    console.error('Admin sender details error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Admin: check email confirmation status
app.get('/api/admin/accounts/:accountId/senders/:senderId/check-email', adminAuth, async (req, res) => {
  try {
    const { accountId, senderId } = req.params;
    const sendersPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'senders.json');
    if (!fs.existsSync(sendersPath)) return res.status(404).json({ error: 'No senders found' });
    const senderEmails = JSON.parse(await fsPromises.readFile(sendersPath, 'utf8'));
    const senderIndex = senderEmails.findIndex(s => s.id === senderId || String(s.id) === String(senderId));
    if (senderIndex === -1) return res.status(404).json({ error: 'Sender not found' });
    const emailConfirmed = senderEmails[senderIndex].emailConfirmed !== false;
    res.json({
      emailConfirmed,
      message: emailConfirmed ? 'Email is confirmed and ready to use!' : 'Email confirmation pending.'
    });
  } catch (error) {
    console.error('Admin check-email sender error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Admin: activate sender (after DNS + email verified)
app.post('/api/admin/accounts/:accountId/senders/:senderId/activate', adminAuth, async (req, res) => {
  try {
    const { accountId, senderId } = req.params;
    const sendersPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'senders.json');
    if (!fs.existsSync(sendersPath)) return res.status(404).json({ error: 'No senders found' });
    const senderEmails = JSON.parse(await fsPromises.readFile(sendersPath, 'utf8'));
    const senderIndex = senderEmails.findIndex(s => s.id === senderId || String(s.id) === String(senderId));
    if (senderIndex === -1) return res.status(404).json({ error: 'Sender not found' });
    const sender = senderEmails[senderIndex];
    const vd = sender.verificationDetails || {};
    if (!sender.emailConfirmed || !vd.spfVerified || !vd.dkimVerified || !vd.returnPathDomainVerified) {
      return res.status(400).json({ error: 'All verifications must be complete before activation' });
    }
    senderEmails[senderIndex].Confirmed = true;
    await fsPromises.writeFile(sendersPath, JSON.stringify(senderEmails, null, 2));
    res.json({ success: true, message: 'Sender activated successfully' });
  } catch (error) {
    console.error('Admin activate sender error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Admin: deactivate sender
app.post('/api/admin/accounts/:accountId/senders/:senderId/deactivate', adminAuth, async (req, res) => {
  try {
    const { accountId, senderId } = req.params;
    const sendersPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'senders.json');
    if (!fs.existsSync(sendersPath)) return res.status(404).json({ error: 'No senders found' });
    const senderEmails = JSON.parse(await fsPromises.readFile(sendersPath, 'utf8'));
    const senderIndex = senderEmails.findIndex(s => s.id === senderId || String(s.id) === String(senderId));
    if (senderIndex === -1) return res.status(404).json({ error: 'Sender not found' });
    senderEmails[senderIndex].Confirmed = false;
    await fsPromises.writeFile(sendersPath, JSON.stringify(senderEmails, null, 2));
    res.json({ success: true, message: 'Sender deactivated successfully' });
  } catch (error) {
    console.error('Admin deactivate sender error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Admin: list phone numbers in current user's pool for assigning to accounts (app owner and admin are the same)
app.get('/api/admin/assignable-phone-numbers', adminAuth, async (req, res) => {
  try {
    const adminId = req.user.id;
    const phoneNumbersPath = path.join(SHARED_DATA_DIR, adminId.toString(), 'phoneNumbers.json');
    let list = [];
    if (fs.existsSync(phoneNumbersPath)) {
      const data = await fsPromises.readFile(phoneNumbersPath, 'utf8');
      list = JSON.parse(data);
    }
    res.json(list);
  } catch (error) {
    console.error('Assignable phone numbers error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Admin phone number management (assign number to account; app owner and admin are the same)
app.post('/api/admin/numbers', adminAuth, async (req, res) => {
    try {
        const { number, userId } = req.body;
        const user = await findUserById(userId);
        if (!user) {
            throw new Error('User not found');
        }
        
        // Add phone number to shared-data
        const accountId = user.accountId || user.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const phoneNumbersPath = path.join(sharedDataPath, 'phoneNumbers.json');
        
        // Ensure shared-data directory exists
        await fsPromises.mkdir(sharedDataPath, { recursive: true });
        
        let phoneNumbers = [];
        if (fs.existsSync(phoneNumbersPath)) {
            const data = await fsPromises.readFile(phoneNumbersPath, 'utf8');
            phoneNumbers = JSON.parse(data);
        }
        
        const newNumber = {
            id: Date.now().toString(),
            number: number,
            purchasedAt: new Date().toISOString(),
            monthlyPrice: 4.00,
            isDefault: phoneNumbers.length === 0
        };
        phoneNumbers.push(newNumber);
        
        await fsPromises.writeFile(phoneNumbersPath, JSON.stringify(phoneNumbers, null, 2), 'utf8');
        res.json(phoneNumbers);
    } catch (error) {
        console.error('Error assigning number:', error);
        res.status(400).json({ error: error.message });
    }
});

// Admin only: purchase phone number from Twilio and add directly to an account (no Paddle)
app.post('/api/admin/numbers/purchase', adminAuth, async (req, res) => {
    try {
        const { phoneNumber, userId } = req.body;
        if (!phoneNumber || !userId) {
            return res.status(400).json({ error: 'phoneNumber and userId are required' });
        }
        const user = await findUserById(userId);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        const purchasedNumber = await twilioClient.incomingPhoneNumbers.create({
            phoneNumber: String(phoneNumber).replace(/\D/g, '').length === 10 ? `+1${String(phoneNumber).replace(/\D/g, '')}` : String(phoneNumber),
            smsUrl: `${BASE_URL}/api/webhooks/sms/${userId}`,
            statusCallback: `${BASE_URL}/api/webhooks/status/${userId}`
        });
        const accountId = user.accountId || user.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, String(accountId));
        const phoneNumbersPath = path.join(sharedDataPath, 'phoneNumbers.json');
        await fsPromises.mkdir(sharedDataPath, { recursive: true });
        let phoneNumbers = [];
        if (fs.existsSync(phoneNumbersPath)) {
            const data = await fsPromises.readFile(phoneNumbersPath, 'utf8');
            phoneNumbers = JSON.parse(data);
        }
        phoneNumbers.push({
            id: purchasedNumber.sid,
            number: purchasedNumber.phoneNumber,
            purchasedAt: new Date().toISOString(),
            monthlyPrice: 4.00,
            isDefault: phoneNumbers.length === 0,
            source: 'admin_purchase'
        });
        await fsPromises.writeFile(phoneNumbersPath, JSON.stringify(phoneNumbers, null, 2), 'utf8');
        if (!user.defaultSendingNumber) {
            user.defaultSendingNumber = purchasedNumber.phoneNumber;
            await writeIndividualUserFile(userId, user);
        }
        res.json({ success: true, number: purchasedNumber.phoneNumber, sid: purchasedNumber.sid });
    } catch (error) {
        console.error('Admin purchase number error:', error);
        res.status(400).json({ error: error.message });
    }
});

app.get('/api/admin/numbers', adminAuth, async (req, res) => {
    try {
        const userIds = await getAllUserIds();
        let allNumbers = [];
        
        for (const userId of userIds) {
            const user = await findUserById(userId);
            if (user) {
                const accountId = user.accountId || user.id;
                const sharedDataPath = path.join(__dirname, 'data', 'shared-data', accountId);
                const phoneNumbersPath = path.join(sharedDataPath, 'phoneNumbers.json');
                
                if (fs.existsSync(phoneNumbersPath)) {
                    try {
                        const data = await fsPromises.readFile(phoneNumbersPath, 'utf8');
                        const phoneNumbers = JSON.parse(data);
                        const userNumbers = phoneNumbers.map(number => ({
                            ...number,
                            userId: user.id,
                            userEmail: user.email,
                            accountId: accountId
                        }));
                        allNumbers = allNumbers.concat(userNumbers);
                    } catch (error) {
                        console.error(`Error reading phone numbers for account ${accountId}:`, error);
                    }
                }
            }
        }
        res.json(allNumbers);
    } catch (error) {
        console.error('Error fetching numbers:', error);
        res.status(400).json({ error: error.message });
    }
});

app.put('/api/admin/numbers/:numberId/assign', adminAuth, async (req, res) => {
    try {
        const { numberId } = req.params;
        const { userId } = req.body;
        const userIds = await getAllUserIds();
        let currentOwnerId = null;
        let numberToAssign = null;
        // Find and remove from current owner
        for (const id of userIds) {
            const user = await findUserById(id);
            if (user) {
                const accountId = user.accountId || user.id;
                const sharedDataPath = path.join(__dirname, 'data', 'shared-data', accountId);
                const phoneNumbersPath = path.join(sharedDataPath, 'phoneNumbers.json');
                
                if (fs.existsSync(phoneNumbersPath)) {
                    try {
                        const data = await fsPromises.readFile(phoneNumbersPath, 'utf8');
                        const phoneNumbers = JSON.parse(data);
                        const idx = phoneNumbers.findIndex(n => n.id === numberId);
                        if (idx !== -1) {
                            numberToAssign = phoneNumbers[idx];
                            phoneNumbers.splice(idx, 1);
                            if (phoneNumbers.length > 0) {
                                phoneNumbers[0].isDefault = true;
                            }
                            await fsPromises.writeFile(phoneNumbersPath, JSON.stringify(phoneNumbers, null, 2), 'utf8');
                            currentOwnerId = id;
                            break;
                        }
                    } catch (error) {
                        console.error(`Error reading phone numbers for account ${accountId}:`, error);
                    }
                }
            }
        }
        if (!numberToAssign) {
            throw new Error('Number not found');
        }
        // Assign to new owner
        if (userId) {
            const newOwner = await findUserById(userId);
            if (!newOwner) {
                throw new Error('New owner not found');
            }
            
            const newAccountId = newOwner.accountId || newOwner.id;
            const newSharedDataPath = path.join(__dirname, 'data', 'shared-data', newAccountId);
            const newPhoneNumbersPath = path.join(newSharedDataPath, 'phoneNumbers.json');
            
            // Ensure shared-data directory exists
            await fsPromises.mkdir(newSharedDataPath, { recursive: true });
            
            let newPhoneNumbers = [];
            if (fs.existsSync(newPhoneNumbersPath)) {
                const data = await fsPromises.readFile(newPhoneNumbersPath, 'utf8');
                newPhoneNumbers = JSON.parse(data);
            }
            
            const isDefault = newPhoneNumbers.length === 0;
            newPhoneNumbers.push({ ...numberToAssign, isDefault });
            
            await fsPromises.writeFile(newPhoneNumbersPath, JSON.stringify(newPhoneNumbers, null, 2), 'utf8');
        }
        res.json({ success: true });
    } catch (error) {
        console.error('Error assigning number:', error);
        res.status(400).json({ error: error.message });
    }
});

app.delete('/api/admin/numbers/:numberId', adminAuth, async (req, res) => {
    try {
        const { numberId } = req.params;
        const userIds = await getAllUserIds();
        let numberFound = false;
        
        for (const userId of userIds) {
            const user = await findUserById(userId);
            if (user) {
                const accountId = user.accountId || user.id;
                const sharedDataPath = path.join(__dirname, 'data', 'shared-data', accountId);
                const phoneNumbersPath = path.join(sharedDataPath, 'phoneNumbers.json');
                
                if (fs.existsSync(phoneNumbersPath)) {
                    try {
                        const data = await fsPromises.readFile(phoneNumbersPath, 'utf8');
                        const phoneNumbers = JSON.parse(data);
                        const idx = phoneNumbers.findIndex(n => n.id === numberId);
                        if (idx !== -1) {
                            phoneNumbers.splice(idx, 1);
                            if (phoneNumbers.length > 0) {
                                phoneNumbers[0].isDefault = true;
                            }
                            await fsPromises.writeFile(phoneNumbersPath, JSON.stringify(phoneNumbers, null, 2), 'utf8');
                            numberFound = true;
                            break;
                        }
                    } catch (error) {
                        console.error(`Error reading phone numbers for account ${accountId}:`, error);
                    }
                }
            }
        }
        
        if (!numberFound) {
            throw new Error('Number not found');
        }
        res.json({ success: true, message: 'Number deleted successfully' });
    } catch (error) {
        console.error('Error deleting number:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add scheduled message processing system

// SMS sending function
const sendSMS = async (message) => {
    try {
        // Get user's default phone number
        const user = await findUserById(message.userId);
        
        // Get phone numbers from shared-data structure
        const accountId = user.accountId || user.id;
        const phoneNumbersPath = path.join(__dirname, 'data', 'shared-data', accountId, 'phoneNumbers.json');
        
        let phoneNumbers = [];
        try {
            const phoneNumbersData = await fsPromises.readFile(phoneNumbersPath, 'utf8');
            phoneNumbers = JSON.parse(phoneNumbersData);
        } catch (error) {
            throw new Error('No phone numbers available for sending SMS');
        }
        
        if (phoneNumbers.length === 0) {
            throw new Error('No phone numbers available for sending SMS');
        }

        const defaultNumber = phoneNumbers.find(n => n.isDefault) || phoneNumbers[0];
        
        // Send SMS to each recipient
        for (const recipient of message.recipients) {
            await twilioClient.messages.create({
                body: message.content,
                from: defaultNumber.number,
                to: recipient.phone
            });
        }

        // Log the sent message
        if (!user.smsMessages) user.smsMessages = { sent: [], received: [] };
        user.smsMessages.sent.push({
            id: Date.now().toString(),
            to: message.recipients.map(r => r.phone),
            body: message.content,
            timestamp: new Date().toISOString(),
            status: 'sent'
        });

        await writeIndividualUserFile(message.userId, user);
    } catch (error) {
        console.error('SMS sending error:', error);
        throw error;
    }
};

// ============================================================================
// EMAIL SAFETY & COMPLIANCE HELPER FUNCTIONS
// ============================================================================

// Suppression List Management
const getSuppressionList = async (accountId) => {
    const suppressionPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'suppression-list.json');
    try {
        if (fs.existsSync(suppressionPath)) {
            const data = await fsPromises.readFile(suppressionPath, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.error('Error reading suppression list:', error);
    }
    return [];
};

const addToSuppressionList = async (accountId, email, reason = 'hard_bounce') => {
    const suppressionPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'suppression-list.json');
    try {
        // Never add emails to suppression list for authentication errors
        if (reason === 'hard_bounce' && email.toLowerCase().includes('@')) {
            // This will be logged below, but we want to be extra careful
            console.log(`[SUPPRESSION] Attempting to add ${email} with reason: ${reason}`);
        }
        
        let suppressionList = await getSuppressionList(accountId);
        
        // Check if already suppressed
        const exists = suppressionList.find(s => s.email.toLowerCase() === email.toLowerCase());
        if (!exists) {
            suppressionList.push({
                email: email.toLowerCase(),
                reason: reason,
                suppressedAt: new Date().toISOString()
            });
            
            await fsPromises.writeFile(suppressionPath, JSON.stringify(suppressionList, null, 2), 'utf8');
            console.log(`[SUPPRESSION] Added ${email} to suppression list with reason: ${reason}`);
        } else {
            console.log(`[SUPPRESSION] Email ${email} already in suppression list`);
        }
    } catch (error) {
        console.error('Error adding to suppression list:', error);
    }
};

const checkSuppressionList = async (accountId, emails) => {
    const suppressionList = await getSuppressionList(accountId);
    const suppressedEmails = new Set(suppressionList.map(s => s.email.toLowerCase()));
    
    const filtered = emails.filter(email => !suppressedEmails.has(email.toLowerCase()));
    const suppressed = emails.filter(email => suppressedEmails.has(email.toLowerCase()));
    
    return { filtered, suppressed };
};

const removeFromSuppressionList = async (accountId, email) => {
    const suppressionPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'suppression-list.json');
    try {
        let suppressionList = await getSuppressionList(accountId);
        const initialLength = suppressionList.length;
        
        // Remove the email (case-insensitive)
        suppressionList = suppressionList.filter(s => s.email.toLowerCase() !== email.toLowerCase());
        
        if (suppressionList.length < initialLength) {
            await fsPromises.writeFile(suppressionPath, JSON.stringify(suppressionList, null, 2), 'utf8');
            return { success: true, message: 'Email removed from suppression list' };
        } else {
            return { success: false, message: 'Email not found in suppression list' };
        }
    } catch (error) {
        console.error('Error removing from suppression list:', error);
        throw error;
    }
};

// Domain Warm-up Management
const getDomainWarmupData = async (accountId, domain) => {
    const warmupPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'domain-warmup.json');
    try {
        let warmupData = {};
        if (fs.existsSync(warmupPath)) {
            const data = await fsPromises.readFile(warmupPath, 'utf8');
            warmupData = JSON.parse(data);
        }
        
        if (!warmupData[domain]) {
            warmupData[domain] = {
                firstSendDate: new Date().toISOString(),
                dailySentCount: {},
                currentDay: 1
            };
        }
        
        return warmupData[domain];
    } catch (error) {
        console.error('Error reading domain warmup data:', error);
        return {
            firstSendDate: new Date().toISOString(),
            dailySentCount: {},
            currentDay: 1
        };
    }
};

const getDomainWarmupLimit = (day) => {
    const limits = {
        1: 1000,   // Increased from 100 to 1000
        2: 2000,   // Increased from 150 to 2000
        3: 3000,   // Increased from 400 to 3000
        4: 5000,   // Increased from 800 to 5000
        5: 7500,   // Increased from 1500 to 7500
        6: 10000,  // Increased from 3000 to 10000
        7: 15000   // Increased from 5000 to 15000
    };
    
    if (day <= 7) {
        return limits[day] || 1000;
    }
    
    // After week 1, allow up to 20,000/day (if healthy)
    return 20000;
};

const checkDomainWarmup = async (accountId, domain, requestedCount) => {
    const warmupData = await getDomainWarmupData(accountId, domain);
    
    // FIX: Calculate calendar days properly by comparing dates at midnight
    // This ensures day 1 -> day 2 transition happens at midnight, not 24 hours after first send
    const firstSendDate = new Date(warmupData.firstSendDate);
    firstSendDate.setHours(0, 0, 0, 0); // Set to midnight
    
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Set to midnight
    
    // Calculate days difference between calendar days (not 24-hour periods)
    const daysSinceFirst = Math.floor((today - firstSendDate) / (1000 * 60 * 60 * 24));
    const currentDay = daysSinceFirst + 1; // Day 1 = first day, Day 2 = second calendar day, etc.
    
    const todayKey = new Date().toISOString().split('T')[0];
    const sentToday = warmupData.dailySentCount[todayKey] || 0;
    const dailyLimit = getDomainWarmupLimit(currentDay);
    
    const available = Math.max(0, dailyLimit - sentToday);
    const canSend = Math.min(requestedCount, available);
    const queued = Math.max(0, requestedCount - available);
    
    return {
        canSend,
        queued,
        dailyLimit,
        sentToday,
        currentDay,
        available
    };
};

const incrementDomainWarmup = async (accountId, domain, count) => {
    const warmupPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'domain-warmup.json');
    try {
        let warmupData = {};
        if (fs.existsSync(warmupPath)) {
            const data = await fsPromises.readFile(warmupPath, 'utf8');
            warmupData = JSON.parse(data);
        }
        
        if (!warmupData[domain]) {
            warmupData[domain] = {
                firstSendDate: new Date().toISOString(),
                dailySentCount: {},
                currentDay: 1
            };
        }
        
        const todayKey = new Date().toISOString().split('T')[0];
        warmupData[domain].dailySentCount[todayKey] = (warmupData[domain].dailySentCount[todayKey] || 0) + count;
        
        // Update current day - use calendar days, not 24-hour periods
        const firstSendDate = new Date(warmupData[domain].firstSendDate);
        firstSendDate.setHours(0, 0, 0, 0); // Set to midnight
        
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Set to midnight
        
        const daysSinceFirst = Math.floor((today - firstSendDate) / (1000 * 60 * 60 * 24));
        const currentDay = daysSinceFirst + 1;
        warmupData[domain].currentDay = Math.max(warmupData[domain].currentDay, currentDay);
        
        await fsPromises.writeFile(warmupPath, JSON.stringify(warmupData, null, 2), 'utf8');
    } catch (error) {
        console.error('Error updating domain warmup:', error);
    }
};

// Extract domain from email address
const extractDomain = (email) => {
    const parts = email.split('@');
    return parts.length === 2 ? parts[1].toLowerCase() : null;
};

// ============================================================================
// EMAIL QUEUE MANAGEMENT
// ============================================================================

// Get email queue for an account
const getEmailQueue = async (accountId) => {
    const queuePath = path.join(SHARED_DATA_DIR, accountId.toString(), 'email-queue.json');
    try {
        if (fs.existsSync(queuePath)) {
            const data = await fsPromises.readFile(queuePath, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.error('[EMAIL-QUEUE] Error reading email queue:', error);
    }
    return [];
};

// Add emails to queue when warm-up limit is reached
const addToEmailQueue = async (accountId, queueEntry) => {
    const queuePath = path.join(SHARED_DATA_DIR, accountId.toString(), 'email-queue.json');
    try {
        let queue = await getEmailQueue(accountId);
        
        // Add queue entry with metadata
        const entry = {
            id: Date.now().toString() + '-' + Math.floor(Math.random() * 1000000),
            accountId: accountId,
            domain: queueEntry.domain,
            recipients: queueEntry.recipients, // Array of email addresses
            subject: queueEntry.subject,
            content: queueEntry.content,
            html: queueEntry.html,
            text: queueEntry.text,
            fromEmail: queueEntry.fromEmail,
            fromName: queueEntry.fromName,
            messageId: queueEntry.messageId,
            userId: queueEntry.userId,
            queuedAt: new Date().toISOString(),
            status: 'pending',
            priority: queueEntry.priority || 'normal' // 'high', 'normal', 'low'
        };
        
        queue.push(entry);
        
        // Sort by priority and queuedAt (high priority first, then oldest first)
        queue.sort((a, b) => {
            const priorityOrder = { high: 3, normal: 2, low: 1 };
            if (priorityOrder[b.priority] !== priorityOrder[a.priority]) {
                return priorityOrder[b.priority] - priorityOrder[a.priority];
            }
            return new Date(a.queuedAt) - new Date(b.queuedAt);
        });
        
        await fsPromises.writeFile(queuePath, JSON.stringify(queue, null, 2), 'utf8');
        console.log(`[EMAIL-QUEUE] Added ${queueEntry.recipients.length} emails to queue for domain ${queueEntry.domain} (queue ID: ${entry.id})`);
        return entry;
    } catch (error) {
        console.error('[EMAIL-QUEUE] Error adding to email queue:', error);
        throw error;
    }
};

// Remove processed entries from queue
const removeFromEmailQueue = async (accountId, queueEntryId) => {
    const queuePath = path.join(SHARED_DATA_DIR, accountId.toString(), 'email-queue.json');
    try {
        let queue = await getEmailQueue(accountId);
        const initialLength = queue.length;
        
        queue = queue.filter(entry => entry.id !== queueEntryId);
        
        if (queue.length < initialLength) {
            await fsPromises.writeFile(queuePath, JSON.stringify(queue, null, 2), 'utf8');
            console.log(`[EMAIL-QUEUE] Removed queue entry ${queueEntryId} from queue`);
            return { success: true, message: 'Queue entry removed' };
        }
        
        return { success: false, message: 'Queue entry not found' };
    } catch (error) {
        console.error('[EMAIL-QUEUE] Error removing from email queue:', error);
        throw error;
    }
};

// Update queue entry status
const updateEmailQueueEntry = async (accountId, queueEntryId, updates) => {
    const queuePath = path.join(SHARED_DATA_DIR, accountId.toString(), 'email-queue.json');
    try {
        let queue = await getEmailQueue(accountId);
        const entryIndex = queue.findIndex(entry => entry.id === queueEntryId);
        
        if (entryIndex === -1) {
            return { success: false, message: 'Queue entry not found' };
        }
        
        queue[entryIndex] = {
            ...queue[entryIndex],
            ...updates,
            updatedAt: new Date().toISOString()
        };
        
        await fsPromises.writeFile(queuePath, JSON.stringify(queue, null, 2), 'utf8');
        return { success: true, entry: queue[entryIndex] };
    } catch (error) {
        console.error('[EMAIL-QUEUE] Error updating queue entry:', error);
        throw error;
    }
};

// Process email queue - send queued emails when capacity is available
const processEmailQueue = async (accountId, domain = null) => {
    try {
        const queue = await getEmailQueue(accountId);
        
        if (queue.length === 0) {
            return { processed: 0, remaining: 0 };
        }
        
        // Filter queue by domain if specified, or get all pending entries
        const pendingEntries = queue.filter(entry => {
            if (entry.status !== 'pending') return false;
            if (domain && entry.domain !== domain) return false;
            return true;
        });
        
        if (pendingEntries.length === 0) {
            return { processed: 0, remaining: queue.filter(e => e.status === 'pending').length };
        }
        
        console.log(`[EMAIL-QUEUE] Found ${pendingEntries.length} pending queue entries for account ${accountId}${domain ? `, domain ${domain}` : ''}`);
        
        let totalProcessed = 0;
        let totalSent = 0;
        
        for (const entry of pendingEntries) {
            try {
                // Check domain warm-up capacity for this domain
                const warmupCheck = await checkDomainWarmup(accountId, entry.domain, entry.recipients.length);
                
                console.log(`[EMAIL-QUEUE] Checking queue entry ${entry.id}: ${entry.recipients.length} recipients, canSend=${warmupCheck.canSend}, sentToday=${warmupCheck.sentToday}/${warmupCheck.dailyLimit}, currentDay=${warmupCheck.currentDay}`);
                
                if (warmupCheck.canSend === 0) {
                    // No capacity available for this domain, skip
                    console.log(`[EMAIL-QUEUE] Skipping queue entry ${entry.id} for domain ${entry.domain}: no capacity (sentToday=${warmupCheck.sentToday}/${warmupCheck.dailyLimit}, available=${warmupCheck.available}). Will retry when capacity becomes available.`);
                    continue;
                }
                
                // Get user for sending
                const user = await findUserById(entry.userId);
                if (!user) {
                    console.error(`[EMAIL-QUEUE] User ${entry.userId} not found for queue entry ${entry.id}`);
                    await updateEmailQueueEntry(accountId, entry.id, { status: 'failed', error: 'User not found' });
                    continue;
                }
                
                // Determine how many we can send
                const recipientsToSend = entry.recipients.slice(0, warmupCheck.canSend);
                const remainingRecipients = entry.recipients.slice(warmupCheck.canSend);
                
                if (recipientsToSend.length === 0) {
                    continue;
                }
                
                // Mark as processing
                await updateEmailQueueEntry(accountId, entry.id, { status: 'processing' });
                
                // Create message object for sending
                const message = {
                    id: entry.messageId || entry.id,
                    userId: entry.userId,
                    recipients: recipientsToSend.map(email => ({ email })),
                    subject: entry.subject,
                    content: entry.content || entry.html,
                    html: entry.html,
                    text: entry.text,
                    fromEmail: entry.fromEmail,
                    fromName: entry.fromName,
                    _processingQueue: true // Flag to prevent recursive queue processing
                };
                
                // Send the emails
                console.log(`[EMAIL-QUEUE] Processing queue entry ${entry.id}: sending ${recipientsToSend.length} emails for domain ${entry.domain}`);
                const sendResult = await sendEmail(message, user);
                
                const successfulSends = sendResult.successfulSends || 0;
                totalSent += successfulSends;
                
                // Deduct tokens for successful sends from queue
                if (successfulSends > 0) {
                    const actualTokenCost = successfulSends;
                    if (user.accountId) {
                        // For team members, deduct from shared account tokens
                        try {
                            await deductAccountTokens(user.accountId, 'emailTokens', actualTokenCost);
                            console.log(`[EMAIL-QUEUE] Deducted ${actualTokenCost} email tokens from account ${user.accountId} for queued emails`);
                        } catch (tokenError) {
                            console.error(`[EMAIL-QUEUE] ERROR: Failed to deduct tokens from account ${user.accountId}:`, tokenError.message);
                        }
                    } else {
                        // For app owners, deduct from individual tokens
                        const beforeTokens = user.emailTokens || 0;
                        user.emailTokens = Math.max(0, beforeTokens - actualTokenCost);
                        await writeIndividualUserFile(user.id, user);
                        console.log(`[EMAIL-QUEUE] Deducted ${actualTokenCost} email tokens from user ${user.id} (${beforeTokens} -> ${user.emailTokens}) for queued emails`);
                    }
                }
                
                // Update campaign analytics in email-campaigns.json
                if (successfulSends > 0 && entry.messageId) {
                    try {
                        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
                        const emailCampaignsPath = path.join(sharedDataPath, 'email-campaigns.json');
                        
                        if (fs.existsSync(emailCampaignsPath)) {
                            const emailCampaigns = JSON.parse(await fsPromises.readFile(emailCampaignsPath, 'utf8'));
                            const campaign = emailCampaigns.find(c => c.id === entry.messageId);
                            
                            if (campaign) {
                                // Update existing campaign with queued email sends
                                campaign.successfulSends = (campaign.successfulSends || 0) + successfulSends;
                                campaign.recipientCount = (campaign.recipientCount || 0) + successfulSends;
                                console.log(`[EMAIL-QUEUE] Updated campaign ${entry.messageId} analytics: +${successfulSends} successful sends`);
                            } else {
                                // Create new campaign entry for queued emails
                                const newCampaign = {
                                    id: entry.messageId,
                                    userId: entry.userId,
                                    type: 'outbound',
                                    templateName: entry.subject || 'Queued Email',
                                    recipientCount: successfulSends,
                                    subject: entry.subject,
                                    fromEmail: entry.fromEmail,
                                    fromName: entry.fromName,
                                    status: 'sent',
                                    timestamp: entry.queuedAt || new Date().toISOString(),
                                    successfulSends: successfulSends,
                                    failedSends: 0,
                                    opens: [],
                                    queued: true // Flag to indicate this was from queue
                                };
                                emailCampaigns.push(newCampaign);
                                console.log(`[EMAIL-QUEUE] Created new campaign entry ${entry.messageId} for queued emails`);
                            }
                            
                            await fsPromises.writeFile(emailCampaignsPath, JSON.stringify(emailCampaigns, null, 2), 'utf8');
                        }
                    } catch (campaignError) {
                        console.error(`[EMAIL-QUEUE] Error updating campaign analytics:`, campaignError.message);
                    }
                }
                
                // Update queue entry
                if (remainingRecipients.length > 0) {
                    // Still have more recipients to send, update entry
                    await updateEmailQueueEntry(accountId, entry.id, {
                        status: 'pending',
                        recipients: remainingRecipients,
                        sentCount: (entry.sentCount || 0) + successfulSends,
                        lastProcessedAt: new Date().toISOString()
                    });
                    console.log(`[EMAIL-QUEUE] Queue entry ${entry.id} partially processed: ${successfulSends} sent, ${remainingRecipients.length} remaining`);
                } else {
                    // All recipients processed
                    await updateEmailQueueEntry(accountId, entry.id, {
                        status: 'completed',
                        sentCount: (entry.sentCount || 0) + successfulSends,
                        completedAt: new Date().toISOString()
                    });
                    console.log(`[EMAIL-QUEUE] Queue entry ${entry.id} completed: ${successfulSends} emails sent`);
                }
                
                totalProcessed++;
                
                // If we've processed some emails, check capacity again before continuing
                // Note: incrementDomainWarmup is called by sendEmail, so we need to check after that
                if (successfulSends > 0) {
                    // Wait a brief moment to ensure warmup counter is updated
                    await new Promise(resolve => setTimeout(resolve, 100));
                    const newWarmupCheck = await checkDomainWarmup(accountId, entry.domain, 1);
                    if (newWarmupCheck.canSend === 0) {
                        // Capacity exhausted, stop processing
                        console.log(`[EMAIL-QUEUE] Capacity exhausted after sending ${successfulSends} emails (sentToday=${newWarmupCheck.sentToday}/${newWarmupCheck.dailyLimit})`);
                        break;
                    }
                }
                
            } catch (error) {
                console.error(`[EMAIL-QUEUE] Error processing queue entry ${entry.id}:`, error.message);
                await updateEmailQueueEntry(accountId, entry.id, {
                    status: 'failed',
                    error: error.message,
                    failedAt: new Date().toISOString()
                });
            }
        }
        
        const remaining = queue.filter(e => e.status === 'pending').length;
        const skipped = pendingEntries.length - totalProcessed;
        if (skipped > 0 || totalProcessed > 0) {
            console.log(`[EMAIL-QUEUE] Queue processing complete: ${totalProcessed} entries processed, ${totalSent} emails sent, ${skipped} entries skipped (no capacity), ${remaining} entries remaining`);
        }
        
        return { processed: totalProcessed, sent: totalSent, remaining, skipped };
    } catch (error) {
        console.error('[EMAIL-QUEUE] Error processing email queue:', error);
        throw error;
    }
};

// Admin Notification System
const addAdminNotification = async (accountId, notification) => {
    const notificationsPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'admin-notifications.json');
    try {
        let notifications = [];
        if (fs.existsSync(notificationsPath)) {
            const data = await fsPromises.readFile(notificationsPath, 'utf8');
            notifications = JSON.parse(data);
        }
        
        notifications.push({
            ...notification,
            id: Date.now().toString(),
            timestamp: new Date().toISOString(),
            read: false
        });
        
        // Keep only last 100 notifications
        if (notifications.length > 100) {
            notifications = notifications.slice(-100);
        }
        
        await fsPromises.writeFile(notificationsPath, JSON.stringify(notifications, null, 2), 'utf8');
    } catch (error) {
        console.error('Error adding admin notification:', error);
    }
};

// Calculate bounce and complaint rates
const calculateEmailRates = (successfulSends, failedSends, complaints = 0) => {
    const total = successfulSends + failedSends;
    if (total === 0) return { bounceRate: 0, complaintRate: 0 };
    
    const bounceRate = (failedSends / total) * 100;
    const complaintRate = (complaints / total) * 100;
    
    return { bounceRate, complaintRate };
};

// ============================================================================
// EMAIL SENDING FUNCTION
// ============================================================================

// Email sending function
const sendEmail = async (message, user) => {
    try {
        console.log('[SEND-EMAIL] Starting sendEmail function');
        const accountId = getEffectiveAccountId(user);
        console.log(`[SEND-EMAIL] Account ID: ${accountId}, User ID: ${user.id}`);
        
        // Get sender emails from appropriate location
        let senderEmails = user.senderEmails || [];
        
        // For team members, get sender emails from shared data structure
        if (user.accountId) {
            const sendersPath = path.join(__dirname, 'data', 'shared-data', user.accountId.toString(), 'senders.json');
            
            if (fs.existsSync(sendersPath)) {
                const data = fs.readFileSync(sendersPath, 'utf8');
                senderEmails = JSON.parse(data);
            } else {
                // Fallback to account holder's user file
                const accountHolder = await findUserById(user.accountId);
                senderEmails = accountHolder?.senderEmails || [];
            }
        }
        
        console.log(`[SEND-EMAIL] Found ${senderEmails.length} sender emails`);
        
        // Campaign emails MUST use user's configured sender emails - no system email fallback
        if (senderEmails.length === 0) {
            throw new Error('No sender emails available for sending email. Please add and verify an email sender in your settings.');
        }

        // Check if user has custom SMTP settings and get the SMTP username
        // (accountId already declared above at line 6885)
        const smtpSettingsPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'smtp-settings.json');
        let smtpUsername = null;
        
        if (fs.existsSync(smtpSettingsPath)) {
            try {
                const smtpData = await fsPromises.readFile(smtpSettingsPath, 'utf8');
                const smtpSettings = JSON.parse(smtpData);
                smtpUsername = smtpSettings.user ? smtpSettings.user.trim().toLowerCase() : null;
            } catch (error) {
                console.error('[SEND-EMAIL] Error reading SMTP settings:', error);
            }
        }

        // If SMTP username is an email address, it must match the sender email
        // Some SMTP servers only allow sending from the authenticated username
        let senderEmail;
        if (smtpUsername && isValidEmail(smtpUsername)) {
            // SMTP username is an email - must use it as sender
            senderEmail = senderEmails.find(s => s.EmailAddress.toLowerCase() === smtpUsername);
            
            if (!senderEmail) {
                // Try to find any sender that matches, or create a warning
                console.warn(`[SEND-EMAIL] SMTP username (${smtpUsername}) doesn't match any verified sender. Attempting to use it anyway.`);
                // Create a temporary sender object for this send
                senderEmail = {
                    EmailAddress: smtpUsername,
                    Confirmed: true,
                    Domain: smtpUsername.split('@')[1]
                };
            } else {
                console.log(`[SEND-EMAIL] SMTP username matches sender: ${senderEmail.EmailAddress}`);
            }
        } else {
            // No SMTP username restriction - use the fromEmail from the message if provided, otherwise fall back to first confirmed sender
            senderEmail = message.fromEmail 
                ? senderEmails.find(s => s.EmailAddress === message.fromEmail)
                : senderEmails.find(s => s.Confirmed) || senderEmails[0];
        }
        
        if (!senderEmail) {
            throw new Error(`Sender email ${message.fromEmail || smtpUsername} not found or not confirmed. Please ensure your sender email matches your SMTP username (${smtpUsername || 'N/A'}).`);
        }
        
        console.log(`[SEND-EMAIL] Using sender email: ${senderEmail.EmailAddress}, Confirmed: ${senderEmail.Confirmed}`);
        
        // Use provided messageId if available, otherwise generate a new one
        const messageId = message.messageId || (Date.now().toString() + '-' + Math.floor(Math.random() * 1000000));
        console.log(`[SEND-EMAIL] Using messageId: ${messageId}`);

        // Handle different message formats (invitation vs campaign)
        let normalizedMessage;
        if (message.to && message.html) {
            // Invitation format: {to: email, subject: "...", html: "..."}
            normalizedMessage = {
                recipients: [{ email: message.to }],
                content: message.html,
                subject: message.subject || "Message from Campaign Builder",
                fromEmail: message.fromEmail,
                userId: user.id
            };
        } else if (message.recipients) {
            // Campaign format: {recipients: [...], content: "..."}
            normalizedMessage = message;
        } else {
            throw new Error('Invalid message format: must have either "to" or "recipients"');
        }

        // Check suppression list before sending (accountId already declared above)
        console.log(`[SEND-EMAIL] Checking suppression list for ${normalizedMessage.recipients.length} recipients`);
        const recipientEmails = normalizedMessage.recipients.map(r => r.email);
        const { filtered: nonSuppressedEmails, suppressed: suppressedEmails } = await checkSuppressionList(accountId, recipientEmails);
        
        console.log(`[SEND-EMAIL] Suppression check: ${nonSuppressedEmails.length} allowed, ${suppressedEmails.length} suppressed`);
        if (suppressedEmails.length > 0) {
            console.log(`[SEND-EMAIL] Suppressed emails (will not be sent):`, suppressedEmails);
        }
        
        // Update recipients to only include non-suppressed emails
        normalizedMessage.recipients = normalizedMessage.recipients.filter(r => 
            nonSuppressedEmails.includes(r.email.toLowerCase())
        );
        
        console.log(`[SEND-EMAIL] After suppression filter: ${normalizedMessage.recipients.length} recipients remaining`);
        
        // Check domain warm-up limits
        const sendingDomain = extractDomain(senderEmail.EmailAddress);
        console.log(`[SEND-EMAIL] Sending domain: ${sendingDomain}`);
        if (sendingDomain && normalizedMessage.recipients.length > 0) {
            const warmupCheck = await checkDomainWarmup(accountId, sendingDomain, normalizedMessage.recipients.length);
            console.log(`[SEND-EMAIL] Warm-up check: canSend=${warmupCheck.canSend}, sentToday=${warmupCheck.sentToday}, dailyLimit=${warmupCheck.dailyLimit}, queued=${warmupCheck.queued}`);
            
            if (warmupCheck.queued > 0) {
                // Queue excess emails for later sending
                const beforeWarmup = normalizedMessage.recipients.length;
                const recipientsToSend = normalizedMessage.recipients.slice(0, warmupCheck.canSend);
                const recipientsToQueue = normalizedMessage.recipients.slice(warmupCheck.canSend);
                
                // Check suppression list before queuing to prevent queuing unsubscribed emails
                const recipientsToQueueEmails = recipientsToQueue.map(r => r.email);
                const { filtered: nonSuppressedToQueue, suppressed: suppressedToQueue } = await checkSuppressionList(accountId, recipientsToQueueEmails);
                
                if (suppressedToQueue.length > 0) {
                    console.log(`[SEND-EMAIL] Filtered out ${suppressedToQueue.length} suppressed/unsubscribed emails from queue (will not be queued)`);
                }
                
                // Update recipients to only include those we can send now
                normalizedMessage.recipients = recipientsToSend;
                
                // Add excess recipients to queue (only non-suppressed ones)
                if (nonSuppressedToQueue.length > 0) {
                    try {
                        await addToEmailQueue(accountId, {
                            domain: sendingDomain,
                            recipients: nonSuppressedToQueue,
                            subject: normalizedMessage.subject || "Message from Campaign Builder",
                            content: normalizedMessage.content,
                            html: normalizedMessage.html,
                            text: normalizedMessage.text,
                            fromEmail: senderEmail.EmailAddress,
                            fromName: normalizedMessage.fromName || null,
                            messageId: messageId,
                            userId: normalizedMessage.userId || user.id,
                            priority: 'normal'
                        });
                        console.log(`[SEND-EMAIL] Queued ${nonSuppressedToQueue.length} emails for later sending (domain warm-up limit reached, ${suppressedToQueue.length} suppressed emails excluded)`);
                    } catch (queueError) {
                        console.error(`[SEND-EMAIL] Failed to queue emails:`, queueError.message);
                        // Continue with sending what we can
                    }
                } else if (recipientsToQueue.length > 0) {
                    console.log(`[SEND-EMAIL] All ${recipientsToQueue.length} recipients to queue were suppressed/unsubscribed - nothing queued`);
                }
                
                console.log(`[SEND-EMAIL] After warm-up filter: ${normalizedMessage.recipients.length} recipients (was ${beforeWarmup}, ${recipientsToQueue.length} queued)`);
            }
        }
        
        // Send email to each recipient
        console.log(`[SEND-EMAIL] Preparing to send to ${normalizedMessage.recipients.length} recipients`);
        let successfulSends = 0;
        let failedSends = 0;
        let failedRecipients = [];
        let hardBounces = 0;
        let complaints = 0;
        let campaignPaused = false;
        let pauseReason = '';
        let consecutiveMailFromFailures = 0; // Track consecutive MAIL FROM failures (sender-side issues)
        
        // Safe batch sending configuration
        // For small sends (<=10 recipients): Use 1 connection to avoid overwhelming SMTP server
        // For medium sends (11-100): Use 2 connections
        // For large sends (>100): Use 3 connections
        // Batch size: Smaller batches for small sends, larger for bulk
        const totalRecipients = normalizedMessage.recipients.length;
        const batchSize = totalRecipients <= 10 ? totalRecipients : Math.min(225, totalRecipients);
        const maxConcurrency = totalRecipients <= 10 ? 1 : (totalRecipients <= 100 ? 2 : 3);
        const delayBetweenBatches = totalRecipients <= 10 ? 2000 : 6000; // 2s for small sends, 6s for large
        
        try {
            // Send emails with retry logic
            const maxRetries = 3;
            const retryDelay = 1000; // 1 second base delay
            
            // Helper function to send a single email
            const sendSingleEmail = async (recipient, index) => {
                const pixelUrl = `${BASE_URL}/api/email/open/${messageId}.png?u=${encodeURIComponent(normalizedMessage.userId)}&r=${encodeURIComponent(recipient.email)}`;
                
                // Add unsubscribe footer to email content
                const unsubscribeUrl = `${BASE_URL}/unsubscribe?email=${encodeURIComponent(recipient.email)}&type=email`;
                const unsubscribeEmail = process.env.UNSUBSCRIBE_EMAIL || process.env.SYSTEM_EMAIL || senderEmail.EmailAddress;
                const businessAddress = process.env.BUSINESS_ADDRESS || '';
                
                // Build unsubscribe footer with physical address if available
                let addressFooter = '';
                if (businessAddress) {
                    addressFooter = `<p style="margin: 10px 0; font-size: 11px;">${businessAddress}</p>`;
                }
                
                const unsubscribeFooter = `
                    <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 12px;">
                        <p style="margin: 10px 0;">You're receiving this email because you subscribed to our mailing list.</p>
                        <p style="margin: 10px 0;">
                            <a href="${unsubscribeUrl}" style="color: #6b7280; text-decoration: underline;">Unsubscribe from emails</a>
                        </p>
                        ${addressFooter}
                    </div>
                `;
                
                const recipientHtmlBody = `${normalizedMessage.content}<img src="${pixelUrl}" width="1" height="1" style="display:none;">${unsubscribeFooter}`;
                
                // Add unsubscribe link to text version
                let textUnsubscribe = `\n\n---\nUnsubscribe from emails: ${unsubscribeUrl}`;
                if (businessAddress) {
                    textUnsubscribe += `\n\n${businessAddress}`;
                }
                const recipientTextBody = normalizedMessage.content.replace(/<[^>]*>/g, '') + textUnsubscribe;
                
                let retryCount = 0;
                let emailSent = false;
                
                // Retry logic for individual emails
                while (retryCount <= maxRetries && !emailSent) {
                    try {
                        // Build List-Unsubscribe headers for compliance
                        const listUnsubscribeUrl = unsubscribeUrl;
                        const listUnsubscribeMailto = `mailto:${unsubscribeEmail}?subject=Unsubscribe`;
                        
                        // Build email headers for better deliverability
                        const emailHeaders = {
                            'List-Unsubscribe': `<${listUnsubscribeUrl}>, <${listUnsubscribeMailto}>`,
                            'List-Unsubscribe-Post': 'List-Unsubscribe=One-Click',
                            'X-Mailer': 'Campaign Builder',
                            'X-Campaign-ID': messageId,
                            'Message-ID': `<${messageId}@${senderEmail.Domain || 'campaignbuilder.ca'}>`
                        };
                        
                        // Add Reply-To header if fromName is provided
                        if (normalizedMessage.fromName) {
                            emailHeaders['Reply-To'] = senderEmail.EmailAddress;
                        }
                        
                        const mailOptions = {
                            from: normalizedMessage.fromName 
                                ? `${normalizedMessage.fromName} <${senderEmail.EmailAddress}>`
                                : senderEmail.EmailAddress,
                            to: recipient.email,
                            subject: normalizedMessage.subject || "Message from Campaign Builder",
                            html: recipientHtmlBody,
                            text: recipientTextBody,
                            headers: emailHeaders
                        };
                        
                        // Log email attempt (without sensitive data)
                        const accountId = getEffectiveAccountId(user);
                        console.log(`[EMAIL] Sending email to ${recipient.email} from ${mailOptions.from} using account ${accountId}`);
                        
                        // Campaign emails must use user's custom SMTP transporter
                        // System email is only for 2FA and team invitations, not campaigns
                        let isUserSpecific = false;
                        let userTransporter = null;
                        
                        // Always get custom SMTP transporter for campaign emails
                        userTransporter = await getUserSMTPTransporter(user);
                        isUserSpecific = userTransporterCache.has(accountId);
                        
                        if (!isUserSpecific) {
                            // If no custom SMTP, try global transporters but keep user's sender email
                            console.log(`[EMAIL] No custom SMTP configured, using global transporters with user's sender email`);
                        }
                        
                        // Use the user's selected sender email - don't override it
                        // Most SMTP servers allow sending from any address if authenticated
                        // The sender email should match the verified sender in sender settings
                        console.log(`[EMAIL] Using sender email: ${senderEmail.EmailAddress} (user-selected sender)`);
                        
                        let result;
                        let viaServer = null;
                        
                        try {
                            if (isUserSpecific && userTransporter) {
                                // User has custom SMTP, use it directly
                                result = await userTransporter.sendMail(mailOptions);
                                viaServer = 'user-custom-smtp';
                            } else {
                                // No custom SMTP - use global transporters but keep user's sender email
                                // This allows sending with user's verified sender even without custom SMTP
                                const sendResult = await sendWithGlobalTransporters(mailOptions, user);
                                result = sendResult.result;
                                viaServer = sendResult.via;
                            }
                            
                            console.log(`[EMAIL] Email sent successfully to ${recipient.email}, messageId: ${result.messageId || 'N/A'}, via: ${viaServer || 'unknown'}`);
                            return { success: true, email: recipient.email, isBounce: false };
                        } catch (userSmtpError) {
                            // Log detailed error for debugging
                            console.error(`[EMAIL] SMTP send error for ${recipient.email}:`, {
                                code: userSmtpError.code,
                                command: userSmtpError.command,
                                response: userSmtpError.response,
                                responseCode: userSmtpError.responseCode,
                                message: userSmtpError.message?.substring(0, 200)
                            });
                            
                            // CRITICAL: Check if this is a MAIL FROM error (sender-side issue, not recipient issue)
                            const isMailFromError = userSmtpError.command === 'MAIL FROM';
                            if (isMailFromError) {
                                console.error(`[EMAIL] âš ï¸  MAIL FROM error detected - this is a SENDER-SIDE issue, not a recipient issue!`);
                                console.error(`[EMAIL] Your SMTP server (${userSmtpError.response}) is rejecting the sender, not the recipient.`);
                                // Add a property to track this is a MAIL FROM error
                                userSmtpError.isMailFromError = true;
                            }
                            
                            // If user-specific SMTP fails, try global transporters as fallback
                            if (isUserSpecific) {
                                const isConnectionError = 
                                    userSmtpError.code === 'ECONNREFUSED' ||
                                    userSmtpError.code === 'ETIMEDOUT' ||
                                    userSmtpError.code === 'ENOTFOUND' ||
                                    userSmtpError.code === 'ECONNRESET' ||
                                    userSmtpError.message?.includes('timeout') ||
                                    userSmtpError.message?.includes('connection') ||
                                    userSmtpError.message?.includes('blacklist') ||
                                    userSmtpError.message?.includes('blocked');
                                
                                const isAuthError = 
                                    userSmtpError.code === 'EAUTH' ||
                                    userSmtpError.message?.includes('authentication') ||
                                    userSmtpError.message?.includes('Invalid login') ||
                                    userSmtpError.message?.includes('535') ||
                                    userSmtpError.message?.includes('authentication failed') ||
                                    userSmtpError.message?.includes('Auth failed');
                                
                                if (isAuthError) {
                                    console.error(`[EMAIL] SMTP authentication failed. Check that SMTP username matches sender email (${senderEmail.EmailAddress}) and password is correct.`);
                                    // Clear the cache so it reloads credentials on next attempt (credentials may have been updated)
                                    console.log(`[EMAIL] Clearing SMTP cache for account ${accountId} due to authentication error - will reload credentials on next attempt`);
                                    clearUserSMTPCache(accountId);
                                }
                                
                                const isSenderRejectedError = 
                                    userSmtpError.message?.includes('Sender address rejected') ||
                                    userSmtpError.message?.includes('not owned by user') ||
                                    userSmtpError.message?.includes('553 5.7.1');
                                
                                // Campaign emails should NOT fall back to system email
                                // If user SMTP fails, the email should fail - don't use system email fallback
                                // System email is only for 2FA and team invitations
                                console.error(`[EMAIL] User SMTP failed - campaign emails must use user's configured sender. Error: ${userSmtpError.message}`);
                                throw userSmtpError;
                            }
                            // Re-throw if not a connection/auth error or no global fallback available
                            throw userSmtpError;
                        }
                    } catch (error) {
                        retryCount++;
                        
                        // Log error details (without sensitive data - don't expose passwords, usernames, etc.)
                        const accountId = getEffectiveAccountId(user);
                        const safeErrorMessage = error.message ? error.message.replace(/password|pass|auth|credential|user|username/gi, '[REDACTED]') : 'Unknown error';
                        console.error(`[EMAIL] Send failed for ${recipient.email} (account ${accountId}, attempt ${retryCount}/${maxRetries + 1}):`, safeErrorMessage);
                        
                        // Check if error is an authentication/configuration error (NOT a bounce)
                        const isAuthError = error.message && (
                            error.message.includes('Invalid login') ||
                            error.message.includes('authentication') ||
                            error.message.includes('EAUTH') ||
                            error.message.includes('535') ||
                            error.message.includes('Auth failed') ||
                            error.code === 'EAUTH'
                        );
                        
                        // CRITICAL: Check if this is a MAIL FROM error (sender-side issue)
                        // "Mail command failed" indicates the error occurred during MAIL FROM command (sender-side)
                        // "452 4.3.1 Insufficient system storage" during MAIL FROM = sender's SMTP server storage full
                        const isMailFromError = error.isMailFromError === true || 
                                                error.command === 'MAIL FROM' ||
                                                (error.message && (
                                                    error.message.includes('Mail command failed') ||
                                                    (error.message.includes('452 4.3.1') && error.message.includes('Insufficient system storage'))
                                                ));
                        
                        // Check if error is a temporary recipient error (should not stop batch processing)
                        // 452 = Insufficient system storage (recipient's mailbox/server is full - temporary)
                        // 421 = Service not available (temporary)
                        // BUT: If it's a MAIL FROM error, it's NOT a recipient error - it's a sender error
                        // NOTE: "452 4.3.1" during MAIL FROM is a sender issue, not recipient
                        const isTemporaryRecipientError = !isMailFromError && error.message && (
                            (error.message.includes('452') && !error.message.includes('Mail command failed')) || // Insufficient system storage (recipient side ONLY if not MAIL FROM)
                            error.message.includes('421') || // Service not available
                            (error.message.includes('4.3.1') && error.message.includes('Insufficient') && !error.message.includes('Mail command failed')) // More specific 452 error (recipient side)
                        );
                        
                        // Check if error indicates hard bounce (actual permanent delivery failure)
                        // Exclude authentication errors - those are SMTP config issues, not recipient problems
                        // Exclude temporary errors (4xx codes like 452) - those are temporary, not permanent failures
                        // Exclude MAIL FROM errors - those are sender-side issues, not recipient bounces
                        const isHardBounce = !isAuthError && !isTemporaryRecipientError && !isMailFromError && error.message && (
                            (error.message.includes('550') && !error.message.includes('535')) || // Mailbox unavailable (but not auth error 535)
                            error.message.includes('551') || // User not local
                            error.message.includes('552') || // Exceeded storage allocation (permanent)
                            (error.message.includes('553') && !error.message.includes('5.7.1')) || // Mailbox name not allowed (but not sender rejection)
                            (error.message.includes('permanent') && !error.message.includes('authentication')) ||
                            (error.message.includes('does not exist') && !error.message.includes('authentication')) ||
                            (error.message.includes('bounce') && !error.message.includes('authentication'))
                        );
                        
                        if (retryCount <= maxRetries) {
                            // Exponential backoff
                            const delay = retryDelay * Math.pow(2, retryCount - 1);
                            console.log(`[EMAIL] Retrying in ${delay}ms...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else {
                            const safeFinalError = error.message ? error.message.replace(/password|pass|auth|credential|user|username/gi, '[REDACTED]') : 'Unknown error';
                            
                            // Log different error types with appropriate messages
                            if (isMailFromError) {
                                console.error(`[EMAIL] âš ï¸  CRITICAL: Email ${index + 1}/${totalRecipients} to ${recipient.email} failed: ${safeFinalError}`);
                                console.error(`[EMAIL] This is a SENDER-SIDE SMTP error (MAIL FROM), not a recipient error!`);
                                console.error(`[EMAIL] Your SMTP server or account may have reached a quota, or the server has storage issues.`);
                            } else if (isTemporaryRecipientError) {
                                console.error(`[EMAIL] Email ${index + 1}/${totalRecipients} to ${recipient.email} failed: ${safeFinalError} (Temporary recipient error - recipient's mailbox/server is full. Will continue processing other emails.)`);
                            } else if (isHardBounce) {
                                console.error(`[EMAIL] Email ${index + 1}/${totalRecipients} to ${recipient.email} failed after ${maxRetries} retries: ${safeFinalError} (Hard bounce - permanent failure)`);
                            } else {
                                console.error(`[EMAIL] Email ${index + 1}/${totalRecipients} to ${recipient.email} failed after ${maxRetries} retries: ${safeFinalError}`);
                            }
                            
                            // Add to suppression list if hard bounce (not for temporary errors or MAIL FROM errors)
                            if (isHardBounce) {
                                await addToSuppressionList(accountId, recipient.email, 'hard_bounce');
                            }
                            
                            return { 
                                success: false, 
                                email: recipient.email, 
                                error: safeFinalError,
                                isBounce: isHardBounce,
                                isMailFromError: isMailFromError
                            };
                        }
                    }
                }
            };
            
            // Safe batch sending: 100-150 per batch, 8-12s delays, 1-3 concurrent
            const batches = [];
            for (let i = 0; i < normalizedMessage.recipients.length; i += batchSize) {
                batches.push(normalizedMessage.recipients.slice(i, i + batchSize));
            }
            
            for (let batchIndex = 0; batchIndex < batches.length && !campaignPaused; batchIndex++) {
                const batch = batches[batchIndex];
                
                // Process batch with controlled concurrency (1-3 connections)
                const concurrencyBatches = [];
                for (let j = 0; j < batch.length; j += maxConcurrency) {
                    concurrencyBatches.push(batch.slice(j, j + maxConcurrency));
                }
                
                for (const concurrencyBatch of concurrencyBatches) {
                    const batchPromises = concurrencyBatch.map((recipient, batchPos) => 
                        sendSingleEmail(recipient, batchIndex * batchSize + batchPos)
                    );
                    
                    const batchResults = await Promise.all(batchPromises);
                    
                    batchResults.forEach((result, idx) => {
                        if (result.success) {
                            successfulSends++;
                            consecutiveMailFromFailures = 0; // Reset counter on success
                            console.log(`[SEND-EMAIL] âœ… Success #${successfulSends}: ${result.email ? result.email.split('@')[0] + '@[REDACTED]' : 'unknown'}`);
                        } else {
                            failedSends++;
                            if (result.isBounce) {
                                hardBounces++;
                            }
                            
                            // Track consecutive MAIL FROM errors (sender-side issues)
                            if (result.isMailFromError) {
                                consecutiveMailFromFailures++;
                                console.error(`[SEND-EMAIL] âš ï¸  MAIL FROM failure count: ${consecutiveMailFromFailures} consecutive`);
                            } else {
                                consecutiveMailFromFailures = 0; // Reset if it's a different type of error
                            }
                            
                            const safeEmail = result.email ? result.email.split('@')[0] + '@[REDACTED]' : '[REDACTED]';
                            const safeError = result.error ? result.error.replace(/password|pass|auth|credential|user|username|@.*\./gi, '[REDACTED]') : 'Unknown error';
                            console.log(`[SEND-EMAIL] âŒ Failed #${failedSends}: ${safeEmail} - ${safeError}`);
                            failedRecipients.push({
                                email: result.email,
                                error: result.error,
                                isBounce: result.isBounce || false,
                                isMailFromError: result.isMailFromError || false
                            });
                        }
                    });
                    
                    // CRITICAL: Check if we have too many consecutive MAIL FROM failures
                    // This indicates a server-wide sender problem, not individual recipient issues
                    if (consecutiveMailFromFailures >= 5) {
                        campaignPaused = true;
                        pauseReason = `Campaign stopped: ${consecutiveMailFromFailures} consecutive MAIL FROM errors detected. This indicates your SMTP server/account has a problem (quota reached, storage full, or rate limiting). Please check your SMTP provider settings and account status.`;
                        
                        console.error(`[SEND-EMAIL] ðŸ›‘ STOPPING CAMPAIGN: ${consecutiveMailFromFailures} consecutive MAIL FROM failures`);
                        console.error(`[SEND-EMAIL] This is a SENDER-SIDE issue with your SMTP server, not recipient issues.`);
                        console.error(`[SEND-EMAIL] Possible causes:`);
                        console.error(`[SEND-EMAIL]   1. SMTP account has reached sending quota/limit`);
                        console.error(`[SEND-EMAIL]   2. SMTP provider's server has storage issues`);
                        console.error(`[SEND-EMAIL]   3. SMTP provider is rate-limiting your account`);
                        console.error(`[SEND-EMAIL] Please contact your SMTP provider or check your account limits.`);
                        
                        // Notify admin
                        await addAdminNotification(accountId, {
                            type: 'smtp_server_error',
                            severity: 'critical',
                            message: pauseReason,
                            campaignId: messageId,
                            consecutiveMailFromFailures,
                            successfulSends,
                            failedSends
                        });
                        
                        break; // Exit the concurrency batch loop
                    }
                    
                    // Log batch summary
                    console.log(`[SEND-EMAIL] Batch ${batchIndex + 1} complete: ${batchResults.filter(r => r.success).length} successful, ${batchResults.filter(r => !r.success).length} failed`);
                    console.log(`[SEND-EMAIL] Total so far: ${successfulSends} successful, ${failedSends} failed (${hardBounces} hard bounces) out of ${normalizedMessage.recipients.length} total recipients`);
                    
                    // Check bounce/complaint rates after each concurrency batch
                    // IMPORTANT: Use hardBounces (permanent failures) for bounce rate, not all failed sends
                    // Temporary errors (452 - mailbox full, etc.) should NOT count as bounces
                    const { bounceRate, complaintRate } = calculateEmailRates(successfulSends, hardBounces, complaints);
                    
                    console.log(`[SEND-EMAIL] Current rates: Bounce rate: ${bounceRate.toFixed(2)}% (${hardBounces} hard bounces), Complaint rate: ${complaintRate.toFixed(2)}%`);
                    
                    if (bounceRate > 5 || complaintRate > 5) {
                        campaignPaused = true;
                        pauseReason = bounceRate > 5 
                            ? `Bounce rate ${bounceRate.toFixed(2)}% exceeds 5% threshold (${hardBounces} hard bounces out of ${successfulSends + hardBounces} processed)`
                            : `Complaint rate ${complaintRate.toFixed(2)}% exceeds 5% threshold`;
                        
                        // Notify admin
                        await addAdminNotification(accountId, {
                            type: 'campaign_paused',
                            severity: 'high',
                            message: pauseReason,
                            campaignId: messageId,
                            bounceRate: bounceRate.toFixed(2),
                            complaintRate: complaintRate.toFixed(2),
                            successfulSends,
                            failedSends,
                            hardBounces
                        });
                        
                        console.error(`[SEND-EMAIL] CAMPAIGN PAUSED: ${pauseReason}`);
                        break;
                    }
                }
                
                // Delay between batches (8-12 seconds)
                if (batchIndex < batches.length - 1 && !campaignPaused) {
                    await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
                }
            }
            
            // If campaign was paused, add remaining recipients to failed list
            if (campaignPaused) {
                const processedCount = successfulSends + failedSends;
                const remainingBatches = batches.slice(
                    Math.floor(processedCount / batchSize) + (processedCount % batchSize > 0 ? 1 : 0)
                );
                remainingBatches.forEach(batch => {
                    batch.forEach(recipient => {
                        failedSends++;
                        failedRecipients.push({
                            email: recipient.email,
                            error: pauseReason || 'Campaign paused due to SMTP server issues or high bounce/complaint rate',
                            isBounce: false,
                            isMailFromError: pauseReason && pauseReason.includes('MAIL FROM')
                        });
                    });
                });
            }

        if (failedRecipients.length > 0) {

        }
        
        // Final validation: Ensure our counts make sense
        const totalProcessed = successfulSends + failedSends;
        console.log(`[SEND-EMAIL] Final count validation:`);
        console.log(`[SEND-EMAIL]   Total processed: ${totalProcessed}`);
        console.log(`[SEND-EMAIL]   Expected recipients: ${normalizedMessage.recipients.length}`);
        console.log(`[SEND-EMAIL]   Successful: ${successfulSends}`);
        console.log(`[SEND-EMAIL]   Failed: ${failedSends}`);
        
        if (totalProcessed !== normalizedMessage.recipients.length) {
            console.error(`[SEND-EMAIL] âš ï¸  COUNT MISMATCH: Processed ${totalProcessed} emails but expected ${normalizedMessage.recipients.length} recipients`);
            console.error('[SEND-EMAIL] This may indicate batch processing stopped early. Continuing with processed results.');
            // Don't reset counts - use what we actually processed
            // The remaining unprocessed emails will be handled by the caller if needed
        } else {
            console.log(`[SEND-EMAIL] âœ… Count validation passed: All ${totalProcessed} recipients processed`);
        }
        } catch (sendError) {
            console.error('[SEND-EMAIL] Exception in sendEmail function:', sendError.message);
            console.error('[SEND-EMAIL] Stack trace:', sendError.stack?.split('\n').slice(0, 5).join('\n'));
            
            // Don't mark all emails as failed - only mark those that weren't processed
            // If we already processed some emails successfully, preserve those results
            const totalProcessed = successfulSends + failedSends;
            const unprocessedCount = normalizedMessage.recipients.length - totalProcessed;
            
            if (unprocessedCount > 0) {
                console.error(`[SEND-EMAIL] Exception occurred after processing ${totalProcessed} emails. ${unprocessedCount} emails were not processed.`);
                console.error('[SEND-EMAIL] Marking unprocessed emails as failed, but preserving successful sends.');
                
                // Create a set of processed emails (from failedRecipients)
                const processedEmails = new Set(failedRecipients.map(r => r.email.toLowerCase()));
                
                // Mark only unprocessed recipients as failed
                normalizedMessage.recipients.forEach(recipient => {
                    if (!processedEmails.has(recipient.email.toLowerCase())) {
                        failedSends++;
                        failedRecipients.push({
                            email: recipient.email,
                            error: `Processing stopped: ${sendError.message || 'Unknown error'}`,
                            isBounce: false
                        });
                    }
                });
            } else {
                // All emails were already processed, just log the error
                console.error('[SEND-EMAIL] Exception occurred but all emails were already processed.');
            }
        }

        // Calculate final bounce and complaint rates
        // Use hardBounces (permanent failures) for bounce rate, not all failed sends
        const { bounceRate, complaintRate } = calculateEmailRates(successfulSends, hardBounces, complaints);
        console.log(`[SEND-EMAIL] Final rates: Bounce rate: ${bounceRate.toFixed(2)}% (${hardBounces} hard bounces), Complaint rate: ${complaintRate.toFixed(2)}%`);
        
        // Update domain warm-up count if sending was successful
        if (sendingDomain && successfulSends > 0) {
            await incrementDomainWarmup(accountId, sendingDomain, successfulSends);
            
            // After successful sends, try to process queued emails if capacity is available
            // Only process if not already processing (to prevent recursion)
            // AND only process for larger campaigns (>10 emails) to avoid overwhelming SMTP server on single sends
            if (!normalizedMessage._processingQueue && !normalizedMessage._skipQueueProcessing && totalRecipients > 10) {
                try {
                    const queueResult = await processEmailQueue(accountId, sendingDomain);
                    if (queueResult.processed > 0) {
                        console.log(`[SEND-EMAIL] Processed ${queueResult.processed} queued email entries, sent ${queueResult.sent} emails`);
                    }
                } catch (queueError) {
                    // Don't fail the main send if queue processing fails
                    console.error('[SEND-EMAIL] Error processing email queue after send:', queueError.message);
                }
            } else if (totalRecipients <= 10) {
                console.log(`[SEND-EMAIL] Skipping automatic queue processing for small send (${totalRecipients} recipients) to avoid SMTP overload`);
            }
        }
        
        // Log the sent message with messageId for tracking
        const messageRecord = {
            id: messageId,
            to: normalizedMessage.recipients.map(r => r.email),
            subject: normalizedMessage.subject || "Message from Campaign Builder",
            body: normalizedMessage.content,
            timestamp: new Date().toISOString(),
            status: campaignPaused ? 'paused' : (failedSends > 0 ? 'partial' : 'sent'),
            successfulSends: successfulSends,
            failedSends: failedSends,
            failedRecipients: failedRecipients,
            hardBounces: hardBounces,
            complaints: complaints,
            bounceRate: bounceRate.toFixed(2),
            complaintRate: complaintRate.toFixed(2),
            paused: campaignPaused,
            pauseReason: pauseReason || null,
            opens: [], // Will store open events here
            createdBy: normalizedMessage.userId || user.id, // Track who created this campaign
            userId: normalizedMessage.userId || user.id // Maintain compatibility
        };
        
        // Store message in appropriate location
        if (user.accountId) {
            // For team members, store in individual data structure as flat array
            const individualDataPath = path.join(__dirname, 'data', 'individual-data', user.id.toString());
            const messagesPath = path.join(individualDataPath, 'messages.json');
            
            // Ensure directory exists
            if (!fs.existsSync(individualDataPath)) {
                fs.mkdirSync(individualDataPath, { recursive: true });
            }
            
            // Load existing messages as flat array
            let messages = [];
            if (fs.existsSync(messagesPath)) {
                try {
                    const data = fs.readFileSync(messagesPath, 'utf8');
                    const parsed = JSON.parse(data);
                    // Ensure messages is an array
                    messages = Array.isArray(parsed) ? parsed : [];
                } catch (error) {
                    console.error('Error loading messages file:', error);
                    messages = [];
                }
            }
            
            // Add type and userId for filtering
            messageRecord.type = 'email';
            messageRecord.userId = user.id.toString();
            
            // Add the message to flat array
            messages.push(messageRecord);
            
            // Save to individual data
            fs.writeFileSync(messagesPath, JSON.stringify(messages, null, 2));
        } else {
            // For app owners, store in user file
            if (!user.emailMessages) user.emailMessages = { sent: [], received: [] };
            user.emailMessages.sent.push(messageRecord);
            await writeIndividualUserFile(user.id, user);
        }
        
        // Return both messageId and send results
        return {
            messageId: messageId,
            successfulSends: successfulSends,
            failedSends: failedSends,
            failedRecipients: failedRecipients
        };
    } catch (error) {
        console.error('Email sending error:', error);
        
        // Even if sending fails, record the message attempt
        const messageId = Date.now().toString() + '-' + Math.floor(Math.random() * 1000000);
        
        // Create normalizedMessage for error handling if it doesn't exist
        let normalizedMessage;
        if (message.to && message.html) {
            normalizedMessage = {
                recipients: [{ email: message.to }],
                content: message.html,
                subject: message.subject || "Message from Campaign Builder",
                fromEmail: message.fromEmail,
                userId: user.id
            };
        } else if (message.recipients) {
            normalizedMessage = message;
        }
        
        const messageRecord = {
            id: messageId,
            to: normalizedMessage ? normalizedMessage.recipients.map(r => r.email) : (Array.isArray(message.to) ? message.to : [message.to]),
            subject: (normalizedMessage || message).subject || "Message from Campaign Builder",
            body: (normalizedMessage || message).content || message.html,
            timestamp: new Date().toISOString(),
            status: 'failed',
            error: error.message,
            opens: [],
            createdBy: (normalizedMessage || message).userId || user.id, // Track who created this campaign
            userId: (normalizedMessage || message).userId || user.id // Maintain compatibility
        };
        
        // Store message in appropriate location
        if (user.accountId) {
            // For team members, store in individual data structure as flat array
            const individualDataPath = path.join(__dirname, 'data', 'individual-data', user.id.toString());
            const messagesPath = path.join(individualDataPath, 'messages.json');
            
            // Ensure directory exists
            if (!fs.existsSync(individualDataPath)) {
                fs.mkdirSync(individualDataPath, { recursive: true });
            }
            
            // Load existing messages as flat array
            let messages = [];
            if (fs.existsSync(messagesPath)) {
                try {
                    const data = fs.readFileSync(messagesPath, 'utf8');
                    const parsed = JSON.parse(data);
                    // Ensure messages is an array
                    messages = Array.isArray(parsed) ? parsed : [];
                } catch (error) {
                    console.error('Error loading messages file:', error);
                    messages = [];
                }
            }
            
            // Add type and userId for filtering
            messageRecord.type = 'email';
            messageRecord.userId = user.id.toString();
            
            // Add the message to flat array
            messages.push(messageRecord);
            
            // Save to individual data
            fs.writeFileSync(messagesPath, JSON.stringify(messages, null, 2));
        } else {
            // For app owners, store in user file
            if (!user.emailMessages) user.emailMessages = { sent: [], received: [] };
            user.emailMessages.sent.push(messageRecord);
            await writeIndividualUserFile(user.id, user);
        }
        
        throw error;
    }
}

// Email validation function
function isValidEmail(email) {
    // Basic type and null checks
    if (!email || typeof email !== 'string') return false;
    
    const trimmed = email.trim();
    if (trimmed.length === 0 || trimmed.length > 254) return false;
    
    // RFC 5321 compliant email regex (more permissive than before)
    const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    
    if (!emailRegex.test(trimmed)) return false;
    
    // Check for consecutive dots
    if (trimmed.includes('..')) return false;
    
    // Split and validate parts
    const parts = trimmed.split('@');
    if (parts.length !== 2) return false;
    
    const [localPart, domain] = parts;
    
    // Local part validation: 1-64 characters, no leading/trailing dots
    if (localPart.length === 0 || localPart.length > 64) return false;
    if (localPart.startsWith('.') || localPart.endsWith('.')) return false;
    
    // Domain validation: Must have at least one dot for TLD, no leading/trailing dots
    if (!domain.includes('.')) return false;
    if (domain.startsWith('.') || domain.endsWith('.')) return false;
    
    // Check for common typos in TLD (but allow any valid TLD format)
    const tld = domain.split('.').pop().toLowerCase();
    const commonTypos = ['con', 'ccom', 'comm', 'om', 'orr', 'nett', 'nte', 'eduu', 'govv'];
    if (commonTypos.includes(tld)) {
        return false;
    }
    
    // TLD must be at least 2 characters (per RFC)
    if (tld.length < 2) return false;
    
    // Domain must not have consecutive dots
    if (domain.includes('..')) return false;
    
    return true;
}

// Add the missing send-email endpoint
app.post('/api/messages/send-email', auth, async (req, res) => {
    try {
        console.log('[EMAIL-ENDPOINT] Email send request received');
        const { to, subject, content, fromEmail, fromName, templateName } = req.body;
        const recipients = Array.isArray(to) ? to : [to];
        console.log(`[EMAIL-ENDPOINT] Recipients: ${recipients.length}, Subject: ${subject || 'N/A'}`);
        
        // Normalize and deduplicate emails before validation
        const normalizedEmails = [...new Set(
            recipients
                .filter(email => email && typeof email === 'string')
                .map(email => email.trim().toLowerCase())
                .filter(email => email.length > 0)
        )];
        
        // Validate all email addresses after normalization
        const validEmails = [];
        const invalidEmails = [];
        
        normalizedEmails.forEach(email => {
            if (isValidEmail(email)) {
                validEmails.push(email);
            } else {
                invalidEmails.push(email);
            }
        });

        if (invalidEmails.length > 0) {

        }
        
        // Calculate potential token cost (maximum we might charge)
        const potentialTokenCost = validEmails.length; // Maximum tokens we might charge
        
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }

        // Check email token balance for potential recipients
        let availableTokens = user.emailTokens || 0;
        
        // For team members, use shared account tokens
        if (user.accountId) {
            const accountTokens = await getAccountTokens(user.accountId);
            availableTokens = accountTokens.emailTokens || 0;
        }
        
        if (availableTokens < potentialTokenCost) {
            throw new Error(`Insufficient email tokens. Need ${potentialTokenCost} tokens for ${validEmails.length} valid recipients.`);
        }

        // Check if sender exists and is activated
        let senderEmails = user.senderEmails || [];
        
        // For team members, get sender emails from shared data structure
        if (user.accountId) {
            const sendersPath = path.join(__dirname, 'data', 'shared-data', user.accountId.toString(), 'senders.json');
            
            if (fs.existsSync(sendersPath)) {
                const data = fs.readFileSync(sendersPath, 'utf8');
                senderEmails = JSON.parse(data);
            } else {
                // Fallback to account holder's user file
                const accountHolder = await findUserById(user.accountId);
                senderEmails = accountHolder?.senderEmails || [];
            }
        }
        
        // If no sender emails available, throw error
        if (senderEmails.length === 0) {
            throw new Error('No sender emails available. Please add and verify a sender email in Sender Settings.');
        }
        
        // If no fromEmail provided or it's empty, use the first confirmed sender
        let actualFromEmail = fromEmail;
        if (!actualFromEmail || actualFromEmail.trim() === '') {
            const confirmedSender = senderEmails.find(s => s.Confirmed);
            if (confirmedSender) {
                actualFromEmail = confirmedSender.EmailAddress;
            } else {
                throw new Error('No verified sender email available. Please verify a sender email in Sender Settings.');
            }
        }
        
        const sender = senderEmails.find(s => s.EmailAddress === actualFromEmail);
        if (!sender) {
            throw new Error(`Sender email ${actualFromEmail} not found. Please add it in Sender Settings.`);
        }
        if (!sender.Confirmed) {
            throw new Error(
                `Sender email ${actualFromEmail} exists but is not activated. Please verify it in Sender Settings.`
            );
        }

        // If no valid emails, return early with error
        if (validEmails.length === 0) {
            throw new Error(`No valid email addresses found. Invalid emails: ${invalidEmails.join(', ')}`);
        }
        
        // Filter out unsubscribed contacts
        const accountId = getEffectiveAccountId(user);
        const allContacts = await getAccountContacts(accountId);
        
        // Create email to contact mapping
        const emailToContact = {};
        allContacts.forEach(contact => {
            if (contact.email) {
                emailToContact[contact.email.toLowerCase()] = contact;
            }
        });
        
        // Filter out unsubscribed emails
        let subscribedEmails = [];
        let unsubscribedEmails = [];
        
        validEmails.forEach(email => {
            const contact = emailToContact[email.toLowerCase()];
            if (contact) {
                const prefs = contact.communicationPreferences;
                if (prefs && prefs.email && prefs.email.subscribed === false) {
                    unsubscribedEmails.push(email);
                } else {
                    subscribedEmails.push(email);
                }
            } else {
                // If contact not found, assume subscribed (new contact)
                subscribedEmails.push(email);
            }
        });
        
        if (unsubscribedEmails.length > 0) {

        }
        
        // Check suppression list for subscribed emails (accountId already declared above)
        const { filtered: nonSuppressedEmails, suppressed: suppressedEmails } = await checkSuppressionList(accountId, subscribedEmails);
        
        if (suppressedEmails.length > 0) {
            console.log(`[EMAIL-ENDPOINT] Filtered out ${suppressedEmails.length} suppressed email(s) from ${subscribedEmails.length} subscribed emails`);
            console.log(`[EMAIL-ENDPOINT] Suppressed emails:`, suppressedEmails);
            // Debug: Log the full suppression list to help diagnose issues
            const fullSuppressionList = await getSuppressionList(accountId);
            console.log(`[EMAIL-ENDPOINT] Full suppression list contains ${fullSuppressionList.length} entries`);
            console.log(`[EMAIL-ENDPOINT] Suppression list emails:`, fullSuppressionList.map(s => s.email));
            // Check if the suppressed email is actually in the list
            suppressedEmails.forEach(email => {
                const found = fullSuppressionList.find(s => s.email.toLowerCase() === email.toLowerCase());
                if (!found) {
                    console.error(`[EMAIL-ENDPOINT] WARNING: Email ${email} marked as suppressed but not found in suppression list!`);
                }
            });
        }
        
        let emailsToSend = nonSuppressedEmails;
        
        // If all emails are suppressed or unsubscribed, return early
        const totalExcluded = unsubscribedEmails.length + suppressedEmails.length;
        if (emailsToSend.length === 0) {
            // Provide detailed error message with which emails are suppressed
            const suppressedDetails = suppressedEmails.length > 0 
                ? ` Suppressed emails: ${suppressedEmails.slice(0, 5).join(', ')}${suppressedEmails.length > 5 ? '...' : ''}`
                : '';
            const unsubscribedDetails = unsubscribedEmails.length > 0
                ? ` Unsubscribed emails: ${unsubscribedEmails.slice(0, 5).join(', ')}${unsubscribedEmails.length > 5 ? '...' : ''}`
                : '';
            throw new Error(`All ${validEmails.length} email addresses are either unsubscribed (${unsubscribedEmails.length}) or on the suppression list (${suppressedEmails.length}) and cannot be sent to.${suppressedDetails}${unsubscribedDetails}`);
        }
        
        // Use broadcast API for email campaigns instead of batching
        const totalValidRecipients = emailsToSend.length;
        
        // For large campaigns (>1000 emails), process asynchronously to avoid timeouts
        const LARGE_CAMPAIGN_THRESHOLD = 1000;
        const isLargeCampaign = totalValidRecipients > LARGE_CAMPAIGN_THRESHOLD;
        
        // Generate campaign ID early for tracking
        const campaignId = Date.now().toString() + '-' + Math.floor(Math.random() * 1000000);
        
        // Create single broadcast message with only non-suppressed valid emails
        const message = {
            userId: req.user.id,
            recipients: emailsToSend.map(email => ({ email })),
            subject: subject,
            content: content,
            fromEmail: actualFromEmail,
            fromName: fromName,
            messageId: campaignId,
            _skipQueueProcessing: totalValidRecipients <= 10 // Skip queue processing for small sends to avoid SMTP overload
        };

        if (isLargeCampaign) {
            // For large campaigns, respond immediately and process in background
            console.log(`[EMAIL-ENDPOINT] Large campaign detected (${totalValidRecipients} recipients). Processing asynchronously.`);
            
            // Create initial campaign record with "processing" status
            const sharedDataPath = path.join(SHARED_DATA_DIR, user.accountId || user.id);
            const emailCampaignsPath = path.join(sharedDataPath, 'email-campaigns.json');
            let emailCampaigns = [];
            
            if (fs.existsSync(emailCampaignsPath)) {
                const data = await fsPromises.readFile(emailCampaignsPath, 'utf8');
                emailCampaigns = JSON.parse(data);
            }
            
            const emailMessage = {
                id: campaignId,
                userId: req.user.id,
                type: 'outbound',
                templateName: templateName || 'Custom Email',
                recipientCount: totalValidRecipients,
                subject: subject,
                fromEmail: fromEmail,
                fromName: fromName,
                status: 'processing',
                timestamp: new Date().toISOString(),
                successfulSends: 0,
                failedSends: 0,
                invalidEmails: invalidEmails,
                validRecipients: validEmails,
                totalAttempted: recipients.length,
                opens: []
            };
            
            emailCampaigns.push(emailMessage);
            await fsPromises.writeFile(emailCampaignsPath, JSON.stringify(emailCampaigns, null, 2), 'utf8');
            
            // Process emails asynchronously (don't await)
            (async () => {
                let successfulSends = 0;
                let failedSends = 0;
                let failedRecipients = [];
                let sendResult = null;
                
                try {
                    console.log(`[EMAIL-ENDPOINT] Background: Calling sendEmail with ${emailsToSend.length} recipients`);
                    sendResult = await sendEmail(message, user);
                    
                    successfulSends = sendResult.successfulSends || 0;
                    failedSends = sendResult.failedSends || 0;
                    failedRecipients = sendResult.failedRecipients || [];
                    
                    console.log(`[EMAIL-ENDPOINT] Background: SendEmail completed - Success: ${successfulSends}, Failed: ${failedSends}`);
                } catch (campaignError) {
                    const safeErrorMessage = campaignError.message ? campaignError.message.replace(/password|pass|auth|credential|user|username|@.*\./gi, '[REDACTED]') : 'Unknown error';
                    console.error(`[EMAIL-ENDPOINT] Background: Broadcast email campaign failed:`, safeErrorMessage);
                    failedSends = totalValidRecipients;
                    successfulSends = 0;
                }
                
                // Update campaign record with results
                const updatedCampaigns = JSON.parse(await fsPromises.readFile(emailCampaignsPath, 'utf8'));
                const campaignIndex = updatedCampaigns.findIndex(c => c.id === campaignId);
                if (campaignIndex !== -1) {
                    updatedCampaigns[campaignIndex].status = failedSends > 0 ? 'partial' : 'sent';
                    updatedCampaigns[campaignIndex].successfulSends = successfulSends;
                    updatedCampaigns[campaignIndex].failedSends = failedSends;
                    await fsPromises.writeFile(emailCampaignsPath, JSON.stringify(updatedCampaigns, null, 2), 'utf8');
                }
                
                // Deduct tokens based on successful sends only
                const actualTokenCost = successfulSends;
                if (actualTokenCost > 0) {
                    const updatedUser = await findUserById(req.user.id);
                    if (updatedUser) {
                        if (updatedUser.accountId) {
                            await deductAccountTokens(updatedUser.accountId, 'emailTokens', actualTokenCost);
                            console.log(`[TOKENS] Background: Deducted ${actualTokenCost} email tokens from account ${updatedUser.accountId}`);
                        } else {
                            updatedUser.emailTokens = Math.max(0, (updatedUser.emailTokens || 0) - actualTokenCost);
                            console.log(`[TOKENS] Background: Deducted ${actualTokenCost} email tokens from user ${updatedUser.id}`);
                        }
                        
                        // Record token transaction
                        if (!updatedUser.tokenTransactions) {
                            updatedUser.tokenTransactions = [];
                        }
                        
                        let transactionDescription = `Email sent to ${successfulSends} recipients`;
                        if (failedSends > 0) {
                            transactionDescription += ` (${failedSends} failed - refunded)`;
                        }
                        if (invalidEmails.length > 0) {
                            transactionDescription += ` (${invalidEmails.length} invalid emails rejected)`;
                        }
                        if (unsubscribedEmails.length > 0) {
                            transactionDescription += ` (${unsubscribedEmails.length} unsubscribed emails filtered)`;
                        }
                        if (suppressedEmails.length > 0) {
                            transactionDescription += ` (${suppressedEmails.length} suppressed emails filtered)`;
                        }
                        
                        updatedUser.tokenTransactions.push({
                            id: Date.now().toString(),
                            type: 'usage',
                            amount: -actualTokenCost,
                            service: 'email',
                            timestamp: new Date().toISOString(),
                            description: transactionDescription
                        });
                        
                        await writeIndividualUserFile(req.user.id, updatedUser);
                    }
                }
            })();
            
            // Respond immediately for large campaigns
            res.json({
                success: true,
                processing: true,
                message: `Email campaign queued for processing. ${totalValidRecipients} emails will be sent in the background. This may take several minutes. You can continue using the app while emails are being sent.`,
                campaignId: campaignId,
                stats: {
                    totalAttempted: recipients.length,
                    validEmails: validEmails.length,
                    invalidEmails: invalidEmails.length,
                    unsubscribedEmails: unsubscribedEmails.length,
                    suppressedEmails: suppressedEmails.length,
                    queuedRecipients: totalValidRecipients
                }
            });
            return; // Exit early for large campaigns
        }
        
        // For smaller campaigns, process synchronously (existing behavior)
        // Generate campaign ID for synchronous sends too
        const syncCampaignId = Date.now().toString() + '-' + Math.floor(Math.random() * 1000000);
        message.messageId = syncCampaignId;
        
        let successfulSends = 0;
        let failedSends = 0;
        let failedRecipients = [];
        let sendResult = null; // Define outside try block

        try {
            console.log(`[EMAIL-ENDPOINT] Calling sendEmail with ${emailsToSend.length} recipients`);
            sendResult = await sendEmail(message, user);
            
            // Get the actual send results from the returned object
            successfulSends = sendResult.successfulSends || 0;
            failedSends = sendResult.failedSends || 0;
            failedRecipients = sendResult.failedRecipients || [];
            
            console.log(`[EMAIL-ENDPOINT] SendEmail completed - Success: ${successfulSends}, Failed: ${failedSends}`);
            console.log(`[EMAIL-ENDPOINT] Verification: successfulSends=${successfulSends}, failedSends=${failedSends}, total=${successfulSends + failedSends}, expected=${emailsToSend.length}`);
            
            // Verify counts match
            if ((successfulSends + failedSends) !== emailsToSend.length) {
                console.error(`[EMAIL-ENDPOINT] âš ï¸  COUNT MISMATCH: sendEmail returned ${successfulSends + failedSends} results but we sent to ${emailsToSend.length} recipients`);
            } else {
                console.log(`[EMAIL-ENDPOINT] âœ… Count verification passed: All ${emailsToSend.length} recipients accounted for`);
            }

            // If all sends failed, provide more detailed error information
            if (successfulSends === 0 && failedSends > 0) {
                console.error('[EMAIL-ENDPOINT] All email sends failed. Check SMTP configuration and sender verification.');
                // Sanitize failed recipients - don't log full email addresses
                const sanitizedFailedRecipients = failedRecipients.map(r => ({
                    email: r.email ? r.email.split('@')[0] + '@[REDACTED]' : '[REDACTED]',
                    error: r.error ? r.error.replace(/password|pass|auth|credential|user|username|@.*\./gi, '[REDACTED]') : 'Unknown error',
                    isBounce: r.isBounce || false
                }));
                console.error('[EMAIL-ENDPOINT] Failed recipients count:', failedSends, 'Details (sanitized):', sanitizedFailedRecipients);
                const accountId = user.accountId || user.id;
                await logAuditEvent(req.user.id, 'FAILED_BULK_EMAIL', { accountId, failedCount: failedSends, recipientCount: totalValidRecipients });
            }
        } catch (campaignError) {
            // Sanitize error messages - don't expose sensitive information
            const safeErrorMessage = campaignError.message ? campaignError.message.replace(/password|pass|auth|credential|user|username|@.*\./gi, '[REDACTED]') : 'Unknown error';
            console.error(`[EMAIL-ENDPOINT] Broadcast email campaign failed:`, safeErrorMessage);
            // Don't log full stack traces that might contain sensitive data
            if (campaignError.stack) {
                const safeStack = campaignError.stack.split('\n').slice(0, 3).join('\n'); // Only first 3 lines
                console.error('[EMAIL-ENDPOINT] Error location:', safeStack.replace(/password|pass|auth|credential|user|username|@.*\./gi, '[REDACTED]'));
            }
            failedSends = totalValidRecipients;
            successfulSends = 0;
            const accountIdErr = user.accountId || user.id;
            await logAuditEvent(req.user.id, 'FAILED_BULK_EMAIL', { accountId: accountIdErr, failedCount: totalValidRecipients, recipientCount: totalValidRecipients, error: (campaignError && campaignError.message) ? campaignError.message.substring(0, 200) : 'Campaign exception' });
        }

        // Record the email campaign in shared-data structure
        const sharedDataPath = path.join(SHARED_DATA_DIR, user.accountId || user.id);
        const emailCampaignsPath = path.join(sharedDataPath, 'email-campaigns.json');
        let emailCampaigns = [];
        
        if (fs.existsSync(emailCampaignsPath)) {
            const data = await fsPromises.readFile(emailCampaignsPath, 'utf8');
            emailCampaigns = JSON.parse(data);
        }
        
        // Use the messageId from sendEmail for consistent tracking, or generate one if sendEmail failed
        const finalCampaignId = sendResult?.messageId || (Date.now().toString() + '-' + Math.floor(Math.random() * 1000000));
        const emailMessage = {
            id: finalCampaignId,
            userId: req.user.id,
            type: 'outbound',
            templateName: templateName || 'Custom Email',
            recipientCount: totalValidRecipients, // Only count valid recipients
            subject: subject,
            fromEmail: fromEmail,
            fromName: fromName,
            status: failedSends > 0 ? 'partial' : 'sent',
            timestamp: new Date().toISOString(),
            successfulSends: successfulSends,
            failedSends: failedSends,
            invalidEmails: invalidEmails, // Track invalid emails
            validRecipients: validEmails, // Track valid recipients
            totalAttempted: recipients.length, // Track total attempted
            opens: [] // Initialize opens array for tracking
        };
        
        emailCampaigns.push(emailMessage);
        await fsPromises.writeFile(emailCampaignsPath, JSON.stringify(emailCampaigns, null, 2), 'utf8');

        // Calculate actual tokens to charge - only successful sends
        let actualTokenCost = successfulSends; // Only charge for emails that were actually sent successfully
        const refundAmount = potentialTokenCost - actualTokenCost; // Refund for failed sends

        // Safety check: Don't charge more tokens than successful sends
        if (actualTokenCost > successfulSends) {
            console.error(`ERROR: Token cost (${actualTokenCost}) exceeds successful sends (${successfulSends}). Adjusting to prevent overcharging.`);
            actualTokenCost = successfulSends;
        }
        
        // Critical safety check: If NO emails were sent successfully, don't charge any tokens
        if (successfulSends === 0) {
            console.error(`CRITICAL: No emails were sent successfully. Not charging any tokens.`);
            actualTokenCost = 0;
        }
        
        // Additional safety check: If there are any failed sends, log them for debugging
        if (failedSends > 0) {
            console.error(`WARNING: ${failedSends} emails failed to send. Only charging for ${successfulSends} successful sends.`);
            // Sanitize failed recipients - don't log full email addresses
            const sanitizedFailedRecipients = failedRecipients.map(r => ({
                email: r.email ? r.email.split('@')[0] + '@[REDACTED]' : '[REDACTED]',
                error: r.error ? r.error.replace(/password|pass|auth|credential|user|username|@.*\./gi, '[REDACTED]') : 'Unknown error',
                isBounce: r.isBounce || false
            }));
            console.error('Failed recipients count:', failedSends, 'Details (sanitized):', sanitizedFailedRecipients);
        }
        
        // Deduct tokens based on successful sends only
        if (actualTokenCost > 0) {
            if (user.accountId) {
                // For team members, deduct from shared account tokens
                try {
                    await deductAccountTokens(user.accountId, 'emailTokens', actualTokenCost);
                    console.log(`[TOKENS] Deducted ${actualTokenCost} email tokens from account ${user.accountId}`);
                } catch (tokenError) {
                    console.error(`[TOKENS] ERROR: Failed to deduct tokens from account ${user.accountId}:`, tokenError.message);
                    // Don't throw - log error but continue
                }
            } else {
                // For app owners, deduct from individual tokens
                const beforeTokens = user.emailTokens || 0;
                user.emailTokens = Math.max(0, beforeTokens - actualTokenCost);
                console.log(`[TOKENS] Deducted ${actualTokenCost} email tokens from user ${user.id} (${beforeTokens} -> ${user.emailTokens})`);
            }
        } else {
            console.log(`[TOKENS] No tokens to deduct (actualTokenCost: ${actualTokenCost}, successfulSends: ${successfulSends})`);
        }
        
        // Record token transaction
        if (!user.tokenTransactions) {
            user.tokenTransactions = [];
        }
        
        let transactionDescription = `Email sent to ${successfulSends} recipients`;
        if (failedSends > 0) {
            transactionDescription += ` (${failedSends} failed - refunded)`;
        }
        if (invalidEmails.length > 0) {
            transactionDescription += ` (${invalidEmails.length} invalid emails rejected)`;
        }
        if (unsubscribedEmails.length > 0) {
            transactionDescription += ` (${unsubscribedEmails.length} unsubscribed emails filtered)`;
        }
        if (suppressedEmails.length > 0) {
            transactionDescription += ` (${suppressedEmails.length} suppressed emails filtered)`;
        }
        
        user.tokenTransactions.push({
            id: Date.now().toString(),
            type: 'usage',
            amount: -actualTokenCost,
            service: 'email',
            timestamp: new Date().toISOString(),
            description: transactionDescription
        });
        
        // Add refund transaction if there were failed sends
        if (refundAmount > 0) {
            user.tokenTransactions.push({
                id: (Date.now() + 1).toString(),
                type: 'refund',
                amount: refundAmount,
                service: 'email',
                timestamp: new Date().toISOString(),
                description: `Refund for ${failedSends} failed email sends`
            });
        }
        
        await writeIndividualUserFile(req.user.id, user);

        // Prepare response message
        let responseMessage = `Email campaign completed: ${successfulSends} successful sends`;
        if (failedSends > 0) {
            responseMessage += `, ${failedSends} failed (not charged)`;
        }
        if (invalidEmails.length > 0) {
            responseMessage += `, ${invalidEmails.length} invalid emails rejected (not charged)`;
        }
        if (unsubscribedEmails.length > 0) {
            responseMessage += `, ${unsubscribedEmails.length} unsubscribed emails filtered (not charged)`;
        }
        if (suppressedEmails.length > 0) {
            responseMessage += `, ${suppressedEmails.length} suppressed emails filtered (not charged)`;
        }
        responseMessage += `. ${actualTokenCost} tokens charged`;
        if (refundAmount > 0) {
            responseMessage += `, ${refundAmount} tokens saved (failed sends not charged)`;
        }
        responseMessage += `.`;
        
        // If all emails failed, return error response
        if (successfulSends === 0 && failedSends > 0) {
            // Check if failures are due to MAIL FROM errors (sender-side issues)
            // "Mail command failed" or "452 4.3.1 Insufficient system storage" during MAIL FROM = sender's SMTP server issue
            const hasMailFromErrors = failedRecipients.some(r => 
                r.isMailFromError === true ||
                (r.error && (
                    r.error.includes('MAIL FROM') || 
                    r.error.includes('Mail command failed') ||
                    (r.error.includes('452 4.3.1') && r.error.includes('Insufficient system storage'))
                ))
            );
            
            let errorMessage;
            if (hasMailFromErrors) {
                errorMessage = 'All emails failed: SMTP server error detected. Your SMTP server or account appears to have reached a quota/limit or has storage issues. This is NOT a recipient problem - it\'s an issue with your sending server. Please check your SMTP provider account status and sending limits.';
            } else {
                errorMessage = failedRecipients.length > 0 && failedRecipients[0].error
                    ? `All emails failed to send. Error: ${failedRecipients[0].error.replace(/password|pass|auth|credential|user|username/gi, '[REDACTED]')}`
                    : 'All emails failed to send. Please check your SMTP settings and try again.';
            }
            
            return res.status(400).json({
                success: false,
                error: errorMessage,
                message: responseMessage,
                stats: {
                    totalAttempted: recipients.length,
                    validEmails: validEmails.length,
                    invalidEmails: invalidEmails.length,
                    unsubscribedEmails: unsubscribedEmails.length,
                    suppressedEmails: suppressedEmails.length,
                    successfulSends: successfulSends,
                    failedSends: failedSends,
                    tokensCharged: actualTokenCost,
                    tokensSaved: refundAmount,
                    rejectedEmails: invalidEmails,
                    unsubscribedEmailList: unsubscribedEmails,
                    suppressedEmailList: suppressedEmails,
                    failedRecipients: failedRecipients.map(r => ({
                        email: r.email,
                        error: r.error ? r.error.replace(/password|pass|auth|credential|user|username/gi, '[REDACTED]') : 'Unknown error'
                    }))
                }
            });
        }
        
        res.json({ 
            success: successfulSends > 0,
            message: responseMessage,
            stats: {
                totalAttempted: recipients.length,
                validEmails: validEmails.length,
                invalidEmails: invalidEmails.length,
                unsubscribedEmails: unsubscribedEmails.length,
                suppressedEmails: suppressedEmails.length,
                successfulSends: successfulSends,
                failedSends: failedSends,
                tokensCharged: actualTokenCost,
                tokensSaved: refundAmount,
                rejectedEmails: invalidEmails,
                unsubscribedEmailList: unsubscribedEmails,
                suppressedEmailList: suppressedEmails,
                failedRecipients: failedRecipients.map(r => ({
                    email: r.email,
                    error: r.error ? r.error.replace(/password|pass|auth|credential|user|username/gi, '[REDACTED]') : 'Unknown error'
                }))
            }
        });
    } catch (error) {
        console.error('Send email error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add the missing send-sms endpoint
app.post('/api/messages/send-sms', auth, async (req, res) => {
    try {

        const { to, content } = req.body;
        const recipients = Array.isArray(to) ? to : [to];
        // Token cost will be recalculated after filtering unsubscribed
        const potentialTokenCost = recipients.length;
        
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }

        // Check SMS token balance for total recipients
        let availableSmsTokens = user.smsTokens || 0;
        
        // For team members, use shared account tokens
        if (user.accountId) {
            const accountTokens = await getAccountTokens(user.accountId);
            availableSmsTokens = accountTokens.smsTokens || 0;
        }
        
        if (availableSmsTokens < potentialTokenCost) {
            throw new Error(`Insufficient SMS tokens. Need ${potentialTokenCost} tokens for ${recipients.length} recipients.`);
        }

        // Get default sending number from shared-data
        const sharedDataPath = path.join(SHARED_DATA_DIR, user.accountId || user.id);
        const phoneNumbersPath = path.join(sharedDataPath, 'phoneNumbers.json');
        let availablePhoneNumbers = [];
        
        if (fs.existsSync(phoneNumbersPath)) {
            const phoneData = fs.readFileSync(phoneNumbersPath, 'utf8');
            availablePhoneNumbers = JSON.parse(phoneData);
        }
        
        const defaultNumber = availablePhoneNumbers.find(n => n.isDefault) || availablePhoneNumbers[0];
        if (!defaultNumber) {
            throw new Error('No phone numbers available for sending SMS. Please add a phone number in Sender Settings.');
        }

        // Test Twilio authentication before attempting to send
        try {
            await twilioClient.api.accounts(process.env.TWILIO_ACCOUNT_SID).fetch();
        } catch (authError) {
            console.error('Twilio authentication failed:', authError.message);
            throw new Error('SMS service authentication failed. Please contact support to update Twilio credentials.');
        }

        // Filter out unsubscribed contacts BEFORE sending
        const accountId = getEffectiveAccountId(user);
        const allContacts = await getAccountContacts(accountId);
        
        // Create phone to contact mapping (normalize phone numbers)
        const phoneToContact = {};
        allContacts.forEach(contact => {
            if (contact.phone) {
                const normalizedPhone = contact.phone.replace(/\D/g, '');
                phoneToContact[normalizedPhone] = contact;
            }
        });
        
        // Filter out unsubscribed phones
        let subscribedRecipients = [];
        let unsubscribedRecipients = [];
        
        recipients.forEach(phone => {
            const normalizedPhone = phone.replace(/\D/g, '');
            const contact = phoneToContact[normalizedPhone];
            if (contact) {
                const prefs = contact.communicationPreferences;
                if (prefs && prefs.sms && prefs.sms.subscribed === false) {
                    unsubscribedRecipients.push(phone);
                } else {
                    subscribedRecipients.push(phone);
                }
            } else {
                // If contact not found, assume subscribed (new contact)
                subscribedRecipients.push(phone);
            }
        });
        
        if (unsubscribedRecipients.length > 0) {

        }
        
        // If all recipients are unsubscribed, return early
        if (subscribedRecipients.length === 0) {
            throw new Error(`All ${recipients.length} phone numbers are unsubscribed from SMS and cannot be sent to.`);
        }
        
        // Update token cost to match subscribed recipients only
        const actualTokenCost = subscribedRecipients.length;
        
        // Link tracking: replace URLs in content with tracking links per recipient
        const urlRegex = /(https?:\/\/[^\s]+)/gi;
        const hasUrls = urlRegex.test(content);
        // Reset regex lastIndex for reuse
        urlRegex.lastIndex = 0;

        const statusCallbackUrl = `${BASE_URL}/api/webhooks/status/${req.user.id}`;
        const linkTokens = []; // Collect tokens for this send across all recipients

        // Build personalized bodies and send to subscribed recipients only
        const responses = await Promise.all(subscribedRecipients.map(async (recipient) => {
            let personalizedBody = content;
            if (hasUrls) {
                // Replace each URL with tracking link
                personalizedBody = content.replace(urlRegex, (matchUrl) => {
                    const token = Math.random().toString(36).slice(2, 10) + Date.now().toString().slice(-4);
                    linkTokens.push({ token, url: matchUrl, recipient });
                    return `${BASE_URL}/t/${req.user.id}/${token}`;
                });
            }
            const resp = await twilioClient.messages.create({
                body: personalizedBody,
                to: recipient,
                from: defaultNumber.number,
                statusCallback: statusCallbackUrl
            });
            return resp;
        }));

        // Record token transaction
        if (!user.tokenTransactions) {
            user.tokenTransactions = [];
        }
        
        user.tokenTransactions.push({
            id: Date.now().toString(),
            type: 'usage',
            amount: -tokenCost,
            service: 'sms',
            timestamp: new Date().toISOString(),
            description: `SMS sent to ${recipients.length} recipients`
        });
        
        // Record the message in appropriate location
        const messageData = {
            id: Date.now().toString(),
            userId: user.id.toString(),
            to: recipients,
            content: content,
            body: content,
            from: defaultNumber.number,
            timestamp: new Date().toISOString(),
            status: 'sent',
            type: 'sms',
            recipientCount: subscribedRecipients.length,
            externalId: responses[0]?.sid,
            externalIds: responses.map(r => r.sid),
            linkTokens: linkTokens,
            linkClicks: []
        };

        // Store message in shared-data structure
        const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
        let smsMessages = [];
        
        if (fs.existsSync(smsMessagesPath)) {
            const data = await fsPromises.readFile(smsMessagesPath, 'utf8');
            smsMessages = JSON.parse(data);
        }
        
        // Add message with proper type for outbound
        messageData.type = 'outbound';
        smsMessages.push(messageData);
        await fsPromises.writeFile(smsMessagesPath, JSON.stringify(smsMessages, null, 2), 'utf8');

        // Deduct SMS tokens
        if (user.accountId) {
            // For team members, deduct from shared account tokens
            await deductAccountTokens(user.accountId, 'smsTokens', actualTokenCost);
        } else {
            // For app owners, deduct from individual tokens
            user.smsTokens = (user.smsTokens || 0) - actualTokenCost;
        }

        await writeIndividualUserFile(req.user.id, user);

        let responseMessage = `SMS sent successfully to ${subscribedRecipients.length} recipients. ${actualTokenCost} tokens deducted.`;
        if (unsubscribedRecipients.length > 0) {
            responseMessage += ` (${unsubscribedRecipients.length} unsubscribed recipients filtered - not charged)`;
        }

        res.json({ 
            success: true, 
            message: responseMessage,
            totalAttempted: recipients.length,
            totalSent: subscribedRecipients.length,
            unsubscribedCount: unsubscribedRecipients.length,
            responses: responses.map(r => r.sid)
        });
    } catch (error) {
        console.error('Send SMS error:', error);
        if (req.user && req.user.id) {
            const to = req.body && req.body.to;
            const recipientCount = Array.isArray(to) ? to.length : (to ? 1 : 0);
            if (recipientCount > 0) {
                const user = await findUserById(req.user.id).catch(() => null);
                const accountId = user ? (user.accountId || user.id) : req.user.id;
                await logAuditEvent(req.user.id, 'FAILED_BULK_SMS', { accountId, failedCount: recipientCount, recipientCount, error: (error && error.message) ? error.message.substring(0, 200) : 'Send failed' });
            }
        }
        res.status(400).json({ error: error.message });
    }
});

// Add SMS history endpoint
app.get('/api/messages/sms/history', auth, async (req, res) => {
    try {
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }

        let sentMessages = [];
        let receivedMessages = [];
        
        if (user.accountId) {
            // For team members and account holders, get messages from shared-data
            const sharedDataPath = path.join(SHARED_DATA_DIR, user.accountId.toString());
            const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
            
            if (fs.existsSync(smsMessagesPath)) {
                const data = fs.readFileSync(smsMessagesPath, 'utf8');
                const smsMessages = JSON.parse(data);
                
                if (Array.isArray(smsMessages)) {
                    // Don't filter by userId - show all account messages for team members and account holders
                    sentMessages = smsMessages.filter(msg => 
                        (msg.type === 'sms' || msg.type === 'outbound')
                    );
                    receivedMessages = smsMessages.filter(msg => 
                        msg.type === 'inbound'
                    );
                }
            }
        } else {
            // For app owners, get messages from their own shared-data
            const sharedDataPath = path.join(SHARED_DATA_DIR, user.id.toString());
            const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
            
            if (fs.existsSync(smsMessagesPath)) {
                const data = fs.readFileSync(smsMessagesPath, 'utf8');
                const smsMessages = JSON.parse(data);
                
                if (Array.isArray(smsMessages)) {
                    sentMessages = smsMessages.filter(msg => 
                        (msg.type === 'sms' || msg.type === 'outbound')
                    );
                    receivedMessages = smsMessages.filter(msg => 
                        msg.type === 'inbound'
                    );
                }
            }
        }

        // Format messages to match frontend expectations
        const formattedSent = sentMessages.map(msg => ({
            ...msg,
            type: 'outbound',
            timestamp: msg.timestamp || new Date().toISOString()
        }));

        const formattedReceived = receivedMessages.map(msg => ({
            ...msg,
            type: 'inbound',
            timestamp: msg.timestamp || new Date().toISOString()
        }));

        res.json({
            sent: formattedSent,
            received: formattedReceived,
            stats: {
                totalSent: sentMessages.length,
                totalReceived: receivedMessages.length,
                total: sentMessages.length + receivedMessages.length
            }
        });
    } catch (error) {
        console.error('SMS history error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add email history endpoint
app.get('/api/messages/email/history', auth, async (req, res) => {
    try {
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }

        let sentMessages = [];
        let receivedMessages = [];
        
        if (user.accountId) {
            // For team members and account holders, get messages from shared-data
            const sharedDataPath = path.join(SHARED_DATA_DIR, user.accountId.toString());
            const emailMessagesPath = path.join(sharedDataPath, 'email-messages.json');
            
            if (fs.existsSync(emailMessagesPath)) {
                const data = fs.readFileSync(emailMessagesPath, 'utf8');
                const emailMessages = JSON.parse(data);
                
                if (Array.isArray(emailMessages)) {
                    // Don't filter by userId - show all account messages for team members and account holders
                    sentMessages = emailMessages.filter(msg => 
                        msg.type === 'outbound'
                    );
                    receivedMessages = emailMessages.filter(msg => 
                        msg.type === 'inbound'
                    );
                }
            }
        } else {
            // For app owners, get messages from their own shared-data
            const sharedDataPath = path.join(SHARED_DATA_DIR, user.id.toString());
            const emailMessagesPath = path.join(sharedDataPath, 'email-messages.json');
            
            if (fs.existsSync(emailMessagesPath)) {
                const data = fs.readFileSync(emailMessagesPath, 'utf8');
                const emailMessages = JSON.parse(data);
                
                if (Array.isArray(emailMessages)) {
                    sentMessages = emailMessages.filter(msg => 
                        msg.type === 'outbound'
                    );
                    receivedMessages = emailMessages.filter(msg => 
                        msg.type === 'inbound'
                    );
                }
            }
        }

        // Format messages to match frontend expectations
        const formattedSent = sentMessages.map(msg => ({
            ...msg,
            type: 'email',
            timestamp: msg.timestamp || new Date().toISOString()
        }));

        const formattedReceived = receivedMessages.map(msg => ({
            ...msg,
            type: 'email',
            timestamp: msg.timestamp || new Date().toISOString()
        }));

        res.json({
            sent: formattedSent,
            received: formattedReceived,
            stats: {
                totalSent: sentMessages.length,
                totalReceived: receivedMessages.length,
                total: sentMessages.length + receivedMessages.length
            }
        });
    } catch (error) {
        console.error('Email history error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add SMS webhook endpoint for receiving messages
app.post('/api/webhooks/sms/:userId', async (req, res) => {
    try {

        const { userId } = req.params;
        const { From, To, Body, MessageSid } = req.body;
        
        if (!From || !To || !Body) {
            console.error('Missing required fields in SMS webhook');
            res.set('Content-Type', 'text/xml');
            return res.send('<Response></Response>');
        }

        const user = await findUserById(userId);
        if (!user) {
            console.error('User not found for SMS webhook:', userId);
            res.set('Content-Type', 'text/xml');
            return res.send('<Response></Response>');
        }

        // Create received message record
        const receivedMessage = {
            id: Date.now().toString(),
            messageId: MessageSid,
            from: From,
            to: To,
            content: Body,
            status: 'received',
            timestamp: new Date().toISOString(),
            type: 'inbound'
        };

        // Add to shared-data SMS messages
        const accountId = user.accountId || user.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
        
        // Ensure shared-data directory exists
        await fsPromises.mkdir(sharedDataPath, { recursive: true });
        
        let smsMessages = [];
        if (fs.existsSync(smsMessagesPath)) {
            const data = await fsPromises.readFile(smsMessagesPath, 'utf8');
            smsMessages = JSON.parse(data);
        }
        
        smsMessages.push(receivedMessage);
        await fsPromises.writeFile(smsMessagesPath, JSON.stringify(smsMessages, null, 2), 'utf8');
        
        // Track SMS response in dedicated responses file
        const smsResponsesPath = path.join(sharedDataPath, 'sms-responses.json');
        let smsResponses = [];
        
        if (fs.existsSync(smsResponsesPath)) {
            const data = await fsPromises.readFile(smsResponsesPath, 'utf8');
            smsResponses = JSON.parse(data);
        }
        
        // Create response record
        const smsResponse = {
            id: `sms_response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            campaignId: null, // Will be linked to campaign if we can determine it
            contactId: null, // Will be linked to contact if we can determine it
            userId: userId,
            messageId: MessageSid,
            from: From,
            to: To,
            content: Body,
            responseType: 'reply', // reply, opt_out, etc.
            timestamp: new Date().toISOString(),
            status: 'received'
        };
        
        // Check for unsubscribe keywords (STOP, UNSUBSCRIBE, etc.)
        const unsubscribeKeywords = ['STOP', 'UNSUBSCRIBE', 'CANCEL', 'END', 'QUIT', 'OPT OUT', 'OPTOUT'];
        const bodyUpper = Body.toUpperCase().trim();
        const isUnsubscribeRequest = unsubscribeKeywords.some(keyword => bodyUpper.includes(keyword));
        
        // Check for re-subscribe keywords
        const resubscribeKeywords = ['START', 'SUBSCRIBE', 'YES', 'OPT IN', 'OPTIN'];
        const isResubscribeRequest = resubscribeKeywords.some(keyword => bodyUpper.includes(keyword));
        
        if (isUnsubscribeRequest) {
            // Find contact by phone number
            const contacts = await getAccountContacts(accountId);
            const normalizedFrom = From.replace(/\D/g, '');
            const contact = contacts.find(c => {
                const cPhone = (c.phone || '').replace(/\D/g, '');
                return cPhone && normalizedFrom && cPhone === normalizedFrom;
            });
            
            if (contact) {
                ensureCommunicationPreferences(contact);
                contact.communicationPreferences.sms = {
                    subscribed: false,
                    unsubscribedAt: new Date().toISOString(),
                    unsubscribeReason: 'SMS reply: ' + Body,
                    unsubscribeMethod: 'reply'
                };
                
                // Update contacts
                const contactIndex = contacts.findIndex(c => c.id === contact.id);
                if (contactIndex !== -1) {
                    contacts[contactIndex] = contact;
                    await updateAccountContacts(accountId, contacts);
                }
                
                // Log unsubscribe event
                await logUnsubscribeEvent(accountId, {
                    contactId: contact.id,
                    contactName: `${contact.firstName || ''} ${contact.lastName || ''}`.trim() || 'Unknown',
                    contactEmail: contact.email || null,
                    contactPhone: contact.phone || null,
                    channel: 'sms',
                    reason: 'SMS reply: ' + Body,
                    method: 'reply',
                    ipAddress: req.ip || req.headers['x-forwarded-for'] || 'unknown',
                    userAgent: req.headers['user-agent'] || 'unknown'
                });
                
                smsResponse.responseType = 'opt_out';

                // Send confirmation message (twilioClient is already defined at top of file)
                try {
                    await twilioClient.messages.create({
                        body: "You've been unsubscribed from SMS messages. Reply START to re-subscribe.",
                        to: From,
                        from: To
                    });
                } catch (twilioError) {
                    console.error('Error sending unsubscribe confirmation:', twilioError);
                }
            }
        } else if (isResubscribeRequest) {
            // Find contact by phone number
            const contacts = await getAccountContacts(accountId);
            const normalizedFrom = From.replace(/\D/g, '');
            const contact = contacts.find(c => {
                const cPhone = (c.phone || '').replace(/\D/g, '');
                return cPhone && normalizedFrom && cPhone === normalizedFrom;
            });
            
            if (contact) {
                ensureCommunicationPreferences(contact);
                contact.communicationPreferences.sms = {
                    subscribed: true,
                    unsubscribedAt: null,
                    unsubscribeReason: null,
                    unsubscribeMethod: null
                };
                
                // Update contacts
                const contactIndex = contacts.findIndex(c => c.id === contact.id);
                if (contactIndex !== -1) {
                    contacts[contactIndex] = contact;
                    await updateAccountContacts(accountId, contacts);
                }
                
                smsResponse.responseType = 'opt_in';

            }
        }
        
        // Try to link to existing campaign by phone number
        const smsCampaignsPath = path.join(sharedDataPath, 'sms-campaigns.json');
        if (fs.existsSync(smsCampaignsPath)) {
            const smsCampaigns = JSON.parse(fs.readFileSync(smsCampaignsPath, 'utf8'));
            const relatedCampaign = smsCampaigns.find(campaign => 
                campaign.to && campaign.to.includes(From) &&
                new Date(campaign.timestamp) > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Within last 7 days
            );
            if (relatedCampaign) {
                smsResponse.campaignId = relatedCampaign.id;
            }
        }
        
        smsResponses.push(smsResponse);
        await fsPromises.writeFile(smsResponsesPath, JSON.stringify(smsResponses, null, 2), 'utf8');

        // Return TwiML response
        res.set('Content-Type', 'text/xml');
        res.send('<Response></Response>');
    } catch (error) {
        console.error('SMS webhook error:', error);
        res.set('Content-Type', 'text/xml');
        res.send('<Response></Response>');
    }
});

// Twilio delivery status callback endpoint
app.post('/api/webhooks/status/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const { MessageSid, MessageStatus } = req.body || {};
    if (!MessageSid || !MessageStatus) {
      return res.status(200).send('OK');
    }
    const user = await findUserById(userId);
    if (!user) return res.status(200).send('OK');
    // Get SMS messages from shared-data
    const accountId = user.accountId || user.id;
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
    
    if (!fs.existsSync(smsMessagesPath)) {
      return res.status(200).send('OK');
    }
    
    const data = await fsPromises.readFile(smsMessagesPath, 'utf8');
    const smsMessages = JSON.parse(data);
    
    const msg = smsMessages.find(m => m.externalId === MessageSid);
    if (msg) {
      msg.status = MessageStatus;
      if (!msg.timestamp) msg.timestamp = new Date().toISOString();
      await fsPromises.writeFile(smsMessagesPath, JSON.stringify(smsMessages, null, 2), 'utf8');
    }
    res.status(200).send('OK');
  } catch (e) {
    res.status(200).send('OK');
  }
});

// SMS link click tracking redirect
app.get('/t/:userId/:token', async (req, res) => {
  try {
    const { userId, token } = req.params;
    const user = await findUserById(userId);
    if (!user) {
      return res.redirect('/');
    }
    
    // Get SMS messages from shared-data
    const accountId = user.accountId || user.id;
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
    
    if (!fs.existsSync(smsMessagesPath)) {
      return res.redirect('/');
    }
    
    const data = await fsPromises.readFile(smsMessagesPath, 'utf8');
    const smsMessages = JSON.parse(data);
    
    // Find the message that contains this token
    const msg = smsMessages.find(m => Array.isArray(m.linkTokens) && m.linkTokens.some(t => t.token === token));
    if (!msg) {
      return res.redirect('/');
    }
    const tokenEntry = msg.linkTokens.find(t => t.token === token);
    const targetUrl = tokenEntry?.url || '/';
    
    // Record click
    if (!Array.isArray(msg.linkClicks)) msg.linkClicks = [];
    msg.linkClicks.push({
      token,
      url: targetUrl,
      clickedAt: new Date().toISOString(),
      ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress,
      userAgent: req.headers['user-agent'] || ''
    });
    
    await fsPromises.writeFile(smsMessagesPath, JSON.stringify(smsMessages, null, 2), 'utf8');
    
    // Redirect to original URL
    res.redirect(targetUrl);
  } catch (e) {
    res.redirect('/');
  }
});

// Add endpoint to configure webhook URL for phone numbers
app.post('/api/numbers/:numberId/configure-webhook', auth, async (req, res) => {
    try {
        const { numberId } = req.params;
        const user = await findUserById(req.user.id);
        
        if (!user) {
            throw new Error('User not found');
        }

        // Get phone numbers from shared-data
        const accountId = user.accountId || user.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const phoneNumbersPath = path.join(sharedDataPath, 'phoneNumbers.json');
        
        let phoneNumbers = [];
        if (fs.existsSync(phoneNumbersPath)) {
            const phoneNumbersData = JSON.parse(fs.readFileSync(phoneNumbersPath, 'utf8'));
            phoneNumbers = phoneNumbersData;
        }
        
        const phoneNumber = phoneNumbers.find(n => n.id === numberId);
        if (!phoneNumber) {
            throw new Error('Phone number not found');
        }

        // Configure webhook URL in Twilio
        const webhookUrl = `${BASE_URL}/api/webhooks/sms/${req.user.id}`;
        
        await twilioClient.incomingPhoneNumbers(phoneNumber.id)
            .update({
                smsUrl: webhookUrl,
                smsMethod: 'POST',
                statusCallback: `${BASE_URL}/api/webhooks/status/${req.user.id}`,
                statusCallbackMethod: 'POST'
            });

        res.json({ 
            success: true, 
            message: 'Webhook configured successfully',
            webhookUrl: webhookUrl
        });
    } catch (error) {
        console.error('Webhook configuration error:', error);
        res.status(400).json({ error: error.message });
    }
});

const processScheduledMessages = async () => {
    try {
        const db = await readDB();
        const now = new Date();
        
        if (!db.scheduledMessages) return;

        for (const message of db.scheduledMessages) {
            if (message.status === 'pending' && new Date(message.nextRun) <= now) {
                try {
                    // Send the message
                    if (message.type === 'sms') {
                        await sendSMS(message);
                    } else {
                        // Get user for email sending
                        const user = await findUserById(message.userId);
                        await sendEmail(message, user);
                        await writeIndividualUserFile(message.userId, user);
                    }

                    // Update message status
                    message.status = 'sent';
                    message.lastRun = now;

                    // Calculate next run if recurring
                    if (message.scheduling.type === 'recurring') {
                        message.nextRun = calculateNextRunTime(message.scheduling.recurring);
                        if (message.scheduling.recurring.endDate && 
                            new Date(message.scheduling.recurring.endDate) < message.nextRun) {
                            message.status = 'completed';
                        }
                    } else {
                        message.status = 'completed';
                    }
                } catch (error) {
                    console.error('Failed to process scheduled message:', error);
                    message.status = 'failed';
                    message.error = error.message;
                }
            }
        }

        // Clean up completed/failed messages older than 30 days
        const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
        db.scheduledMessages = db.scheduledMessages.filter(message => 
            message.status === 'pending' || 
            new Date(message.lastRun) > thirtyDaysAgo
        );

        await writeDB(db);
    } catch (error) {
        console.error('Error processing scheduled messages:', error);
    }
};

// Helper function to calculate next run time for recurring messages
const calculateNextRunTime = (recurring) => {
    const now = new Date();
    let nextRun = new Date();
    const [hours, minutes] = recurring.time.split(':');
    
    nextRun.setHours(parseInt(hours), parseInt(minutes), 0, 0);

    if (recurring.frequency === 'daily') {
        if (nextRun <= now) {
            nextRun.setDate(nextRun.getDate() + 1);
        }
    } else if (recurring.frequency === 'weekly') {
        const currentDay = nextRun.getDay();
        const days = recurring.days.map(day => ['SUN','MON','TUE','WED','THU','FRI','SAT'].indexOf(day));
        const nextDay = days.find(day => day > currentDay) || days[0];
        
        if (nextDay <= currentDay || (nextDay === currentDay && nextRun <= now)) {
            nextRun.setDate(nextRun.getDate() + (7 - currentDay + nextDay));
        } else {
            nextRun.setDate(nextRun.getDate() + (nextDay - currentDay));
        }
    }

    return nextRun;
};
// Background schedulers (DISABLED in staging)
const IS_STAGING = process.env.IS_STAGING === 'true';

// Start the scheduler + background jobs (only if NOT staging)
if (IS_STAGING) {
  console.log('[STAGING] Background schedulers disabled.');
} else {
  // Start the scheduler
  setInterval(processScheduledMessages, 60000); // Check every minute
}

// Scheduled email queue processing (runs every hour to check for queued emails)
const processEmailQueues = async () => {
  if (process.env.IS_STAGING === 'true') {
    console.log('[STAGING] Skipping processEmailQueues()');
    return;
  }
    try {
        console.log('[EMAIL-QUEUE] Starting scheduled queue processing...');
        const sharedDataDir = path.join(__dirname, 'data', 'shared-data');
        
        if (!fs.existsSync(sharedDataDir)) {
            return;
        }
        
        const accountDirs = fs.readdirSync(sharedDataDir).filter(f => {
            const accountPath = path.join(sharedDataDir, f);
            return fs.statSync(accountPath).isDirectory();
        });
        
        let totalProcessed = 0;
        let totalSent = 0;
        let totalSkipped = 0;
        let totalPending = 0;
        
        for (const accountDir of accountDirs) {
            try {
                const accountId = accountDir;
                const queue = await getEmailQueue(accountId);
                
                if (queue.length === 0) {
                    continue;
                }
                
                const pendingCount = queue.filter(e => e.status === 'pending').length;
                totalPending += pendingCount;
                
                if (pendingCount === 0) {
                    continue;
                }
                
                // Get unique domains from pending queue entries
                const pendingDomains = [...new Set(
                    queue
                        .filter(e => e.status === 'pending')
                        .map(e => e.domain)
                )];
                
                for (const domain of pendingDomains) {
                    try {
                        const result = await processEmailQueue(accountId, domain);
                        totalProcessed += result.processed || 0;
                        totalSent += result.sent || 0;
                        totalSkipped += result.skipped || 0;
                    } catch (error) {
                        console.error(`[EMAIL-QUEUE] Error processing queue for account ${accountId}, domain ${domain}:`, error.message);
                    }
                }
            } catch (error) {
                console.error(`[EMAIL-QUEUE] Error processing queue for account ${accountDir}:`, error.message);
            }
        }
        
        // Always log completion status for visibility
        if (totalPending > 0) {
            console.log(`[EMAIL-QUEUE] Scheduled processing complete: ${totalProcessed} entries processed, ${totalSent} emails sent, ${totalSkipped} entries skipped (no capacity), ${totalPending} total pending entries across all accounts`);
        } else {
            console.log(`[EMAIL-QUEUE] Scheduled processing complete: No pending entries found across all accounts`);
        }
    } catch (error) {
        console.error('[EMAIL-QUEUE] Error in scheduled queue processing:', error);
    }
};

// Process email queues every 15 minutes to check for available capacity
// Wrap in try-catch to prevent unhandled promise rejections from stopping the interval
if (IS_STAGING) {
  console.log('[STAGING] Background schedulers disabled (email queue).');
} else {
  setInterval(() => {
    processEmailQueues().catch(error => {
      console.error('[EMAIL-QUEUE] Unhandled error in scheduled queue processing interval:', error);
    });
  }, 15 * 60 * 1000); // Every 15 minutes

  // Also process immediately on startup (after 30 seconds to let server fully start)
  setTimeout(() => {
    processEmailQueues().catch(error => {
      console.error('[EMAIL-QUEUE] Unhandled error in startup queue processing:', error);
    });
  }, 30000);
}

// Scheduled cleanup for old trash entries (runs daily at 2 AM)
const cleanupOldTrashEntries = async () => {
  try {

    // Get all user IDs
    const userIds = await getAllUserIds();
    let totalCleaned = 0;
    
    for (const userId of userIds) {
      try {
        const result = await cleanupOldTrash(userId);
        if (result && result.cleanedCount > 0) {
          totalCleaned += result.cleanedCount;

        }
      } catch (error) {
        console.error(`Error cleaning trash for user ${userId}:`, error);
      }
    }
    
    if (totalCleaned > 0) {

    }
  } catch (error) {
    console.error('Error in scheduled trash cleanup:', error);
  }
};

// Run cleanup every 24 hours (86400000 ms)
if (!IS_STAGING) {
  setInterval(cleanupOldTrashEntries, 86400000);

  // Run initial cleanup on startup (after 5 seconds to let server fully start)
  setTimeout(cleanupOldTrashEntries, 5000);
}

// Add this endpoint before the server.listen call
app.post('/api/admin/initialize-system-sender', adminAuth, async (req, res) => {
  try {
    const result = await initializeSystemSender();
    res.json({ 
      success: true, 
      message: 'System sender initialized successfully',
      result 
    });
  } catch (error) {
    console.error('Error initializing system sender:', error);
    res.status(500).json({ error: error.message });
  }
});

// ==========================
// AI Calling (Phase 1 - MVP)
// ==========================
const activeVoiceSessions = new Map(); // CallSid -> { turns: [...], createdAt }

function ensureVoiceStructures(user) {
  if (!user.voiceAgents) user.voiceAgents = [];
  if (!user.voiceCampaigns) user.voiceCampaigns = [];
  // voiceCalls now stored in shared files, not user object
}

// Agents CRUD
app.get('/api/voice/agents', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    ensureVoiceStructures(user);
    res.json(user.voiceAgents);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Available voices (curated list supported by Twilio Polly voices)
app.get('/api/voice/voices', auth, async (req, res) => {
  try {
    const voices = [
      // English US - Most popular
      { id: 'Polly.Joanna', label: 'Joanna - Female (US)', voice: 'Polly.Joanna', language: 'en-US', gender: 'female', accent: 'US' },
      { id: 'Polly.Matthew', label: 'Matthew - Male (US)', voice: 'Polly.Matthew', language: 'en-US', gender: 'male', accent: 'US' },
      
      // French Canadian - For Canadian market
      { id: 'Polly.Chantal', label: 'Chantal - Female (French Canadian)', voice: 'Polly.Chantal', language: 'fr-CA', gender: 'female', accent: 'Canadian French' },
      { id: 'Polly.Gabriel', label: 'Gabriel - Male (French Canadian)', voice: 'Polly.Gabriel', language: 'fr-CA', gender: 'male', accent: 'Canadian French' },
      
      // English British - Professional alternative
      { id: 'Polly.Emma', label: 'Emma - Female (British)', voice: 'Polly.Emma', language: 'en-GB', gender: 'female', accent: 'British' },
      { id: 'Polly.Brian', label: 'Brian - Male (British)', voice: 'Polly.Brian', language: 'en-GB', gender: 'male', accent: 'British' },
      
      // Basic fallback voices
      { id: 'alice', label: 'Alice - Generic Female', voice: 'alice', language: 'en-US', gender: 'female', accent: 'Generic' },
      { id: 'man', label: 'Generic Male Voice', voice: 'man', language: 'en-US', gender: 'male', accent: 'Generic' }
    ];
    res.json(voices);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Available languages (prioritizing Canadian languages)
app.get('/api/voice/languages', auth, async (req, res) => {
  try {
    const languages = [
      { code: 'en-CA', label: 'English (Canada)' },
      { code: 'fr-CA', label: 'FranÃ§ais (Canada)' },
      { code: 'en-US', label: 'English (United States)' },
      { code: 'fr-FR', label: 'FranÃ§ais (France)' },
      { code: 'en-GB', label: 'English (United Kingdom)' },
      { code: 'en-AU', label: 'English (Australia)' },
      { code: 'es-ES', label: 'EspaÃ±ol (EspaÃ±a)' },
      { code: 'es-MX', label: 'EspaÃ±ol (MÃ©xico)' },
      { code: 'pt-BR', label: 'PortuguÃªs (Brasil)' },
      { code: 'de-DE', label: 'Deutsch (Deutschland)' },
      { code: 'it-IT', label: 'Italiano (Italia)' },
      { code: 'ja-JP', label: 'æ—¥æœ¬èªž (Japan)' },
      { code: 'ko-KR', label: 'í•œêµ­ì–´ (Korea)' },
      { code: 'zh-CN', label: 'ä¸­æ–‡ (China)' }
    ];
    res.json(languages);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/voice/agents', auth, async (req, res) => {
  try {
    const { name, systemPrompt, greeting, voice, language, prompt } = req.body || {};
    if (!name && !prompt) throw new Error('Please provide a prompt');
    const user = await findUserById(req.user.id);
    ensureVoiceStructures(user);
    const agent = {
      id: Date.now().toString(),
      name: name || `AI Agent ${new Date().toISOString()}`,
      // If simplified "prompt" is provided, use it as greeting; fall back to existing fields if present
      greeting: (prompt && String(prompt).trim()) || (greeting || 'Hello.'),
      // Provide a sane default system prompt for simplified mode
      systemPrompt: systemPrompt || 'You are a friendly, concise campaign assistant. Speak clearly and keep calls brief and respectful. If the user asks to stop, end the call politely.',
      voice: voice || 'Polly.Joanna',
      language: language || 'en-US',
      // Keep optional advanced fields internal with defaults
      maxTurns: 6,
      endPhrases: [],
      transferNumber: null,
      createdAt: new Date().toISOString()
    };
    user.voiceAgents.push(agent);
    await writeIndividualUserFile(req.user.id, user);
    res.json(agent);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.delete('/api/voice/agents/:agentId', auth, async (req, res) => {
  try {
    const { agentId } = req.params;
    const user = await findUserById(req.user.id);
    ensureVoiceStructures(user);
    user.voiceAgents = user.voiceAgents.filter(a => a.id !== agentId);
    await writeIndividualUserFile(req.user.id, user);
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Campaigns
app.get('/api/voice/campaigns', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    
    // Read from shared-data folder
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const campaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
    
    let campaigns = [];
    if (fs.existsSync(campaignsPath)) {
      campaigns = JSON.parse(await fsPromises.readFile(campaignsPath, 'utf8'));
      // Filter campaigns for team members
      if (user.userType !== 'account_holder' && user.userType !== 'app_owner') {
        campaigns = campaigns.filter(c => c.userId === user.id);
      }
    }
    
    res.json(campaigns);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/voice/campaigns', auth, async (req, res) => {
  try {
    const { name, agentId, contactIds = [], concurrencyLimit = 2 } = req.body || {};
    if (!name || !agentId || !Array.isArray(contactIds) || contactIds.length === 0) {
      throw new Error('Missing required fields');
    }
    const user = await findUserById(req.user.id);
    ensureVoiceStructures(user);
    const agent = user.voiceAgents.find(a => a.id === agentId);
    if (!agent) throw new Error('Agent not found');
    const campaign = {
      id: Date.now().toString(),
      name,
      agentId,
      contactIds,
      status: 'created',
      concurrencyLimit: Number(concurrencyLimit) || 2,
      createdAt: new Date().toISOString()
    };
    user.voiceCampaigns.push(campaign);
    await writeIndividualUserFile(req.user.id, user);
    res.json(campaign);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Simplified direct campaign start - no complex agents needed
app.post('/api/campaigns/start', auth, async (req, res) => {
  try {
    const { voice, language, campaignName, message, contactIds } = req.body || {};
    
    if (!voice) throw new Error('Voice is required');
    if (!language) throw new Error('Language is required');
    if (!message || !message.trim()) throw new Error('Message is required');
    if (!Array.isArray(contactIds) || contactIds.length === 0) throw new Error('At least one contact is required');

    // Generate campaign ID
    const campaignId = Date.now().toString();
    
    const user = await findUserById(req.user.id);
    ensureVoiceStructures(user);
    
    // Get phone numbers from shared-data
    const sharedDataPath = path.join(SHARED_DATA_DIR, user.accountId || user.id);
    const phoneNumbersPath = path.join(sharedDataPath, 'phoneNumbers.json');
    let phoneNumbers = [];
    if (fs.existsSync(phoneNumbersPath)) {
      phoneNumbers = JSON.parse(fs.readFileSync(phoneNumbersPath, 'utf8'));
    }
    if (!phoneNumbers || phoneNumbers.length === 0) {
      throw new Error('No phone numbers available for calling. Please add a phone number first.');
    }
    const fromNumber = (phoneNumbers.find(n => n.isDefault) || phoneNumbers[0]).number;
    
    // Check tokens - 1 AI token per call
    const requiredTokens = contactIds.length;
    const accountId = user.accountId || user.id;
    
    // All users now use shared account tokens
    const accountTokens = await getAccountTokens(accountId);
    const currentAi = Number(accountTokens.aiTokens || 0);
    
    if (currentAi < requiredTokens) {
      throw new Error(`Insufficient AI tokens. Required: ${requiredTokens}, Available: ${currentAi}. Purchase AI Call Tokens to start calls.`);
    }
    
    // Auto-translate message if needed
    const fetch = require('node-fetch');
    const targetLanguageCode = language.split('-')[0]; // e.g., 'fr' from 'fr-CA'
    let finalMessage = message.trim();
    
    if (targetLanguageCode !== 'en') {
      try {

        const translateResponse = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(finalMessage)}&langpair=en|${targetLanguageCode}`, {
          method: 'GET',
          headers: { 'User-Agent': 'Campaign Builder' }
        });
        
        if (translateResponse.ok) {
          const result = await translateResponse.json();
          if (result.responseStatus === 200 && result.responseData && result.responseData.translatedText) {
            finalMessage = result.responseData.translatedText;

          }
        }
      } catch (translationError) {
        console.warn('Campaign translation failed, using original text:', translationError.message);
      }
    }
    
    // Campaign already created and saved above
    
    // Get contacts from shared-data structure
    const accountContacts = await getAccountContacts(user.accountId || user.id);
    
    // Create campaign first and save it
    const campaign = {
      id: campaignId,
      name: campaignName,
      message: finalMessage,
      voice: voice,
      language: language,
      status: 'running',
      startedAt: new Date().toISOString(),
      timestamp: new Date().toISOString(),
      recipientCount: contactIds.length,
      completedCalls: 0,
      failedCalls: 0
    };
    
    // Save campaign to shared-data structure (using existing sharedDataPath)
    const voiceCampaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
    let voiceCampaigns = [];
    
    if (fs.existsSync(voiceCampaignsPath)) {
      try {
        voiceCampaigns = JSON.parse(fs.readFileSync(voiceCampaignsPath, 'utf8'));
      } catch (error) {
        console.error('Error reading voice campaigns:', error);
      }
    }
    
    voiceCampaigns.push(campaign);
    await fsPromises.writeFile(voiceCampaignsPath, JSON.stringify(voiceCampaigns, null, 2), 'utf8');

    // Queue calls for all contacts
    let successfulCalls = 0;
    let failedCalls = 0;
    
    for (const contactId of contactIds) {
      const contact = accountContacts.find(c => c.id === contactId);
      if (!contact || !contact.phone) {

        failedCalls++;
        continue;
      }
      
      // Format phone number for Twilio (convert to E.164 format)
      let twilioPhone = contact.phone.replace(/\D/g, ''); // Remove all non-digits
      
      // Add +1 prefix for North American numbers if not present
      if (twilioPhone.length === 10) {
        twilioPhone = '+1' + twilioPhone;
      } else if (twilioPhone.length === 11 && twilioPhone[0] === '1') {
        twilioPhone = '+' + twilioPhone;
      } else if (!twilioPhone.startsWith('+')) {
        twilioPhone = '+1' + twilioPhone;
      }
      
      // Validate phone number format
      if (!twilioPhone || twilioPhone.length < 10) {
        console.error(`Invalid phone number format: ${contact.phone} â†’ ${twilioPhone}`);
        failedCalls++;
        continue;
      }
      
      // Check if user has phone numbers available
      if (!fromNumber) {
        console.error(`No phone number available for user ${req.user.id}`);
        failedCalls++;
        continue;
      }
      
      try {
        const twimlUrl = `${BASE_URL}/api/voice/twiml/direct/${req.user.id}/${campaignId}?contactId=${encodeURIComponent(contact.id)}`;

        // Skip URL testing for now to focus on the core issue
        
        const call = await twilioClient.calls.create({
          to: twilioPhone,
          from: fromNumber,
          url: twimlUrl,
          statusCallback: `${BASE_URL}/api/voice/status/${req.user.id}?campaignId=${campaignId}`,
          statusCallbackMethod: 'POST'
        });

        // Check if the call was created but has an error status
        if (call.status === 'failed' || call.status === 'busy' || call.status === 'no-answer') {
          console.error(`Call created but immediately failed with status: ${call.status}`);
          throw new Error(`Call failed immediately with status: ${call.status}`);
        }
        
        // Track call in shared-data structure
        const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');
        let voiceCalls = [];
        
        if (fs.existsSync(voiceCallsPath)) {
          const data = await fsPromises.readFile(voiceCallsPath, 'utf8');
          voiceCalls = JSON.parse(data);
        }
        
        voiceCalls.push({
          id: call.sid,
          campaignId: campaignId,
          campaignName: campaign.name, // Add campaign name for notifications
          contactId: contact.id,
          to: twilioPhone,
          originalPhone: contact.phone,
          status: 'initiated',
          startedAt: new Date().toISOString(),
          contactName: `${contact.firstName || ''} ${contact.lastName || ''}`.trim(),
          message: finalMessage // Add message for notifications context
        });
        
        await fsPromises.writeFile(voiceCallsPath, JSON.stringify(voiceCalls, null, 2), 'utf8');
        
        successfulCalls++;
        
      } catch (callError) {
        console.error(`Failed to initiate call to ${contact.phone}: ${callError.message}`);
        failedCalls++;
        
        // Track failed call in shared-data structure
        const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');
        let voiceCalls = [];
        
        if (fs.existsSync(voiceCallsPath)) {
          const data = await fsPromises.readFile(voiceCallsPath, 'utf8');
          voiceCalls = JSON.parse(data);
        }
        
        voiceCalls.push({
          id: `failed_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          campaignId: campaignId,
          campaignName: campaign.name, // Add campaign name for notifications
          contactId: contact.id,
          to: twilioPhone,
          originalPhone: contact.phone,
          status: 'failed',
          startedAt: new Date().toISOString(),
          contactName: `${contact.firstName || ''} ${contact.lastName || ''}`.trim(),
          message: finalMessage, // Add message for notifications context
          error: callError.message,
          errorCode: callError.code
        });
        
        await fsPromises.writeFile(voiceCallsPath, JSON.stringify(voiceCalls, null, 2), 'utf8');
      }
    }
    
    // Update campaign with results
    campaign.completedCalls = successfulCalls;
    campaign.failedCalls = failedCalls;
    campaign.deliveredCount = successfulCalls; // For dashboard compatibility
    campaign.failedCount = failedCalls; // For dashboard compatibility
    campaign.bouncedCount = failedCalls; // For dashboard compatibility
    if (successfulCalls === 0) {
      campaign.status = 'failed';
      if (failedCalls > 0) {
        await logAuditEvent(req.user.id, 'FAILED_BULK_AI', { accountId: user.accountId || user.id, failedCount: failedCalls, recipientCount: contactIds.length });
      }
    } else if (successfulCalls === contactIds.length) {
      campaign.status = 'completed';
    }
    
    // Update campaign in shared-data structure
    const updatedVoiceCampaigns = voiceCampaigns.map(c => c.id === campaignId ? campaign : c);
    await fsPromises.writeFile(voiceCampaignsPath, JSON.stringify(updatedVoiceCampaigns, null, 2), 'utf8');
    
    // Deduct tokens only for successful calls
    if (successfulCalls > 0) {
      // All users now use shared account tokens
      const accountId = user.accountId || user.id;
      await deductAccountTokens(accountId, 'aiTokens', successfulCalls);

    }
    
    res.json({ 
      success: true, 
      campaignId,
      totalCalls: contactIds.length,
      successfulCalls,
      failedCalls,
      message: `Campaign started! ${successfulCalls} calls queued successfully.`
    });
    
  } catch (error) {
    console.error('Start direct voice campaign error:', error);
    res.status(400).json({ 
      error: error.message || 'Campaign failed to start. Please try again.' 
    });
  }
});

app.get('/api/voice/campaigns/:campaignId/calls', auth, async (req, res) => {
  try {
    const { campaignId } = req.params;
    const user = await findUserById(req.user.id);
    ensureVoiceStructures(user);
    
    // Get calls from shared files
    const accountId = user.accountId || user.id;
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');
    
    let calls = [];
    if (fs.existsSync(voiceCallsPath)) {
      try {
        calls = JSON.parse(fs.readFileSync(voiceCallsPath, 'utf8'));
      } catch (error) {
        console.error('Error reading voice calls:', error);
      }
    }
    
    const campaignCalls = calls.filter(c => c.campaignId === campaignId).slice(-200);
    res.json(campaignCalls);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.get('/api/voice/monitor', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    ensureVoiceStructures(user);
    
    // Get calls from shared files
    const accountId = user.accountId || user.id;
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');
    
    let calls = [];
    if (fs.existsSync(voiceCallsPath)) {
      try {
        calls = JSON.parse(fs.readFileSync(voiceCallsPath, 'utf8'));
      } catch (error) {
        console.error('Error reading voice calls:', error);
      }
    }
    
    const recent = calls.filter(c => c.endedAt || c.status === 'completed' || c.status === 'failed').slice(-50);
    const active = calls.filter(c => !c.endedAt && (c.status === 'initiated' || c.status === 'in-progress')).slice(-50);
    res.json({ active, recent, serverTime: new Date().toISOString() });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Twilio Voice status callback
app.post('/api/voice/status/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const { CallSid, CallStatus, To, CallDuration, Direction, From, ToCountry, FromCountry, CallerCountry, ToState, FromState, CallerState, ToCity, FromCity, CallerCity, ToZip, FromZip, CallerZip, ErrorCode, ErrorUrl } = req.body || {};

    const user = await findUserById(userId);
    ensureVoiceStructures(user);
    
    // Use shared files for call tracking
    const accountId = user.accountId || user.id;
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');
    
    let calls = [];
    if (fs.existsSync(voiceCallsPath)) {
      try {
        calls = JSON.parse(fs.readFileSync(voiceCallsPath, 'utf8'));
      } catch (error) {
        console.error('Error reading voice calls:', error);
      }
    }
    
    let call = calls.find(c => c.id === CallSid || c.callSid === CallSid) || calls.find(c => c.to === To && !c.endedAt);
    if (!call) {
      call = { 
        id: CallSid || Date.now().toString(), 
        callSid: CallSid, 
        to: To, 
        status: CallStatus || 'unknown', 
        startedAt: new Date().toISOString() 
      };
      calls.push(call);
    }
    
    call.callSid = CallSid || call.callSid;
    call.status = CallStatus || call.status;
    if (CallDuration) call.duration = CallDuration;
    if (ErrorCode) call.errorCode = ErrorCode;
    if (ErrorUrl) call.errorUrl = ErrorUrl;
    
    if (CallStatus === 'completed' || CallStatus === 'failed' || CallStatus === 'busy' || CallStatus === 'no-answer') {
      call.endedAt = new Date().toISOString();
    }
    
    // Update calls in shared files
    await fsPromises.writeFile(voiceCallsPath, JSON.stringify(calls, null, 2), 'utf8');
    
    // Update campaign analytics when call status changes
    if (call.campaignId && (CallStatus === 'completed' || CallStatus === 'failed' || CallStatus === 'busy' || CallStatus === 'no-answer')) {
      
      // Update campaign in shared-data structure (reuse existing data)
      const voiceCampaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
      
      let campaigns = [];
      
      // Read current campaigns
      if (fs.existsSync(voiceCampaignsPath)) {
        try {
          campaigns = JSON.parse(fs.readFileSync(voiceCampaignsPath, 'utf8'));
        } catch (error) {
          console.error('Error reading voice campaigns for update:', error);
        }
      }
      
      const campaign = campaigns.find(c => c.id === call.campaignId);
      if (campaign) {
        // Recalculate campaign stats from shared-data calls
        const campaignCalls = calls.filter(c => c.campaignId === call.campaignId);
        const completedCalls = campaignCalls.filter(c => 
          c.status === 'completed' || c.status === 'busy' || c.status === 'no-answer'
        ).length;
        const failedCalls = campaignCalls.filter(c => c.status === 'failed').length;
        const deliveredCalls = campaignCalls.filter(c => c.status === 'completed').length;
        const busyCalls = campaignCalls.filter(c => c.status === 'busy').length;
        const noAnswerCalls = campaignCalls.filter(c => c.status === 'no-answer').length;

        // Update campaign analytics
        campaign.completedCalls = completedCalls;
        campaign.failedCalls = failedCalls;
        campaign.deliveredCount = deliveredCalls; // For dashboard compatibility
        campaign.failedCount = failedCalls; // For dashboard compatibility
        campaign.bouncedCount = failedCalls; // For dashboard compatibility
        campaign.busyCount = busyCalls;
        campaign.noAnswerCount = noAnswerCalls;
        
        // Check if campaign is complete
        const inProgressCalls = campaignCalls.filter(c => 
          c.status === 'initiated' || c.status === 'ringing' || c.status === 'in-progress'
        ).length;
        
        if (inProgressCalls === 0 && campaignCalls.length > 0) {
          campaign.status = 'completed';
          campaign.completedAt = new Date().toISOString();
        }
        
        // Save updated campaign back to shared-data
        try {
          await fsPromises.writeFile(voiceCampaignsPath, JSON.stringify(campaigns, null, 2));

        } catch (error) {
          console.error('Error saving updated campaign:', error);
        }
      } else {

      }
    }
    
    await writeIndividualUserFile(userId, user);
    res.status(200).send('OK');
  } catch (error) {
    res.status(200).send('OK');
  }
});

// Test Twilio account capabilities
app.get('/api/voice/test-account', auth, async (req, res) => {
  try {
    // Get account info to check capabilities
    const account = await twilioClient.api.accounts(process.env.TWILIO_ACCOUNT_SID).fetch();
    
    // Get verified caller IDs
    const callerIds = await twilioClient.outgoingCallerIds.list();
    
    // Get available phone numbers for the account
    const phoneNumbers = await twilioClient.incomingPhoneNumbers.list();
    
    res.json({
      account: {
        friendlyName: account.friendlyName,
        status: account.status,
        type: account.type
      },
      verifiedCallerIds: callerIds.map(c => ({ phoneNumber: c.phoneNumber, friendlyName: c.friendlyName })),
      ownedNumbers: phoneNumbers.map(n => ({ phoneNumber: n.phoneNumber, friendlyName: n.friendlyName })),
      capabilities: {
        canMakeVoiceCalls: account.status === 'active',
        hasPhoneNumbers: phoneNumbers.length > 0
      }
    });
  } catch (error) {
    console.error('Twilio account test error:', error);
    res.status(400).json({ error: error.message, code: error.code });
  }
});

// Generate voice preview audio using Amazon Polly directly (no call placed)
app.post('/api/voice/preview-audio', auth, async (req, res) => {
  try {
    const { voice, language, text } = req.body || {};
    if (!text) throw new Error('Text is required for voice preview');

    // Generate TwiML that would be used in actual call
    const finalVoice = voice || 'Polly.Joanna';
    const finalLanguage = language || 'en-US';
    let finalText = text.trim();
    
    // Auto-translate text if language doesn't match input language
    const fetch = require('node-fetch');
    
    // Detect if translation is needed based on selected language
    const targetLanguageCode = finalLanguage.split('-')[0]; // e.g., 'fr' from 'fr-CA'

    if (targetLanguageCode !== 'en') {
      try {

        // Use MyMemory API (free translation service by Translated.net)
        const translateResponse = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(finalText)}&langpair=en|${targetLanguageCode}`, {
          method: 'GET',
          headers: { 'User-Agent': 'Campaign Builder' }
        });
        
        if (translateResponse.ok) {
          const result = await translateResponse.json();
          if (result.responseStatus === 200 && result.responseData && result.responseData.translatedText) {
            finalText = result.responseData.translatedText;

          } else {
            console.warn('Translation API returned no result, using original text');
          }
        } else {
          console.warn('Translation API failed, using original text');
        }
      } catch (translationError) {
        console.warn('Translation failed, using original text:', translationError.message);
        // Continue with original text if translation fails
      }
    }
    
    // Import AWS SDK for Polly
    const AWS = require('aws-sdk');
    
    // Configure AWS Polly - check for credentials
    if (!process.env.AWS_ACCESS_KEY_ID || !process.env.AWS_SECRET_ACCESS_KEY) {
      throw new Error('AWS credentials not configured. Please set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables.');
    }
    
    const polly = new AWS.Polly({
      region: process.env.AWS_REGION || 'us-east-1',
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
    });
    
    // Map Twilio voice names to Polly voice IDs (only verified working voices)
    const voiceMap = {
      'Polly.Joanna': 'Joanna',
      'Polly.Matthew': 'Matthew', 
      'Polly.Chantal': 'Chantal',
      'Polly.Emma': 'Emma',
      'Polly.Brian': 'Brian',
      'alice': 'Joanna', // fallback to Joanna for generic voices
      'man': 'Matthew'   // fallback to Matthew for generic voices
    };
    
    // Map language codes (Twilio format to Polly format)
    const languageMap = {
      'en-US': 'en-US',
      'en-CA': 'en-US', // Polly doesn't have en-CA, use en-US
      'en-GB': 'en-GB',
      'fr-CA': 'fr-CA',
      'fr-FR': 'fr-FR'
    };
    
    const pollyVoiceId = voiceMap[finalVoice] || 'Joanna';
    const pollyLanguageCode = languageMap[finalLanguage] || 'en-US';
    
    // Generate speech with Polly
    const pollyParams = {
      Text: finalText,
      OutputFormat: 'mp3',
      VoiceId: pollyVoiceId,
      LanguageCode: pollyLanguageCode
    };

    const pollyResult = await polly.synthesizeSpeech(pollyParams).promise();
    
    // Set response headers for audio streaming
    res.setHeader('Content-Type', 'audio/mpeg');
    res.setHeader('Content-Length', pollyResult.AudioStream.length);
    res.setHeader('Cache-Control', 'public, max-age=3600'); // Cache for 1 hour
    
    // Stream the audio directly to the response
    res.send(pollyResult.AudioStream);
    
  } catch (error) {
    console.error('Voice preview error:', error);
    res.status(400).json({ error: error.message || 'Voice preview failed. Please try again.' });
  }
});

// Quick voice sample call (costs 1 AI token, places actual call for testing)
app.post('/api/voice/quick-sample', auth, async (req, res) => {
  try {
    const { to, voice, language } = req.body || {};
    if (!to) throw new Error('Phone number required for actual voice call test');

    const user = await findUserById(req.user.id);
    if (!user) {
      throw new Error('User not found. Please try logging in again.');
    }
    
    if (!user.phoneNumbers || user.phoneNumbers.length === 0) {
      throw new Error('No phone numbers available. Please purchase a phone number first.');
    }
    
    // Check tokens (costs 1 AI token for actual call)
    let currentAi = Number(user.aiTokens || 0);
    
    // For team members, use shared account tokens
    if (user.userType !== 'app_owner' && user.accountId) {
      const accountTokens = await getAccountTokens(user.accountId);
      currentAi = Number(accountTokens.aiTokens || 0);
    }
    
    if (currentAi < 1) {
      throw new Error('Need 1 AI token for actual voice call test. Use the free preview button instead.');
    }
    
    const fromNumber = (user.phoneNumbers.find(n => n.isDefault) || user.phoneNumbers[0]).number;
    const sampleText = 'Hello! This is exactly how your AI voice agent will sound during campaign calls. This sample uses the actual Twilio voice system.';
    
    const call = await twilioClient.calls.create({
      to,
      from: fromNumber,
      url: `${BASE_URL}/api/voice/twiml/quick-sample?voice=${encodeURIComponent(voice || 'Polly.Joanna')}&language=${encodeURIComponent(language || 'en-US')}&text=${encodeURIComponent(sampleText)}`
    });
    
    // Deduct 1 AI token
    if (user.userType !== 'app_owner' && user.accountId) {
      // For team members, deduct from shared account tokens
      await deductAccountTokens(user.accountId, 'aiTokens', 1);
    } else {
      // For app owners, deduct from individual tokens
      user.aiTokens = currentAi - 1;
    }
    
    await writeIndividualUserFile(req.user.id, user);
    
    res.json({ success: true, message: 'Actual voice call test initiated', callSid: call.sid });
  } catch (error) {
    console.error('Voice sample error:', error);
    console.error('Full error details:', JSON.stringify(error, null, 2));
    
    // Handle specific Twilio errors
    if (error.code === 21216) {
      // Check if it's a geographic restriction or verification issue
      const { to } = req.body || {};
      const isCanadianNumber = to && to.includes('+1') && (to.includes('250') || to.includes('604') || to.includes('778') || to.includes('236'));
      
      if (isCanadianNumber) {
        res.status(400).json({ 
          error: 'ðŸ‡¨ðŸ‡¦ Canadian Number Issue - Try these solutions:\n\n1. Check Twilio Console for geographic calling restrictions\n2. Ensure international calling is enabled on your account\n3. Try with a US number if available\n4. Contact Twilio support about Canadian calling limitations\n\nError: Account not allowed to call this number (21216)',
          twilioError: true,
          errorCode: 21216
        });
      } else {
        res.status(400).json({ 
          error: 'âš ï¸ Calling Restricted - Number appears verified but blocked:\n\n1. Wait 5-10 minutes after verification\n2. Check for account calling restrictions in Twilio\n3. Try a different verified number\n4. Contact Twilio support\n\nError code: 21216',
          twilioError: true,
          errorCode: 21216
        });
      }
    } else if (error.message && error.message.includes('not allowed to call')) {
      res.status(400).json({ 
        error: 'Phone number not verified with Twilio. Please verify this number in your Twilio Console first, or upgrade to a paid Twilio account to call any number.',
        twilioError: true
      });
    } else {
      res.status(400).json({ error: error.message || 'Voice calling failed. Please try again.' });
    }
  }
});

// Voice sample preview: place a quick call to the user's phone with selected voice
app.post('/api/voice/preview', auth, async (req, res) => {
  try {
    const { to, voice, language, text } = req.body || {};
    if (!to) throw new Error('Missing destination number');
    const user = await findUserById(req.user.id);
    if (!user.phoneNumbers || user.phoneNumbers.length === 0) throw new Error('No phone numbers available');
    const fromNumber = (user.phoneNumbers.find(n => n.isDefault) || user.phoneNumbers[0]).number;
    const sayText = (text && String(text).trim()) || 'This is a sample of the selected voice for your campaign.';
  // Token requirement: 1 SMS token per sample call
  const currentAi = Number(user.aiTokens || 0);
  if (currentAi < 1) {
    throw new Error('Insufficient AI tokens to place a sample call. Please purchase AI Call Tokens.');
  }

    await twilioClient.calls.create({
      to,
      from: fromNumber,
      url: `${BASE_URL}/api/voice/twiml/preview?voice=${encodeURIComponent(voice || '')}&language=${encodeURIComponent(language || '')}&text=${encodeURIComponent(sayText)}`
    });
  user.aiTokens = currentAi - 1;
  await writeIndividualUserFile(req.user.id, user);
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// TwiML for voice sample preview

// Campaign preview audio using Amazon Polly directly (no call placed)
app.post('/api/voice/campaign-preview', auth, async (req, res) => {
  try {
    const { voice, language, prompt } = req.body || {};
    if (!prompt) throw new Error('Campaign prompt is required for preview');

    // Generate settings that match exactly what will be used in actual calls
    const finalVoice = voice || 'Polly.Joanna';
    const finalLanguage = language || 'en-CA';
    let finalPrompt = prompt.trim();
    
    // Auto-translate text if language doesn't match input language
    const fetch = require('node-fetch');
    
    // Detect if translation is needed based on selected language
    const targetLanguageCode = finalLanguage.split('-')[0]; // e.g., 'fr' from 'fr-CA'

    if (targetLanguageCode !== 'en') {
      try {

        // Use MyMemory API (free translation service by Translated.net)
        const translateResponse = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(finalPrompt)}&langpair=en|${targetLanguageCode}`, {
          method: 'GET',
          headers: { 'User-Agent': 'Campaign Builder' }
        });
        
        if (translateResponse.ok) {
          const result = await translateResponse.json();
          if (result.responseStatus === 200 && result.responseData && result.responseData.translatedText) {
            finalPrompt = result.responseData.translatedText;

          } else {
            console.warn('Translation API returned no result, using original text');
          }
        } else {
          console.warn('Translation API failed, using original text');
        }
      } catch (translationError) {
        console.warn('Campaign translation failed, using original text:', translationError.message);
        // Continue with original text if translation fails
      }
    }
    
    // Import AWS SDK for Polly
    const AWS = require('aws-sdk');
    
    // Configure AWS Polly - check for credentials
    if (!process.env.AWS_ACCESS_KEY_ID || !process.env.AWS_SECRET_ACCESS_KEY) {
      throw new Error('AWS credentials not configured. Please set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables.');
    }
    
    const polly = new AWS.Polly({
      region: process.env.AWS_REGION || 'us-east-1',
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
    });
    
    // Map Twilio voice names to Polly voice IDs (only verified working voices)
    const voiceMap = {
      'Polly.Joanna': 'Joanna',
      'Polly.Matthew': 'Matthew', 
      'Polly.Chantal': 'Chantal',
      'Polly.Emma': 'Emma',
      'Polly.Brian': 'Brian',
      'alice': 'Joanna', // fallback to Joanna for generic voices
      'man': 'Matthew'   // fallback to Matthew for generic voices
    };
    
    // Map language codes (Twilio format to Polly format)
    const languageMap = {
      'en-US': 'en-US',
      'en-CA': 'en-US', // Polly doesn't have en-CA, use en-US
      'en-GB': 'en-GB',
      'fr-CA': 'fr-CA',
      'fr-FR': 'fr-FR'
    };
    
    const pollyVoiceId = voiceMap[finalVoice] || 'Joanna';
    const pollyLanguageCode = languageMap[finalLanguage] || 'en-US';
    
    // Generate speech with Polly
    const pollyParams = {
      Text: finalPrompt,
      OutputFormat: 'mp3',
      VoiceId: pollyVoiceId,
      LanguageCode: pollyLanguageCode
    };

    const pollyResult = await polly.synthesizeSpeech(pollyParams).promise();
    
    // Set response headers for audio streaming
    res.setHeader('Content-Type', 'audio/mpeg');
    res.setHeader('Content-Length', pollyResult.AudioStream.length);
    res.setHeader('Cache-Control', 'public, max-age=3600'); // Cache for 1 hour
    
    // Stream the audio directly to the response
    res.send(pollyResult.AudioStream);
    
  } catch (error) {
    console.error('Campaign preview error:', error);
    res.status(400).json({ error: error.message || 'Campaign preview failed. Please try again.' });
  }
});

// Complete campaign sample: places a call with the full agent prompt (costs 1 AI token)

// Search contact AI call history
app.get('/api/voice/search-contact-calls', auth, async (req, res) => {
  try {
    const { query } = req.query;
    if (!query || !query.trim()) {
      return res.json({ contact: null, calls: [] });
    }
    
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    
    const searchTerm = query.toLowerCase().trim();
    
    // Search for contact by name, email, or phone using shared-data
    const contacts = await getAccountContacts(accountId);
    const contact = contacts.find(c => {
      const firstName = (c.firstName || '').toLowerCase();
      const lastName = (c.lastName || '').toLowerCase();
      const email = (c.email || '').toLowerCase();
      const phone = (c.phone || '').replace(/\D/g, ''); // Remove non-digits
      const searchPhone = searchTerm.replace(/\D/g, '');
      
      return firstName.includes(searchTerm) ||
             lastName.includes(searchTerm) ||
             `${firstName} ${lastName}`.includes(searchTerm) ||
             email.includes(searchTerm) ||
             (searchPhone && phone.includes(searchPhone));
    });
    
    if (!contact) {
      return res.json({ contact: null, calls: [] });
    }
    
    // Find all voice calls for this contact from shared-data
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');
    const campaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
    
    let calls = [];
    let campaigns = [];
    
    // Read voice calls
    if (fs.existsSync(voiceCallsPath)) {
      try {
        const voiceCalls = JSON.parse(await fs.promises.readFile(voiceCallsPath, 'utf8'));
        calls = voiceCalls.filter(call => call.contactId === contact.id);
      } catch (parseError) {
        console.error('Error parsing voice calls for search:', parseError);
      }
    }
    
    // Read campaigns for enrichment
    if (fs.existsSync(campaignsPath)) {
      try {
        campaigns = JSON.parse(await fs.promises.readFile(campaignsPath, 'utf8'));
      } catch (parseError) {
        console.error('Error parsing campaigns for search:', parseError);
      }
    }
    
    // Enrich calls with campaign names
    calls = calls.map(call => {
      const campaign = campaigns.find(c => c.id === call.campaignId);
      return {
        ...call,
        campaignName: campaign ? campaign.name : 'Unknown Campaign'
      };
    }).sort((a, b) => new Date(b.startedAt) - new Date(a.startedAt)); // Most recent first
    
    res.json({ contact, calls });
  } catch (error) {
    console.error('Search contact calls error:', error);
    res.status(400).json({ error: error.message });
  }
});

// TwiML for direct campaigns (simple message delivery with interactive options)
app.post('/api/voice/twiml/direct/:userId/:campaignId', async (req, res) => {

  try {

    const { userId, campaignId } = req.params;
    const { contactId } = req.query;

    // Get user first
    const user = await findUserById(userId);
    if (!user) {
      console.error(`User ${userId} not found`);
      return res.type('text/xml').send('<Response><Say>User not found.</Say><Hangup /></Response>');
    }

    // Get campaign from shared-data structure
    const accountId = user.accountId || user.id;

    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const voiceCampaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');

    let campaign = null;
    if (fs.existsSync(voiceCampaignsPath)) {
      try {
        const campaigns = JSON.parse(fs.readFileSync(voiceCampaignsPath, 'utf8'));

        campaign = campaigns.find(c => c.id === campaignId);

      } catch (error) {
        console.error('Error reading voice campaigns:', error);
      }
    }
    
    if (!campaign) {
      console.error(`Campaign ${campaignId} not found for user ${userId}`);
      return res.type('text/xml').send('<Response><Say>Campaign not found.</Say><Hangup /></Response>');
    }
    
    // Get contact from shared-data structure
    const accountContacts = await getAccountContacts(accountId);
    const contact = accountContacts.find(c => c.id === contactId);
    const contactName = contact ? `${contact.firstName || ''} ${contact.lastName || ''}`.trim() : 'there';

    // Personalize message with contact name if available
    let personalizedMessage = campaign.message;
    if (contactName && contactName !== 'there') {
      personalizedMessage = personalizedMessage.replace(/\bhello\b/gi, `Hello ${contactName}`);
    }
    
    // Escape XML special characters in the message
    const escapeXml = (text) => {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    };
    
    const escapedMessage = escapeXml(personalizedMessage);

    // Generate TwiML with the actual campaign message and keypad response handling
    const responseUrl = `${BASE_URL}/api/voice/response/${userId}/${campaignId}?contactId=${contactId}`;
    const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="${campaign.voice}" language="${campaign.language}">${escapedMessage}</Say>
  <Gather numDigits="1" action="${responseUrl}" method="POST" timeout="10">
    <Say voice="${campaign.voice}" language="${campaign.language}">Please press a key to respond.</Say>
  </Gather>
  <Say voice="${campaign.voice}" language="${campaign.language}">Thank you for your time. Goodbye.</Say>
  <Hangup />
</Response>`;

    res.type('text/xml').send(twiml);
    
  } catch (error) {
    console.error('Direct TwiML generation error:', error);
    console.error('Error details:', {
      userId: req.params.userId,
      campaignId: req.params.campaignId,
      contactId: req.query.contactId,
      error: error.message,
      stack: error.stack
    });
    res.type('text/xml').send('<Response><Say>Sorry, there was an error. Goodbye.</Say><Hangup /></Response>');
  }
});

// Test TwiML endpoint
app.get('/api/voice/twiml/test', (req, res) => {
  try {

    const testTwiML = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="Polly.Joanna" language="en-US">This is a test call from Campaign Builder. If you can hear this, the TwiML endpoint is working correctly.</Say>
  <Hangup />
</Response>`;
    
    res.type('text/xml').send(testTwiML);
  } catch (error) {
    console.error('Error in TwiML test endpoint:', error);
    res.type('text/xml').send('<Response><Say>Error occurred</Say><Hangup /></Response>');
  }
});

// Simple test endpoint to verify TwiML accessibility
app.get('/api/voice/twiml/simple-test', (req, res) => {
  try {

    res.type('text/xml').send('<Response><Say>Test successful</Say><Hangup /></Response>');
  } catch (error) {
    console.error('Error in simple TwiML test endpoint:', error);
    res.type('text/xml').send('<Response><Say>Error occurred</Say><Hangup /></Response>');
  }
});

// Generic TwiML webhook for Twilio (handles dynamic routing)
app.post('/api/voice/twiml/webhook', async (req, res) => {

  try {
    // Extract call information from Twilio webhook
    const { CallSid, To, From } = req.body;
    
    // Find the call in our database to get campaign info
    const sharedDataPath = path.join(SHARED_DATA_DIR, '1740033441075'); // Use your account ID
    const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');
    
    let call = null;
    if (fs.existsSync(voiceCallsPath)) {
      const calls = JSON.parse(fs.readFileSync(voiceCallsPath, 'utf8'));
      call = calls.find(c => c.id === CallSid);
    }
    
    if (!call) {
      console.error(`Call ${CallSid} not found in database`);
      return res.type('text/xml').send('<Response><Say>Call not found.</Say><Hangup /></Response>');
    }
    
    // Redirect to the specific TwiML endpoint
    const redirectUrl = `${BASE_URL}/api/voice/twiml/direct/1740033441075/${call.campaignId}?contactId=${call.contactId}`;
    
    const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Redirect method="POST">${redirectUrl}</Redirect>
</Response>`;
    
    res.type('text/xml').send(twiml);
    
  } catch (error) {
    console.error('Generic TwiML webhook error:', error);
    res.type('text/xml').send('<Response><Say>Sorry, there was an error.</Say><Hangup /></Response>');
  }
});

// Handle keypad responses from voice calls
app.post('/api/voice/response/:userId/:campaignId', async (req, res) => {

  try {
    const { userId, campaignId } = req.params;
    const { contactId } = req.query;
    const { Digits } = req.body;

    // Get user and account info
    const user = await findUserById(userId);
    if (!user) {
      console.error(`User ${userId} not found`);
      return res.type('text/xml').send('<Response><Say>User not found.</Say><Hangup /></Response>');
    }
    
    const accountId = user.accountId || user.id;
    
    // Save the response to shared data
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const voiceResponsesPath = path.join(sharedDataPath, 'voice-responses.json');
    
    let voiceResponses = [];
    if (fs.existsSync(voiceResponsesPath)) {
      const data = await fsPromises.readFile(voiceResponsesPath, 'utf8');
      voiceResponses = JSON.parse(data);
    }
    
    // Add the response
    voiceResponses.push({
      id: `response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      campaignId: campaignId,
      contactId: contactId,
      userId: userId,
      digits: Digits || 'no_response',
      timestamp: new Date().toISOString(),
      callSid: req.body.CallSid
    });
    
    // Save responses
    await fsPromises.writeFile(voiceResponsesPath, JSON.stringify(voiceResponses, null, 2));
    
    // Also update the call record in voice-calls.json
    const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');
    if (fs.existsSync(voiceCallsPath)) {
      try {
        const voiceCalls = JSON.parse(await fsPromises.readFile(voiceCallsPath, 'utf8'));

        // Try to find call by CallSid (which should match the id field)
        let call = voiceCalls.find(c => c.id === req.body.CallSid);
        
        // If not found by id, try by callSid field
        if (!call) {
          call = voiceCalls.find(c => c.callSid === req.body.CallSid);
        }
        
        // If still not found, try by contactId and campaignId
        if (!call && contactId && campaignId) {
          call = voiceCalls.find(c => c.contactId === contactId && c.campaignId === campaignId);
        }
        
        if (call) {
          call.response = Digits || 'no_response';
          call.respondedAt = new Date().toISOString();
          call.callSid = req.body.CallSid; // Ensure CallSid is stored
          await fsPromises.writeFile(voiceCallsPath, JSON.stringify(voiceCalls, null, 2));

        } else {
          console.warn(`Call record not found for CallSid: ${req.body.CallSid}, contactId: ${contactId}, campaignId: ${campaignId}`);
          }
      } catch (error) {
        console.error('Error updating call record:', error);
      }
    }

    // Get campaign details for proper voice/language
    let campaignVoice = 'Polly.Joanna';
    let campaignLanguage = 'en-US';
    
    try {
      const voiceCampaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
      if (fs.existsSync(voiceCampaignsPath)) {
        const campaigns = JSON.parse(await fsPromises.readFile(voiceCampaignsPath, 'utf8'));
        const campaign = campaigns.find(c => c.id === campaignId);
        if (campaign) {
          campaignVoice = campaign.voice || 'Polly.Joanna';
          campaignLanguage = campaign.language || 'en-US';
        }
      }
    } catch (error) {
      console.error('Error getting campaign details for response:', error);
    }
    
    // Generate response TwiML
    let responseMessage = '';
    if (Digits) {
      responseMessage = `Thank you for your response. You pressed ${Digits}. Your response has been recorded.`;
    } else {
      responseMessage = 'Thank you for your time. Your response has been recorded.';
    }
    
    const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="${campaignVoice}" language="${campaignLanguage}">${responseMessage}</Say>
  <Hangup />
</Response>`;
    
    res.type('text/xml').send(twiml);
    
  } catch (error) {
    console.error('Voice response webhook error:', error);
    res.type('text/xml').send('<Response><Say>Thank you for your response.</Say><Hangup /></Response>');
  }
});

// Campaign status endpoint for monitoring
app.get('/api/campaigns/status/:campaignId', auth, async (req, res) => {
  try {
    const { campaignId } = req.params;
    const user = await findUserById(req.user.id);
    ensureVoiceStructures(user);
    
    // Get campaign from shared files
    const accountId = user.accountId || user.id;
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const voiceCampaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
    const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');
    const voiceResponsesPath = path.join(sharedDataPath, 'voice-responses.json');
    
    let campaigns = [];
    let calls = [];
    let responses = [];
    
    if (fs.existsSync(voiceCampaignsPath)) {
      try {
        campaigns = JSON.parse(fs.readFileSync(voiceCampaignsPath, 'utf8'));
      } catch (error) {
        console.error('Error reading voice campaigns:', error);
      }
    }
    
    if (fs.existsSync(voiceCallsPath)) {
      try {
        calls = JSON.parse(fs.readFileSync(voiceCallsPath, 'utf8'));
      } catch (error) {
        console.error('Error reading voice calls:', error);
      }
    }
    
    if (fs.existsSync(voiceResponsesPath)) {
      try {
        responses = JSON.parse(fs.readFileSync(voiceResponsesPath, 'utf8'));
      } catch (error) {
        console.error('Error reading voice responses:', error);
      }
    }
    
    const campaign = campaigns.find(c => c.id === campaignId);
    if (!campaign) {
      return res.status(404).json({ error: 'Campaign not found' });
    }
    
    // Get all calls for this campaign
    const campaignCalls = calls.filter(c => c.campaignId === campaignId);
    const campaignResponses = responses.filter(r => r.campaignId === campaignId);
    
    // Calculate statistics
    const totalCalls = campaignCalls.length;
    const completedCalls = campaignCalls.filter(c => c.status === 'completed' || c.status === 'busy' || c.status === 'no-answer').length;
    const failedCalls = campaignCalls.filter(c => c.status === 'failed').length;
    const inProgressCalls = campaignCalls.filter(c => c.status === 'initiated' || c.status === 'ringing' || c.status === 'in-progress').length;
    const responsesReceived = campaignResponses.length;
    
    // Update campaign stats
    campaign.totalCalls = totalCalls;
    campaign.completedCalls = completedCalls;
    campaign.failedCalls = failedCalls;
    campaign.responsesReceived = responsesReceived;
    
    if (inProgressCalls === 0 && totalCalls > 0) {
      campaign.status = 'completed';
      campaign.completedAt = new Date().toISOString();
    }
    
    await writeIndividualUserFile(req.user.id, user);
    
    // Return detailed status
    res.json({
      campaign: {
        id: campaign.id,
        name: campaign.name,
        status: campaign.status,
        voice: campaign.voice,
        language: campaign.language,
        message: campaign.message,
        startedAt: campaign.startedAt,
        completedAt: campaign.completedAt
      },
      stats: {
        totalCalls,
        completedCalls,
        failedCalls,
        inProgressCalls,
        responsesReceived
      },
      calls: calls.map(call => ({
        id: call.id,
        contactName: call.contactName,
        phone: call.to,
        status: call.status,
        startedAt: call.startedAt,
        endedAt: call.endedAt,
        response: call.response,
        error: call.error
      })),
      responses: responses.map(response => ({
        contactId: response.contactId,
        digits: response.digits,
        timestamp: response.timestamp
      }))
    });
    
  } catch (error) {
    console.error('Campaign status error:', error);
    res.status(400).json({ error: error.message || 'Failed to get campaign status' });
  }
});

// Get AI voice campaigns for dashboard analytics (similar to /api/campaigns/all)
app.get('/api/voice/campaigns/all', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    
    // Read from shared-data folder
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const campaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
    const callsPath = path.join(sharedDataPath, 'voice-calls.json');
    
    let campaigns = [];
    let calls = [];
    
    if (fs.existsSync(campaignsPath)) {
      campaigns = JSON.parse(await fsPromises.readFile(campaignsPath, 'utf8'));
      // Filter campaigns for team members
      if (user.userType !== 'account_holder' && user.userType !== 'app_owner') {
        campaigns = campaigns.filter(c => c.userId === user.id);
      }
    }
    
    if (fs.existsSync(callsPath)) {
      calls = JSON.parse(await fsPromises.readFile(callsPath, 'utf8'));
    }
    
    const formattedCampaigns = campaigns.map(campaign => {
      // Count associated calls
      const campaignCalls = calls.filter(call => call.campaignId === campaign.id);
      const completedCalls = campaignCalls.filter(call => call.status === 'completed').length;
      const failedCalls = campaignCalls.filter(call => ['failed', 'busy', 'no-answer'].includes(call.status)).length;
      
      // Use the stored values if available, otherwise calculate from calls
      const deliveredCount = campaign.deliveredCount !== undefined ? campaign.deliveredCount : completedCalls;
      const failCount = campaign.failedCount !== undefined ? campaign.failedCount : failedCalls;
      
      return {
        id: campaign.id,
        name: campaign.name,
        type: 'voice',
        timestamp: campaign.timestamp || campaign.startedAt || campaign.createdAt,
        dateSent: campaign.timestamp || campaign.startedAt || campaign.createdAt, // For dashboard compatibility
        recipientCount: campaignCalls.length,
        totalAttempted: campaignCalls.length,
        deliveredCount: deliveredCount,
        failedCount: failCount,
        bouncedCount: failCount, // For compatibility with analytics
        status: campaign.status,
        subject: campaign.name, // For compatibility
        body: campaign.name // For compatibility
      };
    });
    
    res.json(formattedCampaigns);
  } catch (error) {
    console.error('Get voice campaigns error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get AI voice campaigns history (for Campaign History tab)
app.get('/api/voice/campaigns/history', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    
    const { page = 1, limit = 25, search = '' } = req.query;
    const pageNum = parseInt(page, 10);
    const limitNum = parseInt(limit, 10);
    
    // Read from shared-data folder
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const campaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
    
    let campaigns = [];
    if (fs.existsSync(campaignsPath)) {
      try {
        campaigns = JSON.parse(await fs.promises.readFile(campaignsPath, 'utf8'));
        // Don't filter campaigns for team members - they should see all account campaigns
        // Team members can access all campaigns in their account
      } catch (parseError) {
        console.error('Error parsing voice campaigns file:', parseError);
        campaigns = [];
      }
    }
    
    campaigns = campaigns.map(campaign => ({
      id: campaign.id,
      name: campaign.name,
      message: campaign.message || campaign.body,
      voice: campaign.voice,
      language: campaign.language,
      timestamp: campaign.timestamp || campaign.startedAt || campaign.createdAt,
      startedAt: campaign.startedAt,
      createdAt: campaign.createdAt,
      status: campaign.status,
      recipientCount: campaign.recipientCount || campaign.totalAttempted
    }));
    
    // Filter by search term if provided
    if (search && search.trim()) {
      const searchLower = search.toLowerCase();
      campaigns = campaigns.filter(campaign => 
        (campaign.name && campaign.name.toLowerCase().includes(searchLower)) ||
        (campaign.message && campaign.message.toLowerCase().includes(searchLower))
      );
    }
    
    // Sort by most recent first
    campaigns.sort((a, b) => {
      const dateA = new Date(a.timestamp || a.startedAt || a.createdAt || 0);
      const dateB = new Date(b.timestamp || b.startedAt || b.createdAt || 0);
      return dateB - dateA;
    });
    
    // Pagination
    const totalItems = campaigns.length;
    const totalPages = Math.ceil(totalItems / limitNum);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = Math.min(startIndex + limitNum, totalItems);
    const paginatedCampaigns = campaigns.slice(startIndex, endIndex);
    
    const pagination = {
      currentPage: pageNum,
      totalPages: totalPages,
      totalItems: totalItems,
      startIndex: startIndex + 1,
      endIndex: endIndex,
      hasNextPage: pageNum < totalPages,
      hasPrevPage: pageNum > 1
    };
    
    res.json({
      campaigns: paginatedCampaigns,
      pagination: pagination
    });
  } catch (error) {
    console.error('Get voice campaigns history error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Add request logging middleware
app.use((req, res, next) => {
  next();
});

// Server startup moved to end of file 

// Add or update the verification endpoint (SMTP mode - DNS verification would be manual)
app.get('/api/email/senders/:id/verify', auth, async (req, res) => {
    try {
        const senderId = req.params.id;
        
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }
        
        // Get sender emails from shared-data
        const accountId = user.accountId || user.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const sendersPath = path.join(sharedDataPath, 'senders.json');
        
        let senderEmails = [];
        if (fs.existsSync(sendersPath)) {
            const data = await fsPromises.readFile(sendersPath, 'utf8');
            senderEmails = JSON.parse(data);
        }
        
        const senderIndex = senderEmails.findIndex(s => s.id === senderId || s.id.toString() === senderId);
        
        if (senderIndex === -1) {
            throw new Error('Sender not found');
        }

        // SMTP mode - DNS verification status is maintained in the sender record
        // Return current verification status from the stored record
        const verificationDetails = senderEmails[senderIndex].verificationDetails || {};
        const allVerified = verificationDetails.spfVerified && 
                          verificationDetails.dkimVerified && 
                          verificationDetails.returnPathDomainVerified;

        // Create detailed status message
        const pendingRecords = [
            !verificationDetails.spfVerified ? 'SPF' : null,
            !verificationDetails.dkimVerified ? 'DKIM' : null,
            !verificationDetails.returnPathDomainVerified ? 'Return-Path' : null
        ].filter(Boolean);

        const message = allVerified 
            ? 'All DNS records have been verified successfully!' 
            : `DNS verification pending for: ${pendingRecords.join(', ')}. Please ensure these records are set up correctly.`;

        res.json({
            sender: senderEmails[senderIndex],
            message: message
        });
    } catch (error) {
        console.error('Verification check error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add details endpoint
app.get('/api/email/senders/:id/details', auth, async (req, res) => {
    try {
        const senderId = parseInt(req.params.id);
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }
        
        // Get sender emails from shared-data
        const accountId = user.accountId || user.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const sendersPath = path.join(sharedDataPath, 'senders.json');
        
        let senderEmails = [];
        if (fs.existsSync(sendersPath)) {
            const data = await fsPromises.readFile(sendersPath, 'utf8');
            senderEmails = JSON.parse(data);
        }
        
        const sender = senderEmails.find(s => s.id === senderId);
        if (!sender) {
            throw new Error('Sender not found');
        }

        res.json(sender.verificationDetails);
    } catch (error) {
        console.error('Details error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Update the delete sender endpoint
app.delete('/api/email/senders/:id', auth, requirePermission('manage_settings'), async (req, res) => {
    try {
        const senderId = req.params.id;
        const user = await findUserById(req.user.id);
        
        if (!user) {
            throw new Error('User not found');
        }

        // Use getEffectiveAccountId for consistency with GET endpoint
        const accountId = getEffectiveAccountId(user);
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        
        // Try both possible file names for backward compatibility
        const senderEmailsPath = path.join(sharedDataPath, 'senderEmails.json');
        const sendersPath = path.join(sharedDataPath, 'senders.json');
        const actualPath = fs.existsSync(senderEmailsPath) ? senderEmailsPath : sendersPath;
        
        let senderEmails = [];
        let foundInFile = false;
        let foundInUserObject = false;
        
        // Check shared-data file first
        if (fs.existsSync(actualPath)) {
            const data = await fsPromises.readFile(actualPath, 'utf8');
            senderEmails = JSON.parse(data);
        }

        // Find the sender - compare as string since IDs can be timestamp-based strings like "1766213744250-676301"
        let senderIndex = senderEmails.findIndex(s => 
            String(s.id) === String(senderId) || 
            s.id === senderId
        );
        
        if (senderIndex !== -1) {
            foundInFile = true;
            // Remove from shared-data file
            senderEmails.splice(senderIndex, 1);
            await fsPromises.writeFile(actualPath, JSON.stringify(senderEmails, null, 2), 'utf8');
        }
        
        // Also check user.senderEmails for backward compatibility
        if (user.senderEmails && Array.isArray(user.senderEmails)) {
            const userSenderIndex = user.senderEmails.findIndex(s => 
                String(s.id) === String(senderId) || 
                s.id === senderId
            );
            if (userSenderIndex !== -1) {
                foundInUserObject = true;
                user.senderEmails.splice(userSenderIndex, 1);
                // Save user data using the correct function
                await writeIndividualUserFile(user.id, user);
            }
        }
        
        if (!foundInFile && !foundInUserObject) {
            throw new Error('Sender not found');
        }

        res.json({ message: 'Sender deleted successfully' });
    } catch (error) {
        console.error('Delete sender error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add email confirmation check endpoint (SMTP mode - senders are auto-confirmed)
app.get('/api/email/senders/:id/check-email', auth, async (req, res) => {
    try {
        const senderId = req.params.id;
        
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }
        
        // Get sender emails from shared-data
        const accountId = user.accountId || user.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const sendersPath = path.join(sharedDataPath, 'senders.json');
        
        let senderEmails = [];
        if (fs.existsSync(sendersPath)) {
            const data = await fsPromises.readFile(sendersPath, 'utf8');
            senderEmails = JSON.parse(data);
        }
        
        const senderIndex = senderEmails.findIndex(s => s.id === senderId || s.id.toString() === senderId);
        
        if (senderIndex === -1) {
            throw new Error('Sender not found');
        }

        // SMTP mode - senders are automatically confirmed
        const emailConfirmed = senderEmails[senderIndex].emailConfirmed !== false;

        res.json({
            emailConfirmed: emailConfirmed,
            message: emailConfirmed ? 
                'Email is confirmed and ready to use!' : 
                'Email confirmation pending.'
        });
    } catch (error) {
        console.error('Email confirmation check error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add activation endpoint
app.post('/api/email/senders/:id/activate', auth, async (req, res) => {
    try {
        const senderId = parseInt(req.params.id);
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }
        
        // Get sender emails from shared-data
        const accountId = user.accountId || user.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const sendersPath = path.join(sharedDataPath, 'senders.json');
        
        let senderEmails = [];
        if (fs.existsSync(sendersPath)) {
            const data = await fsPromises.readFile(sendersPath, 'utf8');
            senderEmails = JSON.parse(data);
        }
        
        const senderIndex = senderEmails.findIndex(s => s.id === senderId);
        if (senderIndex === -1) {
            throw new Error('Sender not found');
        }

        // Verify all checks are complete
        const sender = senderEmails[senderIndex];
        if (!sender.emailConfirmed || 
            !sender.verificationDetails.spfVerified || 
            !sender.verificationDetails.dkimVerified || 
            !sender.verificationDetails.returnPathDomainVerified) {
            throw new Error('All verifications must be complete before activation');
        }

        // Update confirmation status
        senderEmails[senderIndex].Confirmed = true;
        await fsPromises.writeFile(sendersPath, JSON.stringify(senderEmails, null, 2), 'utf8');

        res.json({
            success: true,
            message: 'Sender activated successfully'
        });
    } catch (error) {
        console.error('Activation error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add deactivation endpoint
app.post('/api/email/senders/:id/deactivate', auth, async (req, res) => {
    try {
        const senderId = parseInt(req.params.id);
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }
        
        // Get sender emails from shared-data
        const accountId = user.accountId || user.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const sendersPath = path.join(sharedDataPath, 'senders.json');
        
        let senderEmails = [];
        if (fs.existsSync(sendersPath)) {
            const data = await fsPromises.readFile(sendersPath, 'utf8');
            senderEmails = JSON.parse(data);
        }
        
        const senderIndex = senderEmails.findIndex(s => s.id === senderId);
        if (senderIndex === -1) {
            throw new Error('Sender not found');
        }

        // Update confirmation status
        senderEmails[senderIndex].Confirmed = false;
        await fsPromises.writeFile(sendersPath, JSON.stringify(senderEmails, null, 2), 'utf8');

        // SMTP mode - no external API update needed

        res.json({
            success: true,
            message: 'Sender deactivated successfully'
        });
    } catch (error) {
        console.error('Deactivation error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add endpoint to set default number
app.post('/api/numbers/set-default', auth, async (req, res) => {
    try {
        const { phoneNumber } = req.body;
        
        if (!phoneNumber) {
            throw new Error('Phone number is required');
        }

        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }

        // Update isDefault flag for all numbers in shared-data
        const accountId = user.accountId || user.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const phoneNumbersPath = path.join(sharedDataPath, 'phoneNumbers.json');
        
        let phoneNumbers = [];
        if (fs.existsSync(phoneNumbersPath)) {
            const phoneNumbersData = JSON.parse(fs.readFileSync(phoneNumbersPath, 'utf8'));
            phoneNumbers = phoneNumbersData;
        }
        
        phoneNumbers = phoneNumbers.map(num => ({
            ...num,
            isDefault: num.number === phoneNumber
        }));
        
        await fsPromises.writeFile(phoneNumbersPath, JSON.stringify(phoneNumbers, null, 2), 'utf8');
        
        // Update default sending number in individual data
        user.defaultSendingNumber = phoneNumber;
        await writeIndividualUserFile(req.user.id, user);

        res.json({
            success: true,
            defaultNumber: phoneNumber
        });
    } catch (error) {
        console.error('Error setting default number:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add template generation endpoint
app.post('/api/templates/generate', auth, async (req, res) => {
    try {
        const { topic, tone = 'professional', includeHtml = false, prompt } = req.body;
        // First, let's get an image based on the topic
        let headerImage = 'https://images.unsplash.com/photo-1557804506-669a67965ba0?ixlib=rb-4.0.3'; // Default image
        
        try {
            // Extract keywords from the topic for better image search
            const keywordResponse = await openai.chat.completions.create({
                model: "gpt-3.5-turbo",
                messages: [
                    {
                        "role": "system",
                        "content": "Extract 2-3 key search terms from this newsletter description, separated by commas. Focus on visual elements and themes."
                    },
                    {
                        "role": "user",
                        "content": topic
                    }
                ],
                temperature: 0.3,
                max_tokens: 50
            });
            const searchTerms = keywordResponse.choices[0].message.content;
            
            // Search Unsplash for a relevant image
            const imageResponse = await fetch(
                `https://api.unsplash.com/photos/random?query=${encodeURIComponent(searchTerms)}&orientation=landscape`,
                {
                    headers: {
                        'Authorization': `Client-ID ${UNSPLASH_ACCESS_KEY}`
                    }
                }
            );
            if (imageResponse.ok) {
                const imageData = await imageResponse.json();
                headerImage = imageData.urls.regular;
            }
        } catch (error) {
            console.error('Image search error:', error);
            // Continue with default image if image search fails
        }

        const systemPrompt = `You are a professional email marketing copywriter who creates compelling templates with HTML formatting.
IMPORTANT: Your response must be ONLY valid JSON. The content field should include HTML tags for structure and styling.
Use proper HTML tags like <h1>, <p>, <strong>, <em>, <ul>, <li>, etc. for formatting.`;

        const formatInstructions = `Create a marketing email template for: "${topic}"

Respond with ONLY a JSON object in this exact format:
{
    "name": "string (create a concise, catchy name)",
    "headerText": "string (compelling header text, max 6 words)",
    "headerImage": "${headerImage}",
    "bannerImage": "",
    "bodyElements": [
        {
            "type": "text",
            "content": "string (Write compelling marketing copy using proper HTML tags for structure and emphasis. Include at least 2-3 paragraphs with proper formatting.)"
        },
        {
            "type": "button",
            "text": "string (call to action text, max 4 words)",
            "url": "https://swiftmedia.ca"
        }
    ],
    "footerImage": "",
    "footerLinks": [
        {
            "text": "Privacy Policy",
            "url": "#"
        },
        {
            "text": "Unsubscribe",
            "url": "#"
        }
    ],
    "style": {
        "headerOverlay": "bg-gradient-to-r from-indigo-900 to-indigo-600 mix-blend-multiply",
        "headerTextColor": "text-white"
    }
}

Requirements for the content:
- Use proper HTML tags for structure (<h1>, <h2>, <p>, etc.)
- Include formatting tags for emphasis (<strong>, <em>)
- Create engaging, ${tone} tone marketing copy
- Ensure all HTML tags are properly closed
- Make content scannable with proper spacing and paragraphs`;

        const completion = await openai.chat.completions.create({
            model: "gpt-4",
            messages: [
                {
                    "role": "system",
                    "content": systemPrompt
                },
                {
                    "role": "user",
                    "content": formatInstructions
                }
            ],
            temperature: 0.7,
            max_tokens: 1000
        });

        // Parse the response with better error handling
        let template;
        try {
            const rawResponse = completion.choices[0].message.content.trim();
            // Try to find JSON object in the response
            const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('No valid JSON object found in response');
            }
            template = JSON.parse(jsonMatch[0]);

            // Validate that content has HTML
            if (!template.bodyElements[0].content.includes('<')) {
                template.bodyElements[0].content = `<div class="email-content">
                    <p>${template.bodyElements[0].content}</p>
                </div>`;
            }
        } catch (parseError) {
            console.error('JSON Parse Error:', parseError);
            throw new Error('Failed to parse template response');
        }

        // Add required fields
        template.id = Date.now().toString();
        template.updatedAt = new Date().toISOString();
        template.isDefault = false;
        
        // Save to appropriate location based on user type
        const user = await findUserById(req.user.id);
        
        // Add creation metadata
        template.createdBy = user.id;
        template.createdAt = new Date().toISOString();
        
        // Prevent creation of duplicate default templates
        if (template.name === 'Basic Marketing Template' || template.id === 'default') {
            template.name = `AI Generated Template - ${new Date().toLocaleDateString()}`;
        }
        
        // Add to shared templates (use accountId if available, otherwise user ID for app owners)
        const accountId = user.accountId || user.id;
        const templates = await getAccountTemplates(accountId);
        
        // Prevent duplicate default templates
        if (template.isDefault) {
          // Remove any existing default templates
          const filteredTemplates = templates.filter(t => !(t.isDefault === true && t.id === 'default'));
          templates.length = 0;
          templates.push(...filteredTemplates);
        }
        
        templates.push(template);
        
        // Update shared templates file
        const sharedTemplatesPath = path.join(__dirname, 'data', 'shared-data', accountId, 'templates.json');
        await fsPromises.writeFile(sharedTemplatesPath, JSON.stringify(templates, null, 2), 'utf8');
        
        res.json(template);
    } catch (error) {
        console.error('Template generation error:', error);
        res.status(400).json({ 
            error: 'Failed to generate template',
            details: error.message 
        });
    }
}); 

// Configure storage
// Enhanced file upload security with magic number validation
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, 'public/uploads/templates')
    },
    filename: function (req, file, cb) {
        // Generate secure filename using UUID to prevent path traversal
        const crypto = require('crypto');
        const uuid = crypto.randomUUID();
        const ext = path.extname(file.originalname).toLowerCase();
        const sanitizedExt = /\.(jpg|jpeg|png|gif)$/.test(ext) ? ext : '.jpg';
        cb(null, uuid + sanitizedExt);
    }
});

// Magic number validation for file types
const validateFileMagicNumbers = (buffer, mimetype) => {
    const magicNumbers = {
        'image/jpeg': [0xFF, 0xD8, 0xFF],
        'image/png': [0x89, 0x50, 0x4E, 0x47],
        'image/gif': [0x47, 0x49, 0x46, 0x38]
    };
    
    const expectedMagic = magicNumbers[mimetype];
    if (!expectedMagic) return false;
    
    return expectedMagic.every((byte, index) => buffer[index] === byte);
};

// Multer storage for Excel files (smart import)
const excelStorage = multer.diskStorage({
    destination: function (req, file, cb) {
        const uploadDir = path.join(__dirname, 'public', 'uploads', 'imports');
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        cb(null, uploadDir);
    },
    filename: function (req, file, cb) {
        const crypto = require('crypto');
        const uuid = crypto.randomUUID();
        const ext = path.extname(file.originalname).toLowerCase();
        cb(null, uuid + ext);
    }
});

const upload = multer({ 
    storage: storage,
    limits: {
        fileSize: 5 * 1024 * 1024 // 5MB limit
    },
    fileFilter: (req, file, cb) => {
        const filetypes = /jpeg|jpg|png|gif/;
        const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
        const mimetype = filetypes.test(file.mimetype);

        if (!mimetype || !extname) {
            return cb(new Error('Only image files (JPEG, PNG, GIF) are allowed!'));
        }
        
        // Additional security: validate file extension against MIME type
        const ext = path.extname(file.originalname).toLowerCase();
        const mimeMap = {
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg',
            '.png': 'image/png',
            '.gif': 'image/gif'
        };
        
        // Only validate MIME type if we have a mapping for this extension
        if (mimeMap[ext] && mimeMap[ext] !== file.mimetype) {
            return cb(new Error('File extension does not match MIME type!'));
        }
        
        cb(null, true);
    }
});

// Add image upload endpoint
app.post('/api/templates/upload-image', auth, (req, res, next) => {
    upload.single('image')(req, res, (err) => {
        if (err) {
            console.error('Multer error:', err);
            if (err.code === 'LIMIT_FILE_SIZE') {
                return res.status(400).json({ error: 'File size too large. Maximum size is 5MB.' });
            }
            if (err.message === 'Only image files are allowed!') {
                return res.status(400).json({ error: 'Only image files (JPEG, PNG, GIF) are allowed.' });
            }
            return res.status(500).json({ 
                error: 'Upload failed', 
                details: err.message,
                code: err.code || 'MULTER_ERROR'
            });
        }
        
        // Continue to the main handler
        handleImageUpload(req, res);
    });
});

async function handleImageUpload(req, res) {
    try {

        if (!req.file) {
            throw new Error('No file uploaded');
        }

        // SECURITY: Validate file content with magic number validation
        const filePath = path.join(__dirname, 'public', 'uploads', 'templates', req.file.filename);
        const fileBuffer = await fsPromises.readFile(filePath);
        const fileHeader = fileBuffer.slice(0, 10);
        
        if (!validateFileMagicNumbers(fileHeader, req.file.mimetype)) {
            // Remove the suspicious file
            await fsPromises.unlink(filePath);
            throw new Error('Invalid file content detected. File may be corrupted or malicious.');
        }

        // Generate a unique filename (already done in multer config with UUID)
        const newFilename = req.file.filename; // Already secure UUID-based filename
        
        // File is already in the correct location with secure filename - no need to rename
        
        // Create the URL for the image
        const imageUrl = `${BASE_URL}/uploads/templates/${newFilename}`;
        
        // Get user information for account-specific storage
        const user = await findUserById(req.user.id);
        const accountId = getEffectiveAccountId(user);
        
        // Get images using standardized function
        let images = await getAccountImages(accountId);
        
        // For app owners, also include global images as fallback
        if (user.userType === 'app_owner') {
            const globalImagesPath = path.join(__dirname, 'data', 'images.json');
            const globalImages = await safeReadJsonFile(globalImagesPath, []);
            // Filter to only show app owner's images + system defaults
            const filteredGlobalImages = globalImages.filter(img => 
                img.userId === req.user.id || (img.userId === 'system' && img.isDefault === true)
            );
            images = [...images, ...filteredGlobalImages];
        }
        
        // Generate unique ID and timestamp
        const imageId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        const timestamp = new Date().toISOString();
        
        // Add new image record
        const newImage = {
            id: imageId,
            userId: req.user.id,
            accountId: accountId,
            name: req.file.originalname || `Uploaded Image - ${timestamp}`,
            description: `Uploaded image for template`,
            url: imageUrl,
            tags: ['uploaded', 'template'],
            section: 'template',
            size: req.file.size,
            createdAt: new Date().toISOString(),
            source: 'upload',
            isDefault: false
        };
        
        images.push(newImage);
        
        // Save using standardized function
        await updateAccountImages(accountId, images);

        res.json({ 
            url: imageUrl,
            imageId: imageId
        });
    } catch (error) {
        console.error('Upload error:', error);
        res.status(500).json({ 
            error: 'Upload failed', 
            details: error.message,
            code: error.code || 'UNKNOWN_ERROR'
        });
    }
}

// Add endpoint to download and process external images (for AI-generated images)
app.post('/api/templates/download-image', auth, async (req, res) => {
    try {
        const { imageUrl } = req.body;
        
        if (!imageUrl) {
            throw new Error('Image URL is required');
        }

        // Download the image
        const response = await fetch(imageUrl);
        if (!response.ok) {
            throw new Error(`Failed to download image: ${response.status} ${response.statusText}`);
        }

        const imageBuffer = await response.buffer();
        const contentType = response.headers.get('content-type');
        const fileExtension = contentType.includes('png') ? '.png' : '.jpg';
        
        // Generate a unique ID
        const timestamp = Date.now();
        const imageId = `external-${timestamp}`;
        const newFilename = `${imageId}${fileExtension}`;
        
        // Save the image to the templates directory
        const imagePath = path.join(__dirname, 'public', 'uploads', 'templates', newFilename);
        await fs.promises.writeFile(imagePath, imageBuffer);
        
        // Create the URL for the image
        const localImageUrl = `${BASE_URL}/uploads/templates/${newFilename}`;
        
        // Get user information for account-specific storage
        const user = await findUserById(req.user.id);
        
        // Determine storage location based on user type
        let images = [];
        let isSharedData = false;
        
        if (user.accountId) {
            // For team members and account holders, use account-specific storage
            images = await getAccountImages(user.accountId);
            isSharedData = true;
        } else {
            // For app owners, use global storage (fallback)
            const imagesPath = path.join(__dirname, 'data', 'images.json');
            try {
                const imagesData = await fs.promises.readFile(imagesPath, 'utf8');
                images = JSON.parse(imagesData);
            } catch (error) {
                images = [];
            }
        }
        
        // Add new image record
        const newImage = {
            id: imageId,
            userId: req.user.id,
            accountId: user.accountId || null,
            name: `External Image - ${timestamp}`,
            description: `Downloaded external image`,
            url: localImageUrl,
            tags: ['external', 'downloaded'],
            section: 'template',
            size: imageBuffer.length,
            createdAt: new Date().toISOString(),
            source: 'external',
            isDefault: false
        };
        
        images.push(newImage);
        
        // Save to appropriate location
        if (isSharedData) {
            // Save to account-specific shared images file
            const sharedImagesPath = path.join(__dirname, 'data', 'shared-data', user.accountId, 'images.json');
            
            // Ensure directory exists
            const sharedDataDir = path.join(__dirname, 'data', 'shared-data', user.accountId);
            if (!fs.existsSync(sharedDataDir)) {
                fs.mkdirSync(sharedDataDir, { recursive: true });
            }
            
            await fs.promises.writeFile(sharedImagesPath, JSON.stringify(images, null, 2));

        } else {
            // Save to global images.json for app owners
            const imagesPath = path.join(__dirname, 'data', 'images.json');
            await fs.promises.writeFile(imagesPath, JSON.stringify(images, null, 2));

        }
        
        res.json({ 
            url: localImageUrl,
            imageId: imageId
        });
    } catch (error) {
        console.error('Error downloading external image:', error);
        res.status(500).json({ 
            error: 'Failed to download image', 
            details: error.message 
        });
    }
});

// ===== IMAGE LIBRARY API ENDPOINTS =====

// Convert full image URLs to relative path so browser loads from same origin (fixes ERR_BLOCKED_BY_RESPONSE.NotSameOrigin)
function toRelativeImageUrl(url) {
    if (!url || typeof url !== 'string') return url;
    const trimmed = url.trim();
    if (trimmed.startsWith('/')) return trimmed;
    const match = trimmed.match(/\/uploads\/[^?#]*/);
    return match ? match[0] : trimmed;
}

// Normalize template image URLs to relative so templates view loads images from same origin
function normalizeTemplateImageUrls(template) {
    if (!template) return template;
    const t = { ...template };
    if (t.headerImage) t.headerImage = toRelativeImageUrl(t.headerImage);
    if (t.bannerImage) t.bannerImage = toRelativeImageUrl(t.bannerImage);
    if (t.footerImage) t.footerImage = toRelativeImageUrl(t.footerImage);
    if (Array.isArray(t.bodyElements)) {
        t.bodyElements = t.bodyElements.map(el => {
            if (el && el.type === 'image' && el.url) return { ...el, url: toRelativeImageUrl(el.url) };
            return el;
        });
    }
    return t;
}

// Get user's image library - account-specific
app.get('/api/images', auth, async (req, res) => {
    try {
        const { q, category, tags, sort = 'createdAt', order = 'desc', page = 1, limit = 20, includeDefaults = 'true' } = req.query;
        
        // Get user information for account-specific image retrieval
        const user = await findUserById(req.user.id);
        const accountId = getEffectiveAccountId(user);
        
        // Get account-specific images using standardized function
        let allImages = await getAccountImages(accountId);
        
        // For app owners, also include global images as fallback
        if (user.userType === 'app_owner') {
            const globalImagesPath = path.join(__dirname, 'data', 'images.json');
            const globalImages = await safeReadJsonFile(globalImagesPath, []);
            // Filter to only show app owner's images + system defaults
            const filteredGlobalImages = globalImages.filter(img => 
                img.userId === req.user.id || (img.userId === 'system' && img.isDefault === true)
            );
            allImages = [...allImages, ...filteredGlobalImages];
        }
        
        // For account-based storage, all images are already account-specific
        // For app owners, images are already filtered to their own + defaults
        let userImages = allImages;
        
        // Deduplicate images by ID to prevent duplicates
        const seenIds = new Set();
        userImages = userImages.filter(img => {
            if (seenIds.has(img.id)) {
                return false;
            }
            seenIds.add(img.id);
            return true;
        });
        
        // Apply search filter
        let filteredImages = userImages;
        if (q) {
            const searchTerm = q.toLowerCase();
            filteredImages = filteredImages.filter(img => 
                img.name.toLowerCase().includes(searchTerm) ||
                (img.description && img.description.toLowerCase().includes(searchTerm)) ||
                (img.tags && img.tags.some(tag => tag.toLowerCase().includes(searchTerm)))
            );
        }
        
        // Apply section filter
        if ((category && category !== 'all') || (req.query.section && req.query.section !== 'all')) {
            const sectionFilter = category || req.query.section;
            filteredImages = filteredImages.filter(img => img.section === sectionFilter);
        }
        
        // Apply tags filter
        if (tags) {
            const tagArray = tags.split(',');
            filteredImages = filteredImages.filter(img => 
                img.tags && tagArray.some(tag => img.tags.includes(tag))
            );
        }
        
        // Apply sorting
        filteredImages.sort((a, b) => {
            let aVal = a[sort];
            let bVal = b[sort];
            
            if (sort === 'name') {
                aVal = aVal.toLowerCase();
                bVal = bVal.toLowerCase();
            }
            
            if (order === 'desc') {
                return bVal > aVal ? 1 : -1;
            } else {
                return aVal > bVal ? 1 : -1;
            }
        });
        
        // Apply pagination
        const startIndex = (page - 1) * limit;
        const endIndex = startIndex + parseInt(limit);
        const paginatedImages = filteredImages.slice(startIndex, endIndex).map(img => ({
            ...img,
            url: toRelativeImageUrl(img.url)
        }));
        
        res.json({
            images: paginatedImages,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: filteredImages.length,
                pages: Math.ceil(filteredImages.length / limit)
            }
        });
    } catch (error) {
        console.error('Error fetching image library:', error);
        res.status(500).json({ error: error.message });
    }
});

// Save image to library (from template or AI generation)
app.post('/api/images/save', auth, async (req, res) => {
    try {
        const { imageUrl, name, description, category, tags, section, templateId } = req.body;
        
        if (!imageUrl) {
            throw new Error('Image URL is required');
        }

        // Normalize the image URL to ensure consistency
        let normalizedUrl = imageUrl;
        
        // If it's a relative URL (starts with /), make it absolute with the current domain
        if (imageUrl.startsWith('/')) {
            const protocol = req.headers['x-forwarded-proto'] || req.protocol;
            const host = req.headers['x-forwarded-host'] || req.get('host');
            normalizedUrl = `${protocol}://${host}${imageUrl}`;
        }
        // If it's already a full URL, keep it as is
        else if (!imageUrl.startsWith('http://') && !imageUrl.startsWith('https://')) {
            // If it's a relative URL without leading slash, add it
            const protocol = req.headers['x-forwarded-proto'] || req.protocol;
            const host = req.headers['x-forwarded-host'] || req.get('host');
            normalizedUrl = `${protocol}://${host}/${imageUrl}`;
        }

        // Get user information for account-specific storage
        const user = await findUserById(req.user.id);
        const accountId = getEffectiveAccountId(user);
        
        // Get images using standardized function
        let allImages = await getAccountImages(accountId);
        
        // For app owners, also include global images as fallback
        if (user.userType === 'app_owner') {
            const globalImagesPath = path.join(__dirname, 'data', 'images.json');
            const globalImages = await safeReadJsonFile(globalImagesPath, []);
            // Filter to only show app owner's images + system defaults
            const filteredGlobalImages = globalImages.filter(img => 
                img.userId === req.user.id || (img.userId === 'system' && img.isDefault === true)
            );
            allImages = [...allImages, ...filteredGlobalImages];
        }
        
        // Generate unique ID
        const imageId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        
        // Create image record
        const imageRecord = {
            id: imageId,
            userId: req.user.id,
            accountId: accountId,
            url: normalizedUrl,
            name: name || `Image ${new Date().toLocaleDateString()}`,
            description: description || '',
            tags: tags ? (Array.isArray(tags) ? tags : tags.split(',').map(tag => tag.trim())) : [],
            section: section || 'body',
            size: 0,
            createdAt: new Date().toISOString(),
            source: 'template',
            isDefault: false
        };
        
        // Prevent duplicate default images
        if (imageRecord.isDefault) {
            // Remove any existing default images of the same type
            allImages = allImages.filter(img => !(img.isDefault === true && img.section === imageRecord.section));
        }
        
        // Add to images array
        allImages.push(imageRecord);
        
        // Save using standardized function
        await updateAccountImages(accountId, allImages);

        res.json(imageRecord);
    } catch (error) {
        console.error('Error saving image to library:', error);
        console.error('Error details:', {
            message: error.message,
            stack: error.stack,
            body: req.body
        });
        res.status(500).json({ error: error.message });
    }
});

// Upload image to library (for direct uploads)
app.post('/api/images/upload', auth, upload.single('image'), async (req, res) => {
    try {
        if (!req.file) {
            throw new Error('No image file uploaded');
        }

        // SECURITY: Validate file content with magic number validation
        // Construct proper absolute path
        const filePath = path.resolve(__dirname, req.file.path);

        // Magic number validation temporarily disabled for functionality

        const { name, description, tags, section } = req.body;
        
        // Get user information for account-specific storage
        const user = await findUserById(req.user.id);

        if (!user) {
            throw new Error('User not found');
        }

        // Use standardized account ID resolution
        const accountId = getEffectiveAccountId(user);

        // Get account-specific images using standardized function
        let allImages = await getAccountImages(accountId);

        // For app owners, also include global images as fallback
        if (user.userType === 'app_owner') {
            const globalImagesPath = path.join(__dirname, 'data', 'images.json');
            const globalImages = await safeReadJsonFile(globalImagesPath, []);
            // Filter to only show app owner's images + system defaults
            const filteredGlobalImages = globalImages.filter(img => 
                img.userId === req.user.id || (img.userId === 'system' && img.isDefault === true)
            );
            allImages = [...allImages, ...filteredGlobalImages];
        }
        
        // Generate unique ID
        const imageId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        
        // Get image metadata
        // req.file.path is already the correct path from multer
        const imagePath = path.resolve(__dirname, req.file.path);

        let imageStats;
        try {
            imageStats = await fsPromises.stat(imagePath);

        } catch (statError) {
            console.error('DEBUG: Error reading image stats:', statError);
            throw new Error(`Failed to read image file: ${statError.message}`);
        }
        
        // Construct the URL from the file path
        // req.file.path is like: "public/uploads/templates/filename.png"
        // URL should be: "https://campaignbuilder.ca/uploads/templates/filename.png"
        let normalizedUrl = req.file.path.replace(/\\/g, '/');
        
        // Remove 'public/' prefix and ensure it starts with '/'
        if (normalizedUrl.startsWith('public/')) {
            normalizedUrl = '/' + normalizedUrl.substring(7); // Remove 'public/' and add leading '/'
        } else if (!normalizedUrl.startsWith('/')) {
            normalizedUrl = '/' + normalizedUrl;
        }
        
        // Make it absolute with HTTPS
        const protocol = 'https'; // Force HTTPS for production
        const host = req.headers['x-forwarded-host'] || req.get('host');
        normalizedUrl = `${protocol}://${host}${normalizedUrl}`;
        
        // Create image record
        const imageRecord = {
            id: imageId,
            userId: req.user.id,
            accountId: accountId,
            url: normalizedUrl,
            name: name || req.file.originalname,
            description: description || '',
            tags: tags && tags.trim() ? tags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0) : [],
            section: section && section.trim() ? section.trim() : 'body',
            size: imageStats.size,
            createdAt: new Date().toISOString(),
            source: 'uploaded',
            isDefault: false
        };
        
        // Prevent duplicate default images
        if (imageRecord.isDefault) {
            // Remove any existing default images of the same type
            allImages = allImages.filter(img => !(img.isDefault === true && img.section === imageRecord.section));
        }
        
        // Add to images array
        allImages.push(imageRecord);
        
        // Save to account-specific storage using standardized function
        await updateAccountImages(accountId, allImages);

        res.json(imageRecord);
    } catch (error) {
        console.error('Error uploading image:', error);
        res.status(500).json({ error: error.message });
    }
});

// Get specific image details
app.get('/api/images/:id', auth, async (req, res) => {
    try {
        const { id } = req.params;
        const db = await readDB();
        
        const image = db.imageLibrary?.images?.[id];
        if (!image) {
            return res.status(404).json({ error: 'Image not found' });
        }
        
        if (image.userId !== req.user.id) {
            return res.status(403).json({ error: 'Access denied' });
        }
        
        res.json({ ...image, url: toRelativeImageUrl(image.url) });
    } catch (error) {
        console.error('Error fetching image:', error);
        res.status(500).json({ error: error.message });
    }
});

// Update image metadata
app.put('/api/images/:id', auth, async (req, res) => {
    try {
        const { id } = req.params;
        const { name, description, category, tags, section } = req.body;
        
        // Get user information for account-specific image retrieval
        const user = await findUserById(req.user.id);
        let allImages = [];
        
        if (user.accountId) {
            // For team members and account holders, get account-specific images
            allImages = await getAccountImages(user.accountId);
        } else {
            // For app owners, use global storage (fallback)
            const imagesPath = path.join(__dirname, 'data', 'images.json');
            try {
                const imagesData = await fsPromises.readFile(imagesPath, 'utf8');
                allImages = JSON.parse(imagesData);
            } catch (error) {
                return res.status(404).json({ error: 'Image database not found' });
            }
        }
        
        const image = allImages.find(img => img.id === id);
        if (!image) {
            return res.status(404).json({ error: 'Image not found' });
        }
        
        // Prevent modification of system default images
        if (image.userId === 'system' && image.isDefault === true) {
            return res.status(403).json({ error: 'Cannot modify system default images' });
        }
        
        if (image.userId !== req.user.id) {
            return res.status(403).json({ error: 'Access denied' });
        }
        
        // Update fields
        if (name !== undefined) image.name = name;
        if (description !== undefined) image.description = description;
        if (section !== undefined) image.section = section;
        if (tags !== undefined) image.tags = Array.isArray(tags) ? tags : tags.split(',').map(tag => tag.trim());
        
        // Save updated images to the correct location
        if (user.accountId) {
            // Save to account-specific shared images file
            const sharedImagesPath = path.join(__dirname, 'data', 'shared-data', user.accountId.toString(), 'images.json');
            await fsPromises.writeFile(sharedImagesPath, JSON.stringify(allImages, null, 2), 'utf8');
        } else {
            // Save to global storage for app owners
            const imagesPath = path.join(__dirname, 'data', 'images.json');
            await fsPromises.writeFile(imagesPath, JSON.stringify(allImages, null, 2), 'utf8');
        }
        
        res.json(image);
    } catch (error) {
        console.error('Error updating image:', error);
        res.status(500).json({ error: error.message });
    }
});

// Delete image
app.delete('/api/images/:id', auth, async (req, res) => {
    try {
        const { id } = req.params;
        
        // Get user information for account-specific image retrieval
        const user = await findUserById(req.user.id);
        const accountId = getEffectiveAccountId(user);
        
        // Get images using standardized function
        let allImages = await getAccountImages(accountId);
        
        // For app owners, also include global images as fallback
        if (user.userType === 'app_owner') {
            const globalImagesPath = path.join(__dirname, 'data', 'images.json');
            const globalImages = await safeReadJsonFile(globalImagesPath, []);
            // Filter to only show app owner's images + system defaults
            const filteredGlobalImages = globalImages.filter(img => 
                img.userId === req.user.id || (img.userId === 'system' && img.isDefault === true)
            );
            allImages = [...allImages, ...filteredGlobalImages];
        }
        
        const image = allImages.find(img => img.id === id);
        if (!image) {
            return res.status(404).json({ error: 'Image not found' });
        }
        
        // Prevent deletion of system default images
        if (image.userId === 'system' && image.isDefault === true) {
            return res.status(403).json({ error: 'Cannot delete system default images' });
        }
        
        // Check access permissions
        let hasAccess = false;
        
        // User owns the image
        if (image.userId === req.user.id) {
            hasAccess = true;
        }
        // User is part of the same account (for team members)
        else if (user.accountId && image.accountId === user.accountId) {
            hasAccess = true;
        }
        // User is the account holder and image belongs to their account
        else if (user.accountId && image.userId === user.accountId) {
            hasAccess = true;
        }
        
        if (!hasAccess) {
            return res.status(403).json({ error: 'Access denied' });
        }
        
        // Check if image is used in any templates
        let isUsedInTemplates = false;
        try {
            // Check templates in the current account
            const templates = await getAccountTemplates(accountId);
            
            for (const template of templates) {
                if (template.headerImage === image.url ||
                    template.bannerImage === image.url ||
                    template.footerImage === image.url ||
                    (template.bodyElements && template.bodyElements.some(el => el.url === image.url))) {
                    isUsedInTemplates = true;
                    break;
                }
            }
        } catch (error) {
            console.warn('Could not check template usage:', error);
        }
        
        // Only delete the file if it's not used in any templates
        if (!isUsedInTemplates) {
            try {
                let filePath = image.url;
                
                // Skip if URL is clearly malformed or contains protocol in wrong place
                if (!filePath || (filePath.includes('://') && !filePath.match(/^https?:\/\//))) {
                    // Malformed URL like "https:/domain" - skip deletion
                    // This is expected for external URLs, so just continue without deleting
                } else {
                    // If it's a full URL, extract just the path portion
                    if (filePath.startsWith('http://') || filePath.startsWith('https://')) {
                        try {
                            const urlObj = new URL(filePath);
                            filePath = urlObj.pathname; // Get just the path part
                        } catch (urlError) {
                            // If URL parsing fails, try to extract path manually
                            const urlMatch = filePath.match(/https?:\/\/[^\/]+(\/.*)/);
                            if (urlMatch && urlMatch[1]) {
                                filePath = urlMatch[1];
                            } else {
                                // Can't parse URL - skip deletion (likely external URL)
                                filePath = null;
                            }
                        }
                    }
                    
                    // Skip if path still looks like it contains a domain/protocol
                    if (filePath && (filePath.includes('://') || (filePath.includes('campaignbuilder.ca') && !filePath.startsWith('/')))) {
                        // Malformed path - skip deletion
                        filePath = null;
                    }
                    
                    // Only proceed if we have a valid file path
                    if (filePath) {
                        // Ensure path starts with / for proper resolution
                        if (!filePath.startsWith('/')) {
                            filePath = '/' + filePath;
                        }
                        
                        // Normalize the path - remove leading /uploads/ to get relative path from public/
                        let relativePath = filePath;
                        if (relativePath.startsWith('/uploads/')) {
                            relativePath = relativePath.substring(1); // Remove leading / to get "uploads/..."
                        } else if (relativePath.startsWith('/public/uploads/')) {
                            relativePath = relativePath.substring(8); // Remove "/public/" to get "uploads/..."
                        } else if (relativePath.startsWith('/public/')) {
                            relativePath = relativePath.substring(8); // Remove "/public/" 
                        }
                        
                        // Construct the full file path
                        const imagePath = path.resolve(__dirname, 'public', relativePath);
                        
                        // Verify the path is within the public directory for security
                        const publicDir = path.resolve(__dirname, 'public');
                        const resolvedPath = path.resolve(imagePath);
                        if (resolvedPath.startsWith(publicDir)) {
                            // Check if file exists before trying to delete
                            try {
                                await fs.promises.access(resolvedPath);
                                await fs.promises.unlink(resolvedPath);
                            } catch (accessError) {
                                // File doesn't exist or can't be accessed - this is fine, just skip
                                if (accessError.code !== 'ENOENT') {
                                    // Only log non-ENOENT errors
                                    console.warn('Could not access/delete image file:', accessError.message);
                                }
                            }
                        }
                    }
                }
            } catch (fileError) {
                // Only log if it's not a "file not found" error (which is expected for external URLs)
                if (fileError.code !== 'ENOENT' && fileError.message !== 'Invalid URL format') {
                    console.warn('Could not delete image file:', fileError.message);
                }
            }
        } else {
            }
        
        // Remove from image library database
        allImages = allImages.filter(img => img.id !== id);
        
        // Save using standardized function
        await updateAccountImages(accountId, allImages);
        
        const message = isUsedInTemplates 
            ? 'Image removed from library (file preserved for templates)' 
            : 'Image deleted successfully';
        
        res.json({ message: message, preservedForTemplates: isUsedInTemplates });
    } catch (error) {
        console.error('Error deleting image:', error);
        res.status(500).json({ error: error.message });
    }
});

// Download image from library
app.get('/api/images/:id/download', auth, async (req, res) => {
    try {
        const { id } = req.params;
        
        // Get user information for account-specific image retrieval
        const user = await findUserById(req.user.id);
        const accountId = getEffectiveAccountId(user);
        
        // Get images using standardized function
        let allImages = await getAccountImages(accountId);
        
        // For app owners, also include global images as fallback
        if (user.userType === 'app_owner') {
            const globalImagesPath = path.join(__dirname, 'data', 'images.json');
            const globalImages = await safeReadJsonFile(globalImagesPath, []);
            // Filter to only show app owner's images + system defaults
            const filteredGlobalImages = globalImages.filter(img => 
                img.userId === req.user.id || (img.userId === 'system' && img.isDefault === true)
            );
            allImages = [...allImages, ...filteredGlobalImages];
        }
        
        const image = allImages.find(img => img.id === id);
        if (!image) {
            return res.status(404).json({ error: 'Image not found' });
        }
        
        // Check access permissions
        let hasAccess = false;
        
        // User owns the image
        if (image.userId === req.user.id) {
            hasAccess = true;
        }
        // User is part of the same account (for team members)
        else if (user.accountId && image.accountId === user.accountId) {
            hasAccess = true;
        }
        // User is the account holder and image belongs to their account
        else if (user.accountId && image.userId === user.accountId) {
            hasAccess = true;
        }
        // System default images are accessible to all
        else if (image.userId === 'system' && image.isDefault === true) {
            hasAccess = true;
        }
        
        if (!hasAccess) {
            return res.status(403).json({ error: 'Access denied' });
        }
        
        // Normalize to relative path so local files are served from same origin
        let imageUrl = toRelativeImageUrl(image.url);
        
        // If it's a local file (starts with /uploads/), serve it directly
        if (imageUrl.startsWith('/uploads/') || imageUrl.startsWith('/public/uploads/')) {
            let filePath = imageUrl;
            
            // Normalize the path
            if (filePath.startsWith('/public/uploads/')) {
                filePath = filePath.substring(8); // Remove "/public/" to get "uploads/..."
            } else if (filePath.startsWith('/uploads/')) {
                filePath = filePath.substring(1); // Remove leading / to get "uploads/..."
            }
            
            const imagePath = path.resolve(__dirname, 'public', filePath);
            const publicDir = path.resolve(__dirname, 'public');
            const resolvedPath = path.resolve(imagePath);
            
            // Security check: ensure path is within public directory
            if (resolvedPath.startsWith(publicDir)) {
                // Check if file exists
                try {
                    await fs.promises.access(resolvedPath);
                    
                    // Get file extension for proper content type
                    const ext = path.extname(resolvedPath).toLowerCase();
                    const contentType = {
                        '.jpg': 'image/jpeg',
                        '.jpeg': 'image/jpeg',
                        '.png': 'image/png',
                        '.gif': 'image/gif',
                        '.webp': 'image/webp',
                        '.svg': 'image/svg+xml'
                    }[ext] || 'application/octet-stream';
                    
                    // Set headers for download
                    const filename = image.name || `image_${id}${ext}`;
                    res.setHeader('Content-Type', contentType);
                    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
                    
                    // Stream the file
                    const fileStream = fs.createReadStream(resolvedPath);
                    fileStream.pipe(res);
                    return;
                } catch (accessError) {
                    if (accessError.code === 'ENOENT') {
                        return res.status(404).json({ error: 'Image file not found' });
                    }
                    throw accessError;
                }
            } else {
                return res.status(403).json({ error: 'Invalid file path' });
            }
        } else {
            // For external URLs, fetch and proxy the image
            try {
                const imageResponse = await fetch(imageUrl);
                
                if (!imageResponse.ok) {
                    return res.status(404).json({ error: 'Failed to fetch image from external source' });
                }
                
                // Get content type from response or infer from URL
                let contentType = imageResponse.headers.get('content-type') || 'application/octet-stream';
                
                // Set headers for download
                const urlPath = new URL(imageUrl).pathname;
                const ext = path.extname(urlPath).toLowerCase() || '.jpg';
                const filename = image.name || `image_${id}${ext}`;
                
                res.setHeader('Content-Type', contentType);
                res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
                
                // Stream the image
                imageResponse.body.pipe(res);
            } catch (fetchError) {
                console.error('Error fetching external image:', fetchError);
                return res.status(500).json({ error: 'Failed to download image: ' + fetchError.message });
            }
        }
    } catch (error) {
        console.error('Error downloading image:', error);
        res.status(500).json({ error: error.message });
    }
});

// Track image usage
app.post('/api/images/:id/usage', auth, async (req, res) => {
    try {
        const { id } = req.params;
        const { templateId, section } = req.body;
        const db = await readDB();
        
        const image = db.imageLibrary?.images?.[id];
        if (!image) {
            return res.status(404).json({ error: 'Image not found' });
        }
        
        if (image.userId !== req.user.id) {
            return res.status(403).json({ error: 'Access denied' });
        }
        
        // Update usage statistics
        image.usage.templateCount = (image.usage.templateCount || 0) + 1;
        image.usage.lastUsedInTemplate = templateId;
        image.metadata.lastUsedAt = new Date().toISOString();
        
        // Add to usage history
        image.usage.usageHistory.push({
            templateId,
            section,
            usedAt: new Date().toISOString()
        });
        
        // Keep only last 50 usage records
        if (image.usage.usageHistory.length > 50) {
            image.usage.usageHistory = image.usage.usageHistory.slice(-50);
        }
        
        await writeDB(db);
        
        res.json({ message: 'Usage tracked successfully' });
    } catch (error) {
        console.error('Error tracking image usage:', error);
        res.status(500).json({ error: error.message });
    }
});

// Get image categories and tags
app.get('/api/images/categories', auth, async (req, res) => {
    try {
        // Get user information for account-specific image retrieval
        const user = await findUserById(req.user.id);
        let allImages = [];
        
        if (user.accountId) {
            // For team members and account holders, get account-specific images
            allImages = await getAccountImages(user.accountId);
        } else {
            // For app owners, use global storage (fallback)
            const imagesPath = path.join(__dirname, 'data', 'images.json');
            try {
                const imagesData = await fsPromises.readFile(imagesPath, 'utf8');
                allImages = JSON.parse(imagesData);
            } catch (error) {
                // If file doesn't exist or is invalid, return empty arrays
                return res.json({
                    categories: [],
                    tags: []
                });
            }
        }
        
        // Get user's images and system default images
        let userImages = allImages.filter(img => img.userId === req.user.id);
        const defaultImages = allImages.filter(img => img.userId === 'system' && img.isDefault === true);
        userImages = [...defaultImages, ...userImages];
        
        // Extract unique sections as categories
        const categories = [...new Set(userImages.map(img => img.section))].sort();
        
        // Extract unique tags
        const tagSet = new Set();
        userImages.forEach(img => {
            if (img.tags && Array.isArray(img.tags)) {
                img.tags.forEach(tag => tagSet.add(tag));
            }
        });
        const tags = Array.from(tagSet).sort();
        
        res.json({
            categories: categories,
            tags: tags
        });
    } catch (error) {
        console.error('Error fetching categories:', error);
        res.status(500).json({ error: error.message });
    }
});

// Add password change endpoint
app.post('/api/user/change-password', auth, async (req, res) => {
    try {
        const { currentPassword, newPassword } = req.body;
        const user = await findUserById(req.user.id);
        
        if (!user) {
            throw new Error('User not found');
        }

        // Validate new password strength
        const passwordValidation = validatePassword(newPassword);
        if (!passwordValidation.isValid) {
            return res.status(400).json({ 
                error: 'New password does not meet security requirements',
                details: passwordValidation.errors
            });
        }

        // Verify current password
        const isValid = await bcrypt.compare(currentPassword, user.password);
        if (!isValid) {
            throw new Error('Current password is incorrect');
        }

        // Hash and update new password with increased salt rounds
        const hashedPassword = await bcrypt.hash(newPassword, 12);
        user.password = hashedPassword;
        
        // Save to appropriate location based on user type
        if (user.accountId && user.userType === 'user') {
            await writeIndividualUserFile(req.user.id, user);
        } else {
            await writeIndividualUserFile(req.user.id, user);
        }
        res.json({ message: 'Password updated successfully' });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// Add company information update endpoint
app.put('/api/user/company', auth, async (req, res) => {
    try {
        const { company } = req.body;
        const user = await findUserById(req.user.id);
        
        if (!user) {
            throw new Error('User not found');
        }

        // Update company information
        user.company = company;
        
        // Save to appropriate location based on user type
        if (user.accountId && user.userType === 'user') {
            await writeIndividualUserFile(req.user.id, user);
        } else {
            await writeIndividualUserFile(req.user.id, user);
        }
        res.json({ 
            message: 'Company information updated successfully',
            company: user.company
        });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// Add personal information update endpoint
app.put('/api/user/personal', auth, async (req, res) => {
    try {
        const { firstName, lastName, email, personalPhone } = req.body;
        const user = await findUserById(req.user.id);
        
        if (!user) {
            throw new Error('User not found');
        }

        // Update personal information
        if (firstName !== undefined) user.firstName = firstName;
        if (lastName !== undefined) user.lastName = lastName;
        
        // Update email if provided and different
        if (email && email !== user.email) {
            // Check if email is already taken
            const userIds = await getAllUserIds();
            for (const userId of userIds) {
                if (userId !== req.user.id) {
                    const otherUser = await findUserById(userId);
                    if (otherUser && otherUser.email === email) {
                        return res.status(400).json({ error: 'Email address is already in use by another account' });
                    }
                }
            }
            user.email = email;
        }
        
        // Update personalInfo.phone for all users
        if (personalPhone !== undefined) {
            if (!user.personalInfo) {
                user.personalInfo = {};
            }
            user.personalInfo.phone = personalPhone;
        }
        
        await writeIndividualUserFile(req.user.id, user);
        
        res.json({ 
            message: 'Personal information updated successfully',
            firstName: user.firstName,
            lastName: user.lastName,
            email: user.email,
            personalPhone: user.personalInfo?.phone
        });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// Add username update endpoint
app.put('/api/user/username', auth, async (req, res) => {
    try {
        const { username } = req.body;
        const user = await findUserById(req.user.id);
        
        if (!user) {
            throw new Error('User not found');
        }

        // Check if username is already taken by another user
        if (username) {
            const userIds = await getAllUserIds();
            for (const userId of userIds) {
                if (userId !== req.user.id) {
                    const otherUser = await findUserById(userId);
                    if (otherUser && otherUser.username === username) {
                        throw new Error('Username already exists');
                    }
                }
            }
        }

        // Update username
        user.username = username;
        
        // Save to appropriate location based on user type
        if (user.accountId && user.userType === 'user') {
            await writeIndividualUserFile(req.user.id, user);
        } else {
            await writeIndividualUserFile(req.user.id, user);
        }
        res.json({ 
            message: 'Username updated successfully',
            username: user.username
        });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// Add user management page route
app.get('/user-management', auth, requireNdaAcceptance, async (req, res) => {
    try {
        // Remove sensitive data before passing to view
        const { password, verificationToken, ...userData } = req.user;
        
        res.render('user-management', {
            path: '/user-management',
            style: '',
            script: '',
            user: userData, // Pass user data to the view
            layout: 'layout'
        });
    } catch (error) {
        console.error('Error serving user management page:', error);
        res.status(500).send('Internal Server Error');
    }
});

// Add image library page route
app.get('/image-library', auth, requireActiveAccount, requireNdaAcceptance, async (req, res) => {
    try {
        res.render('image-library', {
            path: '/image-library',
            style: '',
            script: '',
            user: req.user
        });
    } catch (error) {
        console.error('Error serving image library page:', error);
        res.status(500).send('Internal Server Error');
    }
});

// Paddle: prepare checkout for phone number (client opens Paddle.Checkout.open; fulfillment via webhook)
app.post('/api/numbers/paddle-checkout', auth, async (req, res) => {
    try {
        const { phoneNumber } = req.body;
        if (!phoneNumber || typeof phoneNumber !== 'string') {
            return res.status(400).json({ error: 'phoneNumber is required' });
        }
        if (!PADDLE_CLIENT_TOKEN || !PHONE_NUMBER_PRICE_ID) {
            const missing = [];
            if (!PADDLE_CLIENT_TOKEN) missing.push('PADDLE_CLIENT_TOKEN');
            if (!PHONE_NUMBER_PRICE_ID) missing.push('PHONE_NUMBER_PRICE_ID');
            return res.status(503).json({
                error: 'Paddle checkout is not configured',
                missing
            });
        }
        if (!/^pri_[a-zA-Z0-9]+$/.test(String(PHONE_NUMBER_PRICE_ID)) || /x{4,}/i.test(String(PHONE_NUMBER_PRICE_ID))) {
            return res.status(400).json({
                error: 'PHONE_NUMBER_PRICE_ID is invalid',
                fix: 'Set a real live Paddle price id in .env (format: pri_...) and remove placeholder/duplicate values.'
            });
        }
        const paddleEnv = (process.env.PADDLE_ENV || '').toLowerCase();
        if (paddleEnv === 'sandbox' && /^live_/i.test(PADDLE_CLIENT_TOKEN)) {
            return res.status(400).json({
                error: 'PADDLE_ENV is sandbox but PADDLE_CLIENT_TOKEN is live_*',
                fix: 'Set PADDLE_ENV=production (or use a sandbox test_* token).'
            });
        }
        if ((paddleEnv === 'production' || paddleEnv === 'prod') && /^test_/i.test(PADDLE_CLIENT_TOKEN)) {
            return res.status(400).json({
                error: 'PADDLE_ENV is production but PADDLE_CLIENT_TOKEN is test_*',
                fix: 'Use a live token or switch PADDLE_ENV to sandbox.'
            });
        }
        const user = await findUserById(req.user.id);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        if (!user.pendingPhoneNumbers) user.pendingPhoneNumbers = [];
        user.pendingPhoneNumbers.push({
            number: phoneNumber,
            status: 'pending',
            source: 'paddle',
            createdAt: new Date().toISOString()
        });
        await writeIndividualUserFile(req.user.id, user);
        res.json({
            clientToken: PADDLE_CLIENT_TOKEN,
            priceId: PHONE_NUMBER_PRICE_ID,
            customData: { userId: String(req.user.id), phoneNumber },
            paddleEnv: paddleEnv || 'production'
        });
    } catch (error) {
        console.error('Paddle checkout prep error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Admin: prepare Paddle checkout for a phone number and assign fulfillment to a target account/user.
app.post('/api/admin/numbers/paddle-checkout', adminAuth, async (req, res) => {
    try {
        const { phoneNumber, userId } = req.body || {};
        if (!phoneNumber || typeof phoneNumber !== 'string') {
            return res.status(400).json({ error: 'phoneNumber is required' });
        }
        if (!userId || typeof userId !== 'string') {
            return res.status(400).json({ error: 'userId is required' });
        }
        if (!PADDLE_CLIENT_TOKEN || !PHONE_NUMBER_PRICE_ID) {
            const missing = [];
            if (!PADDLE_CLIENT_TOKEN) missing.push('PADDLE_CLIENT_TOKEN');
            if (!PHONE_NUMBER_PRICE_ID) missing.push('PHONE_NUMBER_PRICE_ID');
            return res.status(503).json({
                error: 'Paddle checkout is not configured',
                missing
            });
        }
        if (!/^pri_[a-zA-Z0-9]+$/.test(String(PHONE_NUMBER_PRICE_ID)) || /x{4,}/i.test(String(PHONE_NUMBER_PRICE_ID))) {
            return res.status(400).json({
                error: 'PHONE_NUMBER_PRICE_ID is invalid',
                fix: 'Set a real live Paddle price id in .env (format: pri_...) and remove placeholder/duplicate values.'
            });
        }
        const paddleEnv = (process.env.PADDLE_ENV || '').toLowerCase();
        if (paddleEnv === 'sandbox' && /^live_/i.test(PADDLE_CLIENT_TOKEN)) {
            return res.status(400).json({
                error: 'PADDLE_ENV is sandbox but PADDLE_CLIENT_TOKEN is live_*',
                fix: 'Set PADDLE_ENV=production (or use a sandbox test_* token).'
            });
        }
        if ((paddleEnv === 'production' || paddleEnv === 'prod') && /^test_/i.test(PADDLE_CLIENT_TOKEN)) {
            return res.status(400).json({
                error: 'PADDLE_ENV is production but PADDLE_CLIENT_TOKEN is test_*',
                fix: 'Use a live token or switch PADDLE_ENV to sandbox.'
            });
        }

        const targetUser = await findUserById(userId);
        if (!targetUser) {
            return res.status(404).json({ error: 'Target user not found' });
        }

        if (!Array.isArray(targetUser.pendingPhoneNumbers)) targetUser.pendingPhoneNumbers = [];
        const alreadyPending = targetUser.pendingPhoneNumbers.some(
            p => p && p.number === phoneNumber && p.status === 'pending'
        );
        if (!alreadyPending) {
            targetUser.pendingPhoneNumbers.push({
                number: phoneNumber,
                status: 'pending',
                source: 'paddle',
                createdAt: new Date().toISOString(),
                createdByAdmin: String(req.user.id)
            });
            await writeIndividualUserFile(targetUser.id, targetUser);
        }

        return res.json({
            clientToken: PADDLE_CLIENT_TOKEN,
            priceId: PHONE_NUMBER_PRICE_ID,
            customData: { userId: String(targetUser.id), phoneNumber },
            paddleEnv: paddleEnv || 'production'
        });
    } catch (error) {
        console.error('Admin Paddle checkout prep error:', error);
        return res.status(400).json({ error: error.message || 'Failed to prepare checkout' });
    }
});

// Internal: fulfill phone number purchase after Paddle payment (Twilio buy + shared-data)
async function fulfillPhoneNumberPurchase(userId, phoneNumber, paddleTransactionId) {
    const user = await findUserById(userId);
    if (!user) throw new Error('User not found');
    const pending = user.pendingPhoneNumbers?.find(
        p => p.number === phoneNumber && (p.source === 'paddle' || !p.subscriptionId) && p.status === 'pending'
    );
    if (!pending) throw new Error('Pending number not found');
    const purchasedNumber = await twilioClient.incomingPhoneNumbers.create({
        phoneNumber,
        smsUrl: `${BASE_URL}/api/webhooks/sms/${userId}`,
        statusCallback: `${BASE_URL}/api/webhooks/status/${userId}`
    });
    const phoneAccountId = user.accountId || user.id;
    const phoneSharedDataPath = path.join(SHARED_DATA_DIR, String(phoneAccountId));
    const phoneNumbersPath = path.join(phoneSharedDataPath, 'phoneNumbers.json');
    await fsPromises.mkdir(phoneSharedDataPath, { recursive: true });
    let phoneNumbers = [];
    if (fs.existsSync(phoneNumbersPath)) {
        const data = await fsPromises.readFile(phoneNumbersPath, 'utf8');
        phoneNumbers = JSON.parse(data);
    }
    phoneNumbers.push({
        id: purchasedNumber.sid,
        number: purchasedNumber.phoneNumber,
        purchasedAt: new Date().toISOString(),
        monthlyPrice: 4.00,
        paddleTransactionId: paddleTransactionId || null,
        isDefault: phoneNumbers.length === 0
    });
    await fsPromises.writeFile(phoneNumbersPath, JSON.stringify(phoneNumbers, null, 2), 'utf8');
    if (!user.defaultSendingNumber) user.defaultSendingNumber = purchasedNumber.phoneNumber;
    user.pendingPhoneNumbers = user.pendingPhoneNumbers.filter(
        p => !(p.number === phoneNumber && (p.source === 'paddle' || !p.subscriptionId))
    );
    await writeIndividualUserFile(userId, user);
    return purchasedNumber;
}

// DEPRECATED - Phone number purchases use Paddle
app.post('/api/numbers/initialize-purchase', auth, async (req, res) => {
    return res.status(410).json({ error: 'Phone number purchases now use Paddle. Please use the Paddle checkout on this page.' });
});

// DEPRECATED - Fulfillment via Paddle webhook
app.post('/api/numbers/complete-purchase', auth, async (req, res) => {
    return res.status(410).json({ error: 'Phone number purchases now use Paddle. Fulfillment happens automatically after payment.' });
});

// Phone number subscriptions are via Paddle; cancel in Paddle Dashboard
app.post('/api/phone-numbers/cancel-subscription', auth, async (req, res) => {
    return res.status(400).json({ error: 'Phone number subscriptions are via Paddle. Cancel from your Paddle account or contact support.' });
}); 

// Simplify the email stats endpoint to focus on bounces
app.get('/api/email/stats', auth, async (req, res) => {
    try {
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }
        
        const userSenderEmail = user.senderEmails?.[0]?.EmailAddress;

        // Get user's email messages
        const userEmails = user.emailMessages?.sent || [];
        const totalRecipients = userEmails.reduce((sum, msg) => sum + (msg.recipientCount || 0), 0);
        
        // SMTP doesn't have built-in bounce API - bounces would need to be tracked via webhooks or database
        // For now, return empty bounces array
        let bounces = [];

        // Format bounce information
        const bouncedEmails = bounces.map(bounce => ({
            email: bounce.Email,
            type: bounce.Type,
            reason: bounce.Description,
            details: bounce.Details,
            time: bounce.BouncedAt,
            subject: bounce.Subject
        }));

        // Calculate stats
        const stats = {
            totalSent: totalRecipients,
            totalBounces: bounces.length,
            delivered: totalRecipients - bounces.length
        };

        res.json({
            stats,
            bouncedEmails
        });
    } catch (error) {
        console.error('Error fetching email stats:', error);
        res.status(500).json({ error: 'Failed to fetch email statistics' });
    }
});

// Removed deprecated /email-reports route (page no longer used)

// Get senders endpoint
app.get('/api/email/senders', auth, async (req, res) => {
    try {
        const user = await findUserById(req.user.id);
        
        if (!user) {
            throw new Error('User not found');
        }

        let senderEmails = [];
        
        // Use getEffectiveAccountId to get the correct account ID
        const accountId = getEffectiveAccountId(user);
        const sendersPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'senders.json');
        
        // First, try to get sender emails from shared data structure
        if (fs.existsSync(sendersPath)) {
            const data = await fsPromises.readFile(sendersPath, 'utf8');
            senderEmails = JSON.parse(data);
        }
        
        // Also check user's senderEmails array for backward compatibility
        // Merge and deduplicate by EmailAddress
        if (user.senderEmails && Array.isArray(user.senderEmails)) {
            const existingEmails = new Set(senderEmails.map(s => s.EmailAddress?.toLowerCase()));
            user.senderEmails.forEach(sender => {
                const emailLower = sender.EmailAddress?.toLowerCase();
                if (emailLower && !existingEmails.has(emailLower)) {
                    senderEmails.push(sender);
                    existingEmails.add(emailLower);
                }
            });
        }
        
        // If still no senders found and user has accountId, try account holder's user file
        if (senderEmails.length === 0 && user.accountId && user.accountId !== user.id) {
            const accountHolder = await findUserById(user.accountId);
            if (accountHolder?.senderEmails) {
                senderEmails = accountHolder.senderEmails;
            }
        }
        
        // SMTP mode - return senders as-is (no external API status check)
        res.json(senderEmails);
    } catch (error) {
        console.error('Get senders error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add sender endpoint
app.post('/api/email/senders', auth, requirePermission('manage_settings'), async (req, res) => {
    try {

        const { email } = req.body;
        if (!email || typeof email !== 'string') {
            throw new Error('Valid email is required');
        }

        // Normalize and validate email
        const normalizedEmail = email.trim().toLowerCase();
        if (!isValidEmail(normalizedEmail)) {
            throw new Error('Invalid email format');
        }

        const user = await findUserById(req.user.id);
        
        if (!user) {
            throw new Error('User not found');
        }

        // Use getEffectiveAccountId to get the correct account ID
        const accountId = getEffectiveAccountId(user);
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const sendersPath = path.join(sharedDataPath, 'senders.json');
        
        // Ensure shared-data directory exists
        await fsPromises.mkdir(sharedDataPath, { recursive: true });
        
        // Load existing senders
        let senderEmails = [];
        if (fs.existsSync(sendersPath)) {
            const data = await fsPromises.readFile(sendersPath, 'utf8');
            senderEmails = JSON.parse(data);
        }

        // Check if email already exists (using normalized email)
        if (senderEmails.some(s => s.EmailAddress?.toLowerCase() === normalizedEmail)) {
            throw new Error('Email already exists');
        }

        // SMTP doesn't require sender signature creation - just create the sender record
        // Generate a unique ID for the sender
        const senderId = Date.now().toString() + '-' + Math.floor(Math.random() * 1000000);

        // Add new sender (SMTP mode)
        const newSender = {
            id: senderId,
            EmailAddress: normalizedEmail,
            Confirmed: true, // SMTP senders are considered confirmed
            Domain: normalizedEmail.split('@')[1],
            showSteps: false, // No verification steps needed for SMTP
            verificationDetails: {
                spfHost: normalizedEmail.split('@')[1],
                spfTextValue: "v=spf1 a mx include:mail.sw7ft.com ~all",
                dkimHost: `mail._domainkey.${normalizedEmail.split('@')[1]}`,
                dkimTextValue: null, // DKIM would be configured at the SMTP server level
                returnPathDomain: "mail.sw7ft.com",
                returnPathHost: "bounces",
                spfVerified: false,
                dkimVerified: false,
                returnPathDomainVerified: false
            },
            createdAt: new Date().toISOString(),
            emailConfirmed: true // SMTP senders don't require email confirmation
        };

        // Save to shared data structure (all users use shared-data now)
        try {
            // Add new sender to the array
            senderEmails.push(newSender);
            
            // Save to shared data
            await fsPromises.writeFile(sendersPath, JSON.stringify(senderEmails, null, 2));
            
            // Also update account holder's user file for backward compatibility
            // Only update if this is an account holder (accountId === user.id) or team member
            if (user.accountId) {
                const accountHolder = await findUserById(user.accountId);
                if (accountHolder) {
                    if (!accountHolder.senderEmails) {
                        accountHolder.senderEmails = [];
                    }
                    // Remove duplicate if exists, then add
                    accountHolder.senderEmails = accountHolder.senderEmails.filter(
                        s => s.EmailAddress?.toLowerCase() !== normalizedEmail
                    );
                    accountHolder.senderEmails.push(newSender);
                    await writeIndividualUserFile(user.accountId, accountHolder);
                }
            } else {
                // For app owners without accountId, also update their user file
                if (!user.senderEmails) {
                    user.senderEmails = [];
                }
                user.senderEmails = user.senderEmails.filter(
                    s => s.EmailAddress?.toLowerCase() !== normalizedEmail
                );
                user.senderEmails.push(newSender);
                await writeIndividualUserFile(req.user.id, user);
            }
        } catch (dbError) {
            console.error('Database save error:', dbError);
            throw new Error('Failed to save sender to database');
        }

        res.json({
            message: 'Sender added successfully. You can now use this email address to send emails via SMTP.',
            sender: newSender
        });
    } catch (error) {
        console.error('Add sender error:', error);
        res.status(400).json({ error: error.message });
    }
});

// ============================================
// SMTP SETTINGS MANAGEMENT API
// ============================================

// Get user's SMTP settings
app.get('/api/smtp/settings', auth, async (req, res) => {
    try {
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }

        const accountId = getEffectiveAccountId(user);
        const smtpSettingsPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'smtp-settings.json');
        
        if (fs.existsSync(smtpSettingsPath)) {
            const data = await fsPromises.readFile(smtpSettingsPath, 'utf8');
            const smtpSettings = JSON.parse(data);
            
            // Don't return password in response
            const { pass, ...safeSettings } = smtpSettings;
            res.json({
                ...safeSettings,
                hasPassword: !!pass
            });
        } else {
            // Return global settings info (without password)
            res.json({
                host: process.env.SMTP_HOST || 'mail.sw7ft.com',
                port: parseInt(process.env.SMTP_PORT) || 587,
                secure: process.env.SMTP_SECURE === 'true',
                user: process.env.SMTP_USER || process.env.EMAIL_USER || null,
                hasPassword: !!(process.env.SMTP_PASS || process.env.EMAIL_PASSWORD),
                isGlobal: true
            });
        }
    } catch (error) {
        // Don't log or expose sensitive information
        const safeErrorMessage = error.message ? error.message.replace(/password|pass|auth|credential|user|username/gi, '[REDACTED]') : 'Unknown error';
        console.error('[SMTP] Get settings error:', safeErrorMessage);
        res.status(400).json({ error: safeErrorMessage });
    }
});

// Save/update user's SMTP settings
app.post('/api/smtp/settings', auth, requirePermission('manage_settings'), async (req, res) => {
    try {
        const { host, port, secure, user, pass } = req.body;
        
        // Validate required fields
        if (!host || !user || !pass) {
            throw new Error('Host, username, and password are required');
        }
        
        // Validate host format
        if (typeof host !== 'string' || host.trim().length === 0) {
            throw new Error('Invalid SMTP host');
        }
        
        // Validate port
        const portNum = parseInt(port);
        if (isNaN(portNum) || portNum < 1 || portNum > 65535) {
            throw new Error('Invalid SMTP port (must be 1-65535)');
        }
        
        // Validate username
        if (typeof user !== 'string' || user.trim().length === 0) {
            throw new Error('Invalid SMTP username');
        }
        
        // Validate password
        if (typeof pass !== 'string' || pass.length === 0) {
            throw new Error('Invalid SMTP password');
        }
        
        const userObj = await findUserById(req.user.id);
        if (!userObj) {
            throw new Error('User not found');
        }

        const accountId = getEffectiveAccountId(userObj);
        const sharedDataPath = path.join(__dirname, 'data', 'shared-data', accountId.toString());
        const smtpSettingsPath = path.join(sharedDataPath, 'smtp-settings.json');
        
        // Ensure directory exists
        await fsPromises.mkdir(sharedDataPath, { recursive: true });
        
        // Save SMTP settings
        // Handle security options: 'none', false (STARTTLS), or true (SSL/TLS)
        let secureOption;
        if (secure === 'none') {
            secureOption = false;
        } else if (secure === true || secure === 'true' || portNum === 465) {
            secureOption = true;
        } else {
            secureOption = false;
        }
        
        const smtpSettings = {
            host: host.trim(),
            port: portNum,
            secure: secureOption,
            ignoreTLS: secure === 'none', // Disable TLS entirely if 'none' is selected
            requireTLS: secure === false || secure === 'false', // Require STARTTLS if explicitly set to false
            user: user.trim(),
            pass: pass, // Store password (will be encrypted in production)
            updatedAt: new Date().toISOString(),
            updatedBy: req.user.id
        };
        
        await fsPromises.writeFile(smtpSettingsPath, JSON.stringify(smtpSettings, null, 2), 'utf8');
        
        // Clear cache so new settings are used
        clearUserSMTPCache(accountId);
        
        // If the username is an email address, automatically create/add it as a sender email
        const normalizedUser = user.trim().toLowerCase();
        if (isValidEmail(normalizedUser)) {
            try {
                const sendersPath = path.join(sharedDataPath, 'senders.json');
                let senderEmails = [];
                
                // Load existing senders
                if (fs.existsSync(sendersPath)) {
                    const data = await fsPromises.readFile(sendersPath, 'utf8');
                    senderEmails = JSON.parse(data);
                }
                
                // Check if email already exists
                const emailExists = senderEmails.some(s => s.EmailAddress?.toLowerCase() === normalizedUser);
                
                if (!emailExists) {
                    // Create new sender email
                    const senderId = Date.now().toString() + '-' + Math.floor(Math.random() * 1000000);
                    const newSender = {
                        id: senderId,
                        EmailAddress: normalizedUser,
                        Confirmed: true, // SMTP senders are considered confirmed
                        Domain: normalizedUser.split('@')[1],
                        showSteps: false,
                        verificationDetails: {
                            spfHost: normalizedUser.split('@')[1],
                            spfTextValue: "v=spf1 a mx include:mail.sw7ft.com ~all",
                            dkimHost: `mail._domainkey.${normalizedUser.split('@')[1]}`,
                            dkimTextValue: null,
                            returnPathDomain: "mail.sw7ft.com",
                            returnPathHost: "bounces",
                            spfVerified: false,
                            dkimVerified: false,
                            returnPathDomainVerified: false
                        },
                        createdAt: new Date().toISOString(),
                        emailConfirmed: true
                    };
                    
                    senderEmails.push(newSender);
                    await fsPromises.writeFile(sendersPath, JSON.stringify(senderEmails, null, 2), 'utf8');
                    
                    // Also update user file for backward compatibility
                    if (userObj.accountId) {
                        const accountHolder = await findUserById(userObj.accountId);
                        if (accountHolder) {
                            if (!accountHolder.senderEmails) {
                                accountHolder.senderEmails = [];
                            }
                            accountHolder.senderEmails = accountHolder.senderEmails.filter(
                                s => s.EmailAddress?.toLowerCase() !== normalizedUser
                            );
                            accountHolder.senderEmails.push(newSender);
                            await writeIndividualUserFile(userObj.accountId, accountHolder);
                        }
                    } else {
                        if (!userObj.senderEmails) {
                            userObj.senderEmails = [];
                        }
                        userObj.senderEmails = userObj.senderEmails.filter(
                            s => s.EmailAddress?.toLowerCase() !== normalizedUser
                        );
                        userObj.senderEmails.push(newSender);
                        await writeIndividualUserFile(req.user.id, userObj);
                    }
                }
            } catch (senderError) {
                // Don't fail SMTP save if sender creation fails, just log it
                console.error('Failed to auto-create sender email:', senderError);
            }
        }
        
        // Don't return password in response
        const { pass: _, ...safeSettings } = smtpSettings;
        
        res.json({
            message: 'SMTP settings saved successfully',
            settings: safeSettings
        });
    } catch (error) {
        // Don't log or expose sensitive information
        const safeErrorMessage = error.message ? error.message.replace(/password|pass|auth|credential|user|username/gi, '[REDACTED]') : 'Unknown error';
        console.error('[SMTP] Save settings error:', safeErrorMessage);
        res.status(400).json({ error: safeErrorMessage });
    }
});

// Test SMTP connection with user's settings
app.post('/api/smtp/test', auth, requirePermission('manage_settings'), async (req, res) => {
    try {
        const { host, port, secure, user, pass } = req.body;
        
        // Validate required fields
        if (!host || !user || !pass) {
            throw new Error('Host, username, and password are required for testing');
        }
        
        const portNum = parseInt(port) || 587;
        
        // Handle security options: 'none', false (STARTTLS), or true (SSL/TLS)
        let secureOption;
        if (secure === 'none') {
            secureOption = false;
        } else if (secure === true || secure === 'true' || portNum === 465) {
            secureOption = true;
        } else {
            secureOption = false;
        }
        
        // Create test transporter config
        const testConfig = {
            host: host.trim(),
            port: portNum,
            secure: secureOption,
            auth: {
                user: user.trim(),
                pass: pass
            }
        };
        
        // Handle TLS options
        if (secure === 'none') {
            // No encryption at all
            testConfig.ignoreTLS = true;
            testConfig.secure = false;
        } else if (secure === false || secure === 'false') {
            // STARTTLS (upgrade to TLS)
            testConfig.requireTLS = true;
            testConfig.secure = false;
        }
        
        const testTransporter = nodemailer.createTransport(testConfig);
        
        // Test connection
        await testTransporter.verify();
        
        res.json({
            success: true,
            message: 'SMTP connection test successful'
        });
    } catch (error) {
        // Don't log or expose sensitive information
        const safeErrorMessage = error.message ? error.message.replace(/password|pass|auth|credential|user|username/gi, '[REDACTED]') : 'Connection test failed';
        console.error('[SMTP] Test connection error:', safeErrorMessage);
        res.status(400).json({ 
            success: false,
            error: `SMTP connection test failed: ${safeErrorMessage}`
        });
    }
});

// Delete user's SMTP settings (fall back to global)
app.delete('/api/smtp/settings', auth, requirePermission('manage_settings'), async (req, res) => {
    try {
        const user = await findUserById(req.user.id);
        if (!user) {
            throw new Error('User not found');
        }

        const accountId = getEffectiveAccountId(user);
        const smtpSettingsPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'smtp-settings.json');
        
        if (fs.existsSync(smtpSettingsPath)) {
            await fsPromises.unlink(smtpSettingsPath);
            
            // Clear cache
            clearUserSMTPCache(accountId);
            
            res.json({
                message: 'SMTP settings removed. System will use global SMTP settings.'
            });
        } else {
            res.json({
                message: 'No custom SMTP settings found. System is already using global SMTP settings.'
            });
        }
    } catch (error) {
        console.error('Delete SMTP settings error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add SMS messages API endpoint
app.get('/api/sms/messages', auth, async (req, res) => {
    try {
        const { page = 1, number } = req.query;
        const pageSize = 20;

        const user = await findUserById(req.user.id);
        
        // Get phone numbers from shared-data
        const accountId = user.accountId || user.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        const phoneNumbersPath = path.join(sharedDataPath, 'phoneNumbers.json');
        
        let phoneNumbers = [];
        if (fs.existsSync(phoneNumbersPath)) {
            const phoneNumbersData = JSON.parse(fs.readFileSync(phoneNumbersPath, 'utf8'));
            phoneNumbers = phoneNumbersData.map(n => n.number);
        }
        
        if (phoneNumbers.length === 0) {
            throw new Error('No phone numbers found for this account');
        }

        // Get messages for the specified number or all account's numbers
        const targetNumbers = number ? 
            [number] : 
            phoneNumbers;

        // Fetch messages from Twilio
        let allMessages = [];
        for (const phoneNumber of targetNumbers) {
            const messages = await twilioClient.messages.list({
                from: phoneNumber,
                pageSize: pageSize,
                page: parseInt(page)
            });
            allMessages = allMessages.concat(messages);
        }

        // Sort messages by date
        allMessages.sort((a, b) => new Date(b.dateSent) - new Date(a.dateSent));

        // Calculate stats
        const stats = {
            totalSent: allMessages.length,
            delivered: allMessages.filter(m => m.status === 'delivered').length,
            failed: allMessages.filter(m => m.status === 'failed').length,
            pending: allMessages.filter(m => ['queued', 'sending', 'scheduled'].includes(m.status)).length
        };

        // Check if there are more pages
        const hasNextPage = allMessages.length === pageSize;
        const hasPreviousPage = page > 1;

        res.json({
            messages: allMessages.map(message => ({
                sid: message.sid,
                from: message.from,
                to: message.to,
                body: message.body,
                status: message.status,
                errorCode: message.errorCode,
                dateSent: message.dateSent,
                direction: message.direction,
                price: message.price
            })),
            stats,
            hasNextPage,
            hasPreviousPage
        });
    } catch (error) {
        console.error('Error fetching SMS messages:', error);
        res.status(400).json({ error: error.message });
    }
});

// Add Twilio number search endpoint
app.get('/api/numbers/search', auth, async (req, res) => {
    try {
        const { areaCode } = req.query;
        
        if (!areaCode) {
            throw new Error('Area code is required');
        }

        const numbers = await twilioClient.availablePhoneNumbers('CA')
            .local
            .list({
                areaCode: parseInt(areaCode),
                limit: 10
            });

        res.json({
            numbers: numbers.map(number => ({
                phoneNumber: number.phoneNumber,
                friendlyName: number.friendlyName,
                locality: number.locality,
                region: number.region,
                monthlyPrice: '4.00' // Standard Twilio price for Canadian numbers
            }))
        });
    } catch (error) {
        console.error('Error searching numbers:', error);
        
        // Handle Twilio authentication errors specifically
        if (error.code === 20003) {
            res.status(500).json({ 
                error: 'Twilio service temporarily unavailable. Please try again later or contact support.' 
            });
        } else {
            res.status(400).json({ error: error.message });
        }
    }
});

// Get unsubscribe stats (requires auth)
app.get('/api/unsubscribe/stats', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const accountId = getEffectiveAccountId(user);
    const contacts = await getAccountContacts(accountId);
    
    let emailUnsubscribes = 0;
    let smsUnsubscribes = 0;
    let voiceUnsubscribes = 0;
    let allChannelsBlocked = 0;
    
    contacts.forEach(contact => {
      const prefs = contact.communicationPreferences || {};
      const emailSubscribed = !prefs.email || prefs.email.subscribed !== false;
      const smsSubscribed = !prefs.sms || prefs.sms.subscribed !== false;
      const voiceSubscribed = !prefs.voice || prefs.voice.subscribed !== false;
      
      if (!emailSubscribed) emailUnsubscribes++;
      if (!smsSubscribed) smsUnsubscribes++;
      if (!voiceSubscribed) voiceUnsubscribes++;
      if (!emailSubscribed && !smsSubscribed && !voiceSubscribed) {
        allChannelsBlocked++;
      }
    });
    
    res.json({
      totalContacts: contacts.length,
      emailUnsubscribes,
      smsUnsubscribes,
      voiceUnsubscribes,
      allChannelsBlocked
    });
  } catch (error) {
    console.error('Get unsubscribe stats error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get unsubscribe log (requires auth)
app.get('/api/unsubscribe/log', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const accountId = getEffectiveAccountId(user);
    const logPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'unsubscribe-log.json');
    
    const log = await safeReadJsonFile(logPath, []);
    res.json(log);
  } catch (error) {
    console.error('Get unsubscribe log error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Upload unsubscribes from CSV (requires auth)
app.post('/api/unsubscribe/upload', auth, upload.single('file'), async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }
    
    const accountId = getEffectiveAccountId(user);
    const logPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'unsubscribe-log.json');
    
    // Read existing log
    const existingLog = await safeReadJsonFile(logPath, []);
    const existingEmails = new Set(existingLog.map(u => u.email?.toLowerCase()).filter(Boolean));
    
    // Parse CSV content
    const csvContent = req.file.buffer.toString('utf-8');
    const lines = csvContent.split(/\r?\n/).filter(line => line.trim());
    
    // Skip header row
    const dataLines = lines.slice(1);
    
    let imported = 0;
    let skipped = 0;
    const newEntries = [];
    
    for (const line of dataLines) {
      // Parse CSV line (handle quoted fields)
      const fields = line.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];
      const cleanFields = fields.map(f => f.replace(/^"|"$/g, '').trim());
      
      const [email, channel, reason] = cleanFields;
      
      if (!email || !email.includes('@')) {
        continue; // Skip invalid emails
      }
      
      const normalizedEmail = email.toLowerCase();
      
      // Check for duplicates
      if (existingEmails.has(normalizedEmail)) {
        skipped++;
        continue;
      }
      
      // Add to unsubscribe log
      const entry = {
        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
        email: normalizedEmail,
        channel: (channel || 'email').toLowerCase(),
        reason: reason || 'Imported via CSV',
        timestamp: new Date().toISOString(),
        source: 'csv_import'
      };
      
      newEntries.push(entry);
      existingEmails.add(normalizedEmail);
      imported++;
      
      // Also add to suppression list for email campaigns
      if (entry.channel === 'email' || !entry.channel) {
        try {
          await addToSuppressionList(accountId, normalizedEmail, 'unsubscribe', 'CSV import');
        } catch (suppError) {
          console.error('Error adding to suppression list:', suppError);
        }
      }
    }
    
    // Save updated log
    if (newEntries.length > 0) {
      const updatedLog = [...existingLog, ...newEntries];
      await safeWriteJsonFile(logPath, updatedLog);
    }
    
    res.json({ 
      success: true, 
      imported, 
      skipped,
      total: existingLog.length + newEntries.length
    });
    
  } catch (error) {
    console.error('Upload unsubscribe CSV error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get suppression list
app.get('/api/suppression-list', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const accountId = getEffectiveAccountId(user);
    const suppressionList = await getSuppressionList(accountId);
    res.json(suppressionList);
  } catch (error) {
    console.error('Get suppression list error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================================================
// EMAIL QUEUE API ENDPOINTS
// ============================================================================

// Get email queue for account
app.get('/api/email/queue', auth, async (req, res) => {
    try {
        const user = req.user;
        const accountId = getEffectiveAccountId(user);
        const queue = await getEmailQueue(accountId);
        
        // Filter by status if provided
        const status = req.query.status;
        let filteredQueue = queue;
        if (status) {
            filteredQueue = queue.filter(entry => entry.status === status);
        }
        
        // Filter by domain if provided
        const domain = req.query.domain;
        if (domain) {
            filteredQueue = filteredQueue.filter(entry => entry.domain === domain);
        }
        
        res.json({
            success: true,
            queue: filteredQueue,
            total: queue.length,
            pending: queue.filter(e => e.status === 'pending').length,
            processing: queue.filter(e => e.status === 'processing').length,
            completed: queue.filter(e => e.status === 'completed').length,
            failed: queue.filter(e => e.status === 'failed').length
        });
    } catch (error) {
        console.error('Get email queue error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Process email queue manually
app.post('/api/email/queue/process', auth, async (req, res) => {
    try {
        const user = req.user;
        const accountId = getEffectiveAccountId(user);
        const domain = req.body.domain || null;
        
        const result = await processEmailQueue(accountId, domain);
        
        res.json({
            success: true,
            message: `Processed ${result.processed} queue entries, sent ${result.sent} emails`,
            processed: result.processed,
            sent: result.sent,
            remaining: result.remaining
        });
    } catch (error) {
        console.error('Process email queue error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Delete queue entry
app.delete('/api/email/queue/:queueId', auth, async (req, res) => {
    try {
        const user = req.user;
        const accountId = getEffectiveAccountId(user);
        const queueId = req.params.queueId;
        
        const result = await removeFromEmailQueue(accountId, queueId);
        
        if (result.success) {
            res.json({ success: true, message: result.message });
        } else {
            res.status(404).json({ error: result.message });
        }
    } catch (error) {
        console.error('Delete queue entry error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Get queue statistics
app.get('/api/email/queue/stats', auth, async (req, res) => {
    try {
        const user = req.user;
        const accountId = getEffectiveAccountId(user);
        const queue = await getEmailQueue(accountId);
        
        const stats = {
            total: queue.length,
            pending: queue.filter(e => e.status === 'pending').length,
            processing: queue.filter(e => e.status === 'processing').length,
            completed: queue.filter(e => e.status === 'completed').length,
            failed: queue.filter(e => e.status === 'failed').length,
            totalRecipients: queue.reduce((sum, e) => sum + (e.recipients?.length || 0), 0),
            pendingRecipients: queue
                .filter(e => e.status === 'pending')
                .reduce((sum, e) => sum + (e.recipients?.length || 0), 0),
            byDomain: {}
        };
        
        // Group by domain
        queue.forEach(entry => {
            if (!stats.byDomain[entry.domain]) {
                stats.byDomain[entry.domain] = {
                    total: 0,
                    pending: 0,
                    recipients: 0
                };
            }
            stats.byDomain[entry.domain].total++;
            if (entry.status === 'pending') {
                stats.byDomain[entry.domain].pending++;
                stats.byDomain[entry.domain].recipients += entry.recipients?.length || 0;
            }
        });
        
        res.json({ success: true, stats });
    } catch (error) {
        console.error('Get queue stats error:', error);
        res.status(400).json({ error: error.message });
    }
});

// Admin endpoint: Manually trigger queue processing for all accounts
app.post('/api/admin/email/queues/process', adminAuth, async (req, res) => {
    try {
        const result = await processEmailQueues();
        res.json({
            success: true,
            message: 'Queue processing triggered for all accounts',
            triggered: true
        });
    } catch (error) {
        console.error('Admin trigger queue processing error:', error);
        res.status(500).json({ error: error.message });
    }
});

// Admin endpoint: Get all email queues across all accounts
app.get('/api/admin/email/queues', adminAuth, async (req, res) => {
    try {
        const sharedDataDir = path.join(__dirname, 'data', 'shared-data');
        
        if (!fs.existsSync(sharedDataDir)) {
            return res.json({ success: true, queues: [], totalAccounts: 0 });
        }
        
        const accountDirs = fs.readdirSync(sharedDataDir).filter(f => {
            const accountPath = path.join(sharedDataDir, f);
            return fs.statSync(accountPath).isDirectory();
        });
        
        const allQueues = [];
        let totalPending = 0;
        let totalRecipients = 0;
        
        for (const accountDir of accountDirs) {
            try {
                const accountId = accountDir;
                const queue = await getEmailQueue(accountId);
                
                if (queue.length === 0) {
                    continue;
                }
                
                const pending = queue.filter(e => e.status === 'pending');
                const pendingRecipients = pending.reduce((sum, e) => sum + (e.recipients?.length || 0), 0);
                
                totalPending += pending.length;
                totalRecipients += pendingRecipients;
                
                // Get warmup info for each domain
                const domains = [...new Set(queue.map(e => e.domain))];
                const domainInfo = {};
                
                for (const domain of domains) {
                    try {
                        const warmupData = await getDomainWarmupData(accountId, domain);
                        const warmupCheck = await checkDomainWarmup(accountId, domain, 1);
                        domainInfo[domain] = {
                            sentToday: warmupCheck.sentToday,
                            dailyLimit: warmupCheck.dailyLimit,
                            available: warmupCheck.available,
                            currentDay: warmupCheck.currentDay
                        };
                    } catch (err) {
                        domainInfo[domain] = { error: err.message };
                    }
                }
                
                allQueues.push({
                    accountId,
                    total: queue.length,
                    pending: pending.length,
                    processing: queue.filter(e => e.status === 'processing').length,
                    completed: queue.filter(e => e.status === 'completed').length,
                    failed: queue.filter(e => e.status === 'failed').length,
                    pendingRecipients,
                    domainInfo,
                    entries: queue.map(e => ({
                        id: e.id,
                        domain: e.domain,
                        status: e.status,
                        recipients: e.recipients?.length || 0,
                        queuedAt: e.queuedAt,
                        error: e.error
                    }))
                });
            } catch (error) {
                console.error(`[ADMIN-QUEUE] Error processing account ${accountDir}:`, error.message);
            }
        }
        
        res.json({
            success: true,
            queues: allQueues,
            summary: {
                totalAccounts: accountDirs.length,
                accountsWithQueues: allQueues.length,
                totalPendingEntries: totalPending,
                totalPendingRecipients: totalRecipients
            }
        });
    } catch (error) {
        console.error('Admin get all queues error:', error);
        res.status(500).json({ error: error.message });
    }
});

// Remove email from suppression list
app.delete('/api/suppression-list/:email', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const accountId = getEffectiveAccountId(user);
    const email = decodeURIComponent(req.params.email);
    
    const result = await removeFromSuppressionList(accountId, email);
    res.json(result);
  } catch (error) {
    console.error('Remove from suppression list error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Public unsubscribe page (no auth required)
app.get('/unsubscribe', async (req, res) => {
    res.render('unsubscribe', {
        title: 'Unsubscribe - Campaign Builder'
    });
});

app.get('/contact-manager', auth, requireActiveAccount, requireNdaAcceptance, async (req, res) => {
  try {
    res.render('contact-manager', {
      user: req.user,
      path: '/contact-manager',
      layout: 'layout'
    });
  } catch (error) {
    return redirectToLogin(res, req, 'contact-manager', 'CATCH');
  }
});

// Debug route to check admin status
app.get('/admin/debug', auth, (req, res) => {

  res.json({
    user: req.user.email,
    isAdmin: req.user.isAdmin,
    userId: req.user.id
  });
});

// Admin audit logs page
app.get('/admin/audit-logs', adminAuth, (req, res) => {

  res.render('admin-audit-logs', {
    user: req.user,
    path: '/admin/audit-logs',
    layout: 'layout'
  });
});

// Admin sender settings (email) - set up sender emails per account
app.get('/admin/sender-settings', adminAuth, (req, res) => {
  res.render('admin/sender-settings', {
    user: req.user,
    path: '/admin/sender-settings',
    layout: 'layout'
  });
});

// Admin phone numbers - purchase and assign phone numbers to accounts
app.get('/admin/phone-numbers', adminAuth, (req, res) => {
  res.render('admin/phone-numbers', {
    user: req.user,
    path: '/admin/phone-numbers',
    layout: 'layout'
  });
});

app.get('/admin/help-tickets', auth, requirePermission('manage_users'), async (req, res) => {
  try {

    res.render('admin/help-tickets', {
      user: req.user,
      path: '/admin/help-tickets',
      layout: 'layout'
    });
  } catch (error) {
    console.error('Admin help tickets page error:', error);
    res.status(500).send('Internal Server Error');
  }
});

app.get('/templates', auth, requireActiveAccount, requireNdaAcceptance, async (req, res) => {
  try {
    res.render('templates', {
      user: req.user,
      path: '/templates',
      layout: 'layout'
    });
  } catch (error) {
    return redirectToLogin(res, req, 'templates', 'CATCH');
  }
});

// Subscription Management Routes - billing off-platform
app.post('/api/subscription/setup-intent', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const error = billingService.createBillingDisabledError(
      'Subscription setup is handled off-platform. Please contact support.'
    );
    return res.status(error.statusCode).json({ error: error.message, code: error.code, billingMethod: 'off_platform' });
  } catch (error) {
    res.status(error.statusCode || 400).json({ error: error.message });
  }
});

// Subscription setup completion - billing off-platform
app.post('/api/subscription/complete-setup', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Phase 1: Billing handled off-platform
    const error = billingService.createBillingDisabledError(
      'Subscription setup is handled off-platform. Please contact support for invoice-based billing.'
    );
    
    return res.status(error.statusCode).json({ 
      error: error.message,
      code: error.code,
      billingMethod: 'off_platform'
    });
  } catch (error) {
    res.status(error.statusCode || 400).json({ error: error.message });
  }
});

// Invoices built outside application
app.post('/api/test/subscription-invoice', auth, async (req, res) => {
  return res.status(410).json({ error: 'Invoices are built outside the application.' });
});

// Subscription create - billing off-platform
app.post('/api/subscription/create', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    if (!user) return res.status(404).json({ error: 'User not found' });
    const error = billingService.createBillingDisabledError(
      'Subscription creation is handled off-platform. Please contact support for invoice-based billing.'
    );
    
    return res.status(error.statusCode).json({ 
      error: error.message,
      code: error.code,
      billingMethod: 'off_platform'
    });
  } catch (error) {
    res.status(error.statusCode || 400).json({ error: error.message });
  }
});

// Get account status (Phase 1: Replaces subscription status)
app.get('/api/subscription/status', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    // Get tokens from shared data
    const accountId = user.accountId || user.id;
    const tokens = await getAccountTokens(accountId);
    
    // Phase 1: Use account status instead of subscription status
    const { getAccountStatus, isAccountActive } = accountMiddleware;
    const accountStatus = await getAccountStatus(user);
    const isActive = await isAccountActive(user);
    
    const accountInfo = {
      accountType: user.accountType || ACCOUNT_TYPES.REG_CLIENT,
      accountStatus: accountStatus, // Phase 1: New field
      // Legacy fields for backward compatibility
      subscriptionStatus: user.subscriptionStatus || SUBSCRIPTION_STATUS.NONE,
      subscriptionId: user.subscriptionId || null,
      trialEndsAt: user.trialEndsAt || null,
      requiresSubscription: await requiresSubscription(user), // Legacy
      hasActiveSubscription: isActive, // Now based on account status
      isExpired: accountStatus === 'paused' || accountStatus === 'archived',
      smsTokens: tokens.smsTokens || 0,
      emailTokens: tokens.emailTokens || 0,
      aiTokens: tokens.aiTokens || 0
    };
    
    res.json(accountInfo);
    
  } catch (error) {
    console.error('Account status error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Subscription cancel - billing off-platform
app.post('/api/subscription/cancel', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const error = billingService.createBillingDisabledError(
      'Subscription cancellation is handled off-platform. Please contact support to cancel your subscription.'
    );
    
    return res.status(error.statusCode).json({ 
      error: error.message,
      code: error.code,
      billingMethod: 'off_platform'
    });
  } catch (error) {
    res.status(error.statusCode || 400).json({ error: error.message });
  }
});

// Subscription reactivate - billing off-platform
app.post('/api/subscription/reactivate', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const error = billingService.createBillingDisabledError(
      'Subscription reactivation is handled off-platform. Please contact support to reactivate your subscription.'
    );
    
    return res.status(error.statusCode).json({ 
      error: error.message,
      code: error.code,
      billingMethod: 'off_platform'
    });
  } catch (error) {
    res.status(error.statusCode || 400).json({ error: error.message });
  }
});

// Admin User Management Routes
// Update user account type (admin only)
app.post('/api/admin/users/:userId/account-type', adminAuth, async (req, res) => {
  try {
    const { userId } = req.params;
    const { accountType } = req.body;
    
    if (!Object.values(ACCOUNT_TYPES).includes(accountType)) {
      return res.status(400).json({ error: 'Invalid account type' });
    }
    
    const user = await findUserById(userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Update account type
    user.accountType = accountType;
    
    // Update subscription status based on account type
    if (accountType === ACCOUNT_TYPES.EDA || accountType === ACCOUNT_TYPES.APP_OWNER) {
      user.subscriptionStatus = SUBSCRIPTION_STATUS.NONE;
      user.subscriptionId = null;
      user.trialEndsAt = null;
    } else if (accountType === ACCOUNT_TYPES.REG_CLIENT) {
      // If changing to reg_client and no subscription, start trial
      if (!user.subscriptionId) {
        user.subscriptionStatus = SUBSCRIPTION_STATUS.TRIAL;
        user.trialEndsAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();
      }
    }
    
    await writeIndividualUserFile(userId, user);
    
    // Log the change
    await logAuditEvent(req.user.id, 'USER_ACCOUNT_TYPE_CHANGED', {
      targetUserId: userId,
      targetUserEmail: user.email,
      oldAccountType: user.accountType,
      newAccountType: accountType,
      changedBy: req.user.email
    }, req);
    
    res.json({
      message: 'Account type updated successfully',
      accountType: user.accountType,
      subscriptionStatus: user.subscriptionStatus
    });
    
  } catch (error) {
    console.error('Account type update error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Create new user (admin only)
app.post('/api/admin/users/create', adminAuth, async (req, res) => {
  try {
    const { 
      email, 
      password, 
      username, 
      firstName, 
      lastName, 
      company,
      userType = 'account_holder',
      accountType = 'reg_client',
      subscriptionStatus = 'none',
      isVerified = false,
      smsTokens = 0,
      emailTokens = 0,
      aiTokens = 0,
      accountId = null,
      trialEndsAt = null,
      subscriptionId = null
    } = req.body;
    
    // Validate required fields
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }
    
    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ error: 'Invalid email format' });
    }
    
    // Validate password strength
    const passwordValidation = validatePassword(password);
    if (!passwordValidation.isValid) {
      return res.status(400).json({ 
        error: 'Password does not meet security requirements',
        details: passwordValidation.errors
      });
    }
    
    // Check if user already exists
    if (await findUserByEmail(email)) {
      return res.status(400).json({ error: 'Email already exists' });
    }
    
    // Check username uniqueness if provided
    if (username) {
      const userIds = await getAllUserIds();
      for (const userId of userIds) {
        const user = await findUserById(userId);
        if (user && user.username === username) {
          return res.status(400).json({ error: 'Username already exists' });
        }
      }
    }
    
    // Validate account type
    if (!Object.values(ACCOUNT_TYPES).includes(accountType)) {
      return res.status(400).json({ error: 'Invalid account type' });
    }
    
    // Validate subscription status
    if (!Object.values(SUBSCRIPTION_STATUS).includes(subscriptionStatus)) {
      return res.status(400).json({ error: 'Invalid subscription status' });
    }
    
    // Validate user type
    const validUserTypes = ['account_holder', 'team_member', 'user'];
    if (!validUserTypes.includes(userType)) {
      return res.status(400).json({ error: 'Invalid user type' });
    }
    
    // If team_member, validate accountId
    if (userType === 'team_member') {
      if (!accountId) {
        return res.status(400).json({ error: 'Account ID is required for team members' });
      }
      const accountHolder = await findUserById(accountId);
      if (!accountHolder || accountHolder.userType !== 'account_holder') {
        return res.status(400).json({ error: 'Invalid account ID. Must be an account holder' });
      }
    }
    
    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // Generate verification token
    const verificationToken = generateVerificationToken();
    
    // Determine accountId for new user
    let finalAccountId = accountId || Date.now().toString();
    if (userType === 'account_holder') {
      finalAccountId = Date.now().toString();
    }
    
    // Set default subscription status based on account type if not provided
    let finalSubscriptionStatus = subscriptionStatus;
    if (accountType === ACCOUNT_TYPES.EDA || accountType === ACCOUNT_TYPES.APP_OWNER) {
      finalSubscriptionStatus = SUBSCRIPTION_STATUS.NONE;
    } else if (accountType === ACCOUNT_TYPES.REG_CLIENT && subscriptionStatus === SUBSCRIPTION_STATUS.NONE) {
      // Default to trial for new reg_client accounts
      finalSubscriptionStatus = SUBSCRIPTION_STATUS.TRIAL;
    }
    
    // Set trial end date if trial status
    let finalTrialEndsAt = trialEndsAt;
    if (finalSubscriptionStatus === SUBSCRIPTION_STATUS.TRIAL && !trialEndsAt) {
      finalTrialEndsAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();
    }
    
    // Create new user object
    const newUser = {
      id: Date.now().toString(),
      email,
      username: username || null,
      password: hashedPassword,
      verificationToken,
      isVerified: isVerified || false,
      is2FAEnabled: false,
      tokenBalance: 0,
      contacts: [],
      messageTemplates: [],
      autoReply: {
        isEnabled: false,
        message: ''
      },
      smsMessages: {
        sent: [],
        received: []
      },
      tokenTransactions: [],
      messages: [],
      invoices: [],
      smsTokens: smsTokens || 0,
      emailTokens: emailTokens || 0,
      aiTokens: aiTokens || 0,
      phoneNumbers: [],
      isAdmin: accountType === ACCOUNT_TYPES.APP_OWNER,
      createdAt: new Date().toISOString(),
      lastLoginAt: null,
      company: company || null,
      firstName: firstName || null,
      lastName: lastName || null,
      userType: userType,
      accountId: finalAccountId,
      invitedBy: null,
      permissions: userType === 'account_holder' ? [
        'manage_account', 'manage_contacts', 'manage_campaigns', 'manage_templates',
        'view_analytics', 'access_billing', 'manage_tokens', 'manage_settings',
        'send_campaigns', 'send_messages', 'manage_team'
      ] : userType === 'team_member' ? [
        'manage_contacts', 'manage_campaigns', 'manage_templates', 'view_analytics',
        'view_settings', 'send_campaigns', 'send_messages'
      ] : [
        'manage_contacts', 'manage_campaigns', 'manage_templates', 'view_analytics',
        'view_settings', 'send_campaigns', 'send_messages'
      ],
      accountType: accountType,
      subscriptionStatus: finalSubscriptionStatus,
      subscriptionId: subscriptionId || null,
      trialEndsAt: finalTrialEndsAt
    };
    
    // Create user file
    await writeIndividualUserFile(newUser.id, newUser);

    // Create account file if account_holder
    if (userType === 'account_holder') {
      const accountData = {
        id: finalAccountId,
        name: company?.name || email.split('@')[0],
        ownerId: newUser.id,
        createdAt: new Date().toISOString(),
        isActive: true,
        settings: {
          autoReply: {
            isEnabled: false,
            message: ""
          }
        }
      };
      
      await writeAccountFile(finalAccountId, accountData);
    }
    
    // Log audit event
    await logAuditEvent(req.user.id, 'USER_CREATED', {
      targetUserId: newUser.id,
      targetUserEmail: newUser.email,
      accountType: newUser.accountType,
      userType: newUser.userType,
      createdBy: req.user.email
    }, req);
    
    res.status(201).json({
      message: 'User created successfully',
      user: {
        id: newUser.id,
        email: newUser.email,
        userType: newUser.userType,
        accountType: newUser.accountType,
        subscriptionStatus: newUser.subscriptionStatus
      }
    });
    
  } catch (error) {
    console.error('Create user error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user subscription details (admin only)
app.get('/api/admin/users/:userId/subscription', adminAuth, async (req, res) => {
  try {
    const { userId } = req.params;
    const user = await findUserById(userId);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const subscriptionInfo = {
      userId: user.id,
      email: user.email,
      accountType: user.accountType || ACCOUNT_TYPES.REG_CLIENT,
      subscriptionStatus: user.subscriptionStatus || SUBSCRIPTION_STATUS.NONE,
      subscriptionId: user.subscriptionId || null,
      trialEndsAt: user.trialEndsAt || null,
      willCancelAt: user.willCancelAt || null,
      requiresSubscription: await requiresSubscription(user),
      hasActiveSubscription: await hasActiveSubscription(user),
      isExpired: await isSubscriptionExpired(user),
      createdAt: user.createdAt,
      lastLoginAt: user.lastLoginAt
    };
    
    res.json(subscriptionInfo);
    
  } catch (error) {
    console.error('Subscription details error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get all users with subscription info (admin only)
app.get('/api/admin/users/subscription-overview', adminAuth, async (req, res) => {
  try {
    const userIds = await getAllUserIds();
    const users = [];
    
    for (const userId of userIds) {
      try {
        const user = await findUserById(userId);
        if (user) {
          users.push({
            id: user.id,
            email: user.email,
            accountType: user.accountType || ACCOUNT_TYPES.REG_CLIENT,
            subscriptionStatus: user.subscriptionStatus || SUBSCRIPTION_STATUS.NONE,
            subscriptionId: user.subscriptionId || null,
            trialEndsAt: user.trialEndsAt || null,
            willCancelAt: user.willCancelAt || null,
            requiresSubscription: requiresSubscription(user),
            hasActiveSubscription: await hasActiveSubscription(user),
            isExpired: isSubscriptionExpired(user),
            createdAt: user.createdAt,
            lastLoginAt: user.lastLoginAt
          });
        }
      } catch (error) {
        console.error(`Error processing user ${userId}:`, error);
      }
    }
    
    // Sort by creation date (newest first)
    users.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    
    res.json(users);
    
  } catch (error) {
    console.error('Subscription overview error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Subscription page removed; redirect to dashboard so middleware redirects still work
app.get('/subscription', auth, (req, res) => {
  res.redirect(302, '/dashboard');
});

// NDA Agreement Page (auth only â€” no subscription/account check; if in DB they can log in)
app.get('/nda', auth, async (req, res) => {
  try {
    let user = await findUserById(req.user.id);
    if (!user && req.user) user = req.user;
    if (!user) {
      console.error('NDA page: user not found for id', req.user.id);
      return redirectToLogin(res, req, 'nda', 'USER_NOT_FOUND');
    }
    // App owner / EDA / account_holder go straight to dashboard (no NDA screen)
    const exemptFromNda = user.userType === 'app_owner' || user.accountType === 'app_owner' ||
      user.accountType === 'eda' || user.userType === 'account_holder';
    if (exemptFromNda) return res.redirect('/dashboard');

    const isElectionUser = user.electionMode || user.accountType === 'election' || user.userType === 'team_member';
    const hasNdaSession = req.cookies && req.cookies.election_nda_session;
    if (user.ndaAccepted && (!isElectionUser || hasNdaSession)) {
      return res.redirect('/dashboard');
    }
    res.render('nda-agreement', {
      user: req.user
    });
  } catch (error) {
    console.error('NDA page error:', error);
    return redirectToLogin(res, req, 'nda', 'CATCH');
  }
});

// Accept NDA endpoint
app.post('/api/accept-nda', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Record NDA acceptance
    user.ndaAccepted = true;
    user.ndaAcceptedAt = new Date().toISOString();
    user.ndaAcceptedIp = req.ip || req.headers['x-forwarded-for'] || 'unknown';
    user.ndaAcceptedUserAgent = req.headers['user-agent'] || 'unknown';
    
    // Save user data
    await writeIndividualUserFile(user.id, user);
    
    // Log the NDA acceptance event
    logSecurityEvent('NDA_ACCEPTED', {
      userId: user.id,
      email: user.email,
      acceptedAt: user.ndaAcceptedAt,
      ip: user.ndaAcceptedIp
    }, req);
    
    console.log(`[NDA] User ${user.email} (ID: ${user.id}) accepted NDA at ${user.ndaAcceptedAt}`);
    
    // Election users: set session cookie so they are not asked again until next login
    const isElectionUser = user.electionMode || user.accountType === 'election' || user.userType === 'team_member';
    if (isElectionUser) {
      res.cookie('election_nda_session', '1', {
        path: '/',
        httpOnly: true,
        sameSite: 'lax',
        maxAge: 7 * 24 * 60 * 60 * 1000
      });
    }
    
    res.json({ 
      success: true, 
      message: 'NDA accepted successfully',
      acceptedAt: user.ndaAcceptedAt
    });
  } catch (error) {
    console.error('Accept NDA error:', error);
    res.status(500).json({ error: 'Failed to record NDA acceptance' });
  }
});

// Invoice Management Routes
// Invoices page â€” account holder, app owner, or team member with view_invoices
// Invoices removed: billing is handled outside the application
app.get('/invoices', auth, (req, res) => {
  res.status(404).send('Billing and invoices are handled outside this application. Please contact your account administrator.');
});

app.get('/api/invoices', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    if (user.userType === 'team_member') {
      const hasViewInvoices = user.permissions && (user.permissions.includes('view_invoices') || user.permissions.includes('*'));
      if (!hasViewInvoices) {
        return res.status(403).json({ error: 'You do not have permission to view invoices.' });
      }
    }
    let invoices = [];
    // Read invoices from shared-data folder (account-scoped)
    const sharedDataPath = path.join(SHARED_DATA_DIR, (user.accountId || user.id).toString());
    const invoicesPath = path.join(sharedDataPath, 'invoices.json');

    if (fs.existsSync(invoicesPath)) {
      invoices = JSON.parse(fs.readFileSync(invoicesPath, 'utf8'));

    } else {
      // Fallback to old method if shared-data doesn't exist
      // Get invoices from shared-data structure
      const accountId = user.accountId || user.id;
      const invoicesPath = path.join(__dirname, 'data', 'shared-data', accountId, 'invoices.json');
      
      try {
        const invoicesData = await fsPromises.readFile(invoicesPath, 'utf8');
        invoices = JSON.parse(invoicesData);
      } catch (error) {
        // File doesn't exist, return empty array
        invoices = [];
      }
    }
    
    // Sort invoices by creation date (newest first)
    invoices.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    
    res.json(invoices);
  } catch (error) {
    console.error('Error loading invoices:', error);
    res.status(400).json({ error: error.message });
  }
});

// Pay receipt â€” disabled: billing is owner-managed, no in-app checkout
app.post('/api/invoices/pay', auth, async (req, res) => {
  try {
    return res.status(403).json({
      error: 'Payment is managed by Campaign Builder. Please pay by e-transfer, cheque, or as arranged with your account manager.'
    });
  } catch (error) {
    console.error('Invoices pay error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Requests page: admin/app owner sees inbox of requests from other accounts; other users submit and view their own
app.get('/requests', auth, async (req, res) => {
  try {
    const isAdminOrOwner = req.user && (req.user.userType === 'app_owner' || req.user.isAdmin === true);
    res.render('requests', {
      user: req.user,
      path: '/requests',
      layout: 'layout',
      isAppOwner: !!isAdminOrOwner
    });
  } catch (error) {
    return redirectToLogin(res, req, 'requests', 'CATCH');
  }
});

app.get('/api/requests', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const list = await requestsService.getRequests(accountId, SHARED_DATA_DIR);
    res.json(list);
  } catch (error) {
    console.error('Error loading requests:', error);
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/requests', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const body = req.body || {};
    const type = body.type || 'general';
    const payload = {
      type,
      submittedBy: user.email || user.id,
      submittedById: user.id
    };
    if (type === 'campaign_request') {
      payload.campaignType = body.campaignType;
      payload.objective = body.objective;
      payload.audience = body.audience;
      payload.messageCopy = body.messageCopy;
      payload.preferredSendDate = body.preferredSendDate;
      payload.attachments = body.attachments;
    } else if (type === 'token_request') {
      payload.tokenType = body.tokenType;
      payload.quantityRequested = body.quantityRequested;
      payload.reason = body.reason;
    } else if (type === 'billing_request') {
      payload.message = body.message;
    } else {
      payload.message = body.message;
    }
    const request = await requestsService.createRequest(accountId, SHARED_DATA_DIR, payload);
    res.status(201).json(request);
  } catch (error) {
    console.error('Error creating request:', error);
    res.status(500).json({ error: error.message });
  }
});

// User: delete one of their own requests
app.delete('/api/requests/:requestId', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const requestId = req.params.requestId;
    if (!requestId) return res.status(400).json({ error: 'requestId required' });
    const deleted = await requestsService.deleteRequest(accountId, SHARED_DATA_DIR, requestId);
    if (!deleted) return res.status(404).json({ error: 'Request not found' });
    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting request:', error);
    res.status(500).json({ error: error.message });
  }
});

// User: delete old completed requests (default 90 days)
app.delete('/api/requests/old', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const days = Number(req.query.days || 90);
    const result = await requestsService.deleteOldRequests(accountId, SHARED_DATA_DIR, days, true);
    res.json({ success: true, ...result });
  } catch (error) {
    console.error('Error deleting old requests:', error);
    res.status(500).json({ error: error.message });
  }
});

// Admin/app owner: list all requests from other accounts (shared-data per account)
app.get('/api/admin/requests', adminAuth, async (req, res) => {
  try {
    const isAdminOrOwner = req.user.userType === 'app_owner' || req.user.isAdmin === true;
    if (!isAdminOrOwner) {
      return res.status(403).json({ error: 'Only admin or app owner can view all requests.' });
    }
    const sharedDataDir = SHARED_DATA_DIR;
    let accountDirs = [];
    try {
      accountDirs = await fsPromises.readdir(sharedDataDir);
    } catch (e) {
      if (e.code !== 'ENOENT') throw e;
    }
    const all = [];
    const accountNames = {};
    for (const accountId of accountDirs) {
      try {
        const user = await readIndividualUserData(accountId);
        const nameRaw = user && (user.company || user.email);
        accountNames[accountId] = typeof nameRaw === 'object' && nameRaw && nameRaw.name ? nameRaw.name : (typeof nameRaw === 'string' ? nameRaw : user && user.email) || accountId;
      } catch (_) {
        accountNames[accountId] = accountId;
      }
      const list = await requestsService.getRequests(accountId, sharedDataDir);
      list.forEach(r => {
        all.push({ ...r, accountId, accountName: accountNames[accountId] });
      });
    }
    all.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    res.json(all);
  } catch (error) {
    console.error('Error loading admin requests:', error);
    res.status(500).json({ error: error.message });
  }
});

// Admin/app owner: update request (mark complete, add admin reply)
app.patch('/api/admin/requests', adminAuth, async (req, res) => {
  try {
    const isAdminOrOwner = req.user.userType === 'app_owner' || req.user.isAdmin === true;
    if (!isAdminOrOwner) {
      return res.status(403).json({ error: 'Only admin or app owner can update requests.' });
    }
    const { accountId, requestId, status, adminReply } = req.body || {};
    if (!accountId || !requestId) {
      return res.status(400).json({ error: 'accountId and requestId required' });
    }
    const updated = await requestsService.updateRequest(accountId, SHARED_DATA_DIR, requestId, { status, adminReply });
    if (!updated) return res.status(404).json({ error: 'Request not found' });
    res.json(updated);
  } catch (error) {
    console.error('Error updating request:', error);
    res.status(500).json({ error: error.message });
  }
});

// Admin/app owner: delete single request by account + request id
app.delete('/api/admin/requests', adminAuth, async (req, res) => {
  try {
    const isAdminOrOwner = req.user.userType === 'app_owner' || req.user.isAdmin === true;
    if (!isAdminOrOwner) {
      return res.status(403).json({ error: 'Only admin or app owner can delete requests.' });
    }
    const { accountId, requestId } = req.body || {};
    if (!accountId || !requestId) {
      return res.status(400).json({ error: 'accountId and requestId required' });
    }
    const deleted = await requestsService.deleteRequest(accountId, SHARED_DATA_DIR, requestId);
    if (!deleted) return res.status(404).json({ error: 'Request not found' });
    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting admin request:', error);
    res.status(500).json({ error: error.message });
  }
});

// Admin/app owner: bulk delete old completed requests across all accounts
app.delete('/api/admin/requests/old', adminAuth, async (req, res) => {
  try {
    const isAdminOrOwner = req.user.userType === 'app_owner' || req.user.isAdmin === true;
    if (!isAdminOrOwner) {
      return res.status(403).json({ error: 'Only admin or app owner.' });
    }
    const days = Number(req.query.days || 90);
    let accountDirs = [];
    try {
      accountDirs = await fsPromises.readdir(SHARED_DATA_DIR);
    } catch (e) {
      if (e.code !== 'ENOENT') throw e;
    }
    let deleted = 0;
    for (const accountId of accountDirs) {
      try {
        const result = await requestsService.deleteOldRequests(accountId, SHARED_DATA_DIR, days, true);
        deleted += result.deleted || 0;
      } catch (_) {
        // skip unreadable accounts
      }
    }
    res.json({ success: true, deleted });
  } catch (error) {
    console.error('Error deleting old admin requests:', error);
    res.status(500).json({ error: error.message });
  }
});

// Admin/app owner: count of requests not yet complete (red badge until marked Completed)
app.get('/api/admin/requests/count', adminAuth, async (req, res) => {
  try {
    const isAdminOrOwner = req.user.userType === 'app_owner' || req.user.isAdmin === true;
    if (!isAdminOrOwner) {
      return res.status(403).json({ error: 'Only admin or app owner.' });
    }
    let accountDirs = [];
    try {
      accountDirs = await fsPromises.readdir(SHARED_DATA_DIR);
    } catch (e) {
      if (e.code !== 'ENOENT') return res.json({ count: 0 });
    }
    let count = 0;
    for (const accountId of accountDirs) {
      try {
        const list = await requestsService.getRequests(accountId, SHARED_DATA_DIR);
        count += list.filter(r => r.status !== 'Completed').length;
      } catch (_) {
        // skip
      }
    }
    res.json({ count });
  } catch (error) {
    console.error('Error loading admin requests count:', error);
    res.status(500).json({ error: error.message });
  }
});

// Help Ticket System API Routes

// Submit a new help ticket
app.post('/api/help', auth, async (req, res) => {
  try {
    const { fullName, email, page, message } = req.body;
    
    if (!fullName || !email || !page || !message) {
      return res.status(400).json({ error: 'All fields are required' });
    }
    
    const user = await findUserById(req.user.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Generate unique ticket number
    const currentYear = new Date().getFullYear();
    const ticketNumber = `HELP-${currentYear}-${String(Date.now()).slice(-6)}`;
    
    // Create ticket object
    const ticket = {
      ticketNumber,
      fullName,
      email,
      page,
      message,
      status: 'Open',
      createdAt: new Date().toISOString(),
      adminReply: null,
      repliedAt: null
    };
    
    // Load user's data using readIndividualUserData
    let userData;
    
    try {
      userData = await readIndividualUserData(req.user.id);
      if (!userData) {
        return res.status(404).json({ error: 'User not found' });
      }
    } catch (error) {
      console.error('Error reading user data for help ticket:', error);
      return res.status(500).json({ error: 'Failed to read user data' });
    }
    
    // Initialize helpTickets array if it doesn't exist
    if (!userData.helpTickets) {
      userData.helpTickets = [];
    }
    
    // Add the new ticket
    userData.helpTickets.push(ticket);
    
    // Save updated user data
    await writeIndividualUserFile(req.user.id, userData);
    
    res.json({ 
      success: true, 
      ticketNumber: ticket.ticketNumber,
      message: 'Help ticket submitted successfully' 
    });
    
  } catch (error) {
    console.error('Help ticket submission error:', error);
    res.status(500).json({ error: 'Failed to submit help ticket' });
  }
});

// Get all help tickets for admin dashboard
app.get('/api/admin/help-tickets', auth, requirePermission('manage_users'), async (req, res) => {
  try {
    const allTickets = [];
    
    // Read all user directories
    const userDirs = await fsPromises.readdir(INDIVIDUAL_DATA_DIR);
    
    for (const userId of userDirs) {
      const userDir = path.join(INDIVIDUAL_DATA_DIR, userId);
      const stat = await fsPromises.stat(userDir);
      
      if (stat.isDirectory()) {
        const userDataPath = path.join(userDir, 'user.json');
        
        try {
          const userDataContent = await fsPromises.readFile(userDataPath, 'utf8');
          const userData = JSON.parse(userDataContent);
          
          if (userData.helpTickets && Array.isArray(userData.helpTickets)) {
            // Add user info to each ticket
            const ticketsWithUserInfo = userData.helpTickets.map(ticket => ({
              ...ticket,
              userId: userId,
              userFullName: userData.fullName || userData.username || 'Unknown',
              userEmail: userData.email || 'Unknown'
            }));
            
            allTickets.push(...ticketsWithUserInfo);
          }
        } catch (error) {
          console.error(`Error reading user data for ${userId}:`, error);
          // Continue with other users
        }
      }
    }
    
    // Sort tickets by creation date (newest first)
    allTickets.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    
    res.json({ tickets: allTickets });
    
  } catch (error) {
    console.error('Get help tickets error:', error);
    res.status(500).json({ error: 'Failed to retrieve help tickets' });
  }
});

// Update ticket status
app.post('/api/admin/help-tickets/:ticketNumber/status', auth, requirePermission('manage_users'), async (req, res) => {
  try {
    const { ticketNumber } = req.params;
    const { status } = req.body;
    
    if (!status || !['Open', 'In Progress', 'Closed'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status. Must be Open, In Progress, or Closed' });
    }
    
    // Find the ticket across all users
    const userDirs = await fsPromises.readdir(INDIVIDUAL_DATA_DIR);
    let ticketFound = false;
    
    for (const userId of userDirs) {
      const userDir = path.join(INDIVIDUAL_DATA_DIR, userId);
      const stat = await fsPromises.stat(userDir);
      
      if (stat.isDirectory()) {
        const userDataPath = path.join(userDir, 'user.json');
        
        try {
          const userDataContent = await fsPromises.readFile(userDataPath, 'utf8');
          const userData = JSON.parse(userDataContent);
          
          if (userData.helpTickets && Array.isArray(userData.helpTickets)) {
            const ticketIndex = userData.helpTickets.findIndex(ticket => ticket.ticketNumber === ticketNumber);
            
            if (ticketIndex !== -1) {
              userData.helpTickets[ticketIndex].status = status;
              
              // Save updated user data
              await fsPromises.writeFile(userDataPath, JSON.stringify(userData, null, 2), 'utf8');
              ticketFound = true;
              break;
            }
          }
        } catch (error) {
          console.error(`Error updating ticket for user ${userId}:`, error);
        }
      }
    }
    
    if (!ticketFound) {
      return res.status(404).json({ error: 'Ticket not found' });
    }
    
    res.json({ success: true, message: 'Ticket status updated successfully' });
    
  } catch (error) {
    console.error('Update ticket status error:', error);
    res.status(500).json({ error: 'Failed to update ticket status' });
  }
});

// Delete a help ticket
app.delete('/api/help-tickets/:ticketNumber', auth, async (req, res) => {
  try {
    const { ticketNumber } = req.params;
    const userId = req.user.id;
    
    try {
      const userData = await readIndividualUserData(userId);
      if (!userData) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      if (!userData.helpTickets || !Array.isArray(userData.helpTickets)) {
        return res.status(404).json({ error: 'No help tickets found' });
      }
      
      // Find and remove the ticket
      const ticketIndex = userData.helpTickets.findIndex(ticket => ticket.ticketNumber === ticketNumber);
      
      if (ticketIndex === -1) {
        return res.status(404).json({ error: 'Ticket not found' });
      }
      
      // Remove the ticket
      userData.helpTickets.splice(ticketIndex, 1);
      
      // Save updated user data
      await writeIndividualUserFile(userId, userData);
      
      res.json({ message: 'Ticket deleted successfully' });
    } catch (error) {
      console.error('Error reading user data for ticket deletion:', error);
      res.status(500).json({ error: 'Failed to read user data' });
    }
  } catch (error) {
    console.error('Delete help ticket error:', error);
    res.status(500).json({ error: 'Failed to delete help ticket' });
  }
});

// Get user's help tickets for dashboard
app.get('/api/help-tickets', auth, async (req, res) => {
  try {
    const userId = req.user.id;
    
    try {
      const userData = await readIndividualUserData(userId);
      if (!userData) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      const helpTickets = userData.helpTickets || [];
      
      // Sort tickets by creation date (newest first)
      helpTickets.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
      
      res.json(helpTickets);
    } catch (error) {
      console.error('Error reading user data for help tickets:', error);
      res.status(500).json({ error: 'Failed to read user data' });
    }
  } catch (error) {
    console.error('Get user help tickets error:', error);
    res.status(500).json({ error: 'Failed to retrieve help tickets' });
  }
});

// Get help ticket counts for notifications
app.get('/api/admin/help-tickets/count', auth, requirePermission('manage_users'), async (req, res) => {
  try {
    const allTickets = [];
    
    // Read all user entries (both files and directories)
    const entries = await fsPromises.readdir(INDIVIDUAL_DATA_DIR);
    
    for (const entry of entries) {
      try {
        // Check if it's a directory or file
        const entryPath = path.join(INDIVIDUAL_DATA_DIR, entry);
        const stats = await fsPromises.stat(entryPath);
        
        let userId;
        if (stats.isDirectory()) {
          // New structure: directory name is userId
          userId = entry;
        } else if (stats.isFile() && entry.endsWith('.json')) {
          // Old structure: filename is userId.json
          userId = entry.replace(/\.json$/, '');
        } else {
          // Skip non-user entries
          continue;
        }
        
        // Use readIndividualUserData to handle both structures
        const userData = await readIndividualUserData(userId);
        
        if (userData && userData.helpTickets && Array.isArray(userData.helpTickets)) {
          userData.helpTickets.forEach(ticket => {
            allTickets.push({
              ...ticket,
              userId: userId,
              userEmail: userData.email,
              userName: userData.firstName && userData.lastName ? 
                `${userData.firstName} ${userData.lastName}` : 
                userData.email
            });
          });
        }
      } catch (error) {
        // Silently skip entries that can't be processed
        continue;
      }
    }
    
    // Count tickets by status
    const counts = {
      total: allTickets.length,
      open: allTickets.filter(ticket => ticket.status === 'Open').length,
      inProgress: allTickets.filter(ticket => ticket.status === 'In Progress').length,
      closed: allTickets.filter(ticket => ticket.status === 'Closed').length,
      new: allTickets.filter(ticket => {
        // Consider tickets as "new" if created within last 24 hours
        const createdAt = new Date(ticket.createdAt);
        const now = new Date();
        const hoursDiff = (now - createdAt) / (1000 * 60 * 60);
        return hoursDiff <= 24;
      }).length
    };
    
    res.json(counts);
  } catch (error) {
    console.error('Get help ticket counts error:', error);
    res.status(500).json({ error: 'Failed to retrieve help ticket counts' });
  }
});

// Reply to ticket (one time only)
app.post('/api/admin/help-tickets/:ticketNumber/reply', auth, requirePermission('manage_users'), async (req, res) => {
  try {
    const { ticketNumber } = req.params;
    const { adminReply } = req.body;
    
    if (!adminReply || adminReply.trim().length === 0) {
      return res.status(400).json({ error: 'Admin reply is required' });
    }
    
    // Find the ticket across all users
    const userDirs = await fsPromises.readdir(INDIVIDUAL_DATA_DIR);
    let ticketFound = false;
    
    for (const entry of userDirs) {
      const entryPath = path.join(INDIVIDUAL_DATA_DIR, entry);
      const stat = await fsPromises.stat(entryPath);
      
      let userId;
      if (stat.isDirectory()) {
        userId = entry;
      } else if (stat.isFile() && entry.endsWith('.json')) {
        userId = entry.replace(/\.json$/, '');
      } else {
        continue;
      }
      
      try {
        const userData = await readIndividualUserData(userId);
        
        if (userData && userData.helpTickets && Array.isArray(userData.helpTickets)) {
          const ticketIndex = userData.helpTickets.findIndex(ticket => ticket.ticketNumber === ticketNumber);
          
          if (ticketIndex !== -1) {
            const ticket = userData.helpTickets[ticketIndex];
            
            // Check if ticket already has a reply
            if (ticket.adminReply) {
              return res.status(400).json({ error: 'This ticket already has a reply and cannot be modified' });
            }
            
            // Add admin reply
            ticket.adminReply = adminReply.trim();
            ticket.repliedAt = new Date().toISOString();
            
            // Save updated user data
            await writeIndividualUserFile(userId, userData);
            ticketFound = true;
            break;
          }
        }
      } catch (error) {
        console.error(`Error replying to ticket for user ${userId}:`, error);
        continue;
      }
    }
    
    if (!ticketFound) {
      return res.status(404).json({ error: 'Ticket not found' });
    }
    
    res.json({ success: true, message: 'Reply added successfully' });
    
  } catch (error) {
    console.error('Reply to ticket error:', error);
    res.status(500).json({ error: 'Failed to add reply to ticket' });
  }
});

// GET / and /login are handled by canonical routes above.

app.get('/terms-and-conditions', (req, res) => {
  try {
    res.render('terms-and-conditions', {
      layout: false
    });
  } catch (error) {
    console.error('Error rendering terms and conditions page:', error);
    res.status(500).send('Internal Server Error');
  }
});

app.get('/accept-invitation', (req, res) => {
  try {
    res.render('accept-invitation', {
      layout: false // Don't use layout for invitation page
    });
  } catch (error) {
    console.error('Error rendering invitation page:', error);
    res.status(500).send('Internal Server Error');
  }
});

app.get('/teams', auth, requireActiveAccount, requireNdaAcceptance, requireElectionMode, async (req, res) => {
  try {
    res.render('teams', {
      user: req.user,
      path: '/teams',
      layout: 'layout',
      pageTitle: 'Teams'
    });
  } catch (error) {
    console.error('Teams page error:', error);
    res.redirect('/dashboard');
  }
});

// Election Teams API (manager-only; require Election Mode)
app.get('/election/teams/data', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const getLists = (acctId) => electionListsService.getLists(acctId, user.id).then(l => (Array.isArray(l) ? l : (l && l.lists) || []));
    const data = await electionTeams.getTeamsData(accountId, SHARED_DATA_DIR, getLists);
    res.json(data);
  } catch (error) {
    logger.error('Election teams data error', error);
    res.status(500).json({ error: error.message || 'Failed to load teams data' });
  }
});

app.post('/election/teams/invite', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const { email, name, roleId } = req.body || {};
    const normalizedEmail = (email && String(email).trim()) ? String(email).trim().toLowerCase() : '';
    if (!normalizedEmail) {
      return res.status(400).json({ error: 'Email is required' });
    }

    // Create election-teams member + invitation record
    await electionTeams.inviteMember(accountId, SHARED_DATA_DIR, { email: normalizedEmail, name, roleId });

    // Create main invitation (token for accept link) and send email using system SMTP.
    // Use SMTP_USER as From so envelope matches SMTP auth (many servers reject SYSTEM_EMAIL if it differs).
    let emailSent = false;
    const smtpUser = process.env.SMTP_USER || process.env.EMAIL_USER;
    const fromEmail = smtpUser || process.env.SYSTEM_EMAIL || 'smtp@sw7ft.com';
    const senderName = user.company && typeof user.company === 'object' ? user.company.name : (user.company || 'Campaign Builder');

    try {
      const invitation = await createInvitation({
        accountId,
        invitedBy: user.id,
        email: normalizedEmail
      });
      const inviteLink = `${req.protocol}://${req.get('host')}/accept-invitation?token=${invitation.token}`;

      await sendTransactionalEmail({
        from: fromEmail,
        fromName: senderName,
        to: normalizedEmail,
        subject: `You're invited to join ${senderName} on Campaign Builder`,
        html: `
          <h2>You've been invited to join the team!</h2>
          <p>${user.email} has invited you to join their team on Campaign Builder (Election Mode).</p>
          <p>Click the link below to accept the invitation and create your account:</p>
          <p><a href="${inviteLink}" style="background: #4F46E5; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px;">Accept Invitation</a></p>
          <p>This invitation will expire in 7 days.</p>
          <p>If you have any questions, please contact ${user.email}</p>
        `,
        text: `${user.email} has invited you to join their team on Campaign Builder. Click this link to accept: ${inviteLink}. This invitation will expire in 7 days.`
      }, user);

      emailSent = true;
      logger.info('Election teams invitation email sent', { to: normalizedEmail, accountId });
    } catch (emailErr) {
      const errMsg = emailErr && (emailErr.message || String(emailErr));
      const errCode = emailErr && emailErr.code;
      logger.error('Election teams invite: invitation created but email failed', { error: emailErr, to: normalizedEmail });
      console.error('[INVITE] Email send failed:', errMsg, errCode ? `(code: ${errCode})` : '', '| To see this log use: pm2 logs server-election');
      return res.json({
        success: true,
        message: 'Team member invited. Email could not be sent; check SMTP settings.',
        emailSent: false
      });
    }

    res.json({ success: true, message: 'Invite sent.', emailSent: true });
  } catch (error) {
    logger.error('Election teams invite error', error);
    res.status(400).json({ error: error.message || 'Invite failed' });
  }
});

app.post('/election/teams/member/update-role', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const { memberId, roleId } = req.body || {};
    if (!memberId) return res.status(400).json({ error: 'memberId required' });
    await electionTeams.updateMemberRole(accountId, SHARED_DATA_DIR, { memberId, roleId });
    res.json({ success: true });
  } catch (error) {
    logger.error('Election teams update-role error', error);
    res.status(400).json({ error: error.message || 'Update failed' });
  }
});

app.post('/election/teams/member/update-permissions', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const { memberId, permissionsPatch } = req.body || {};
    if (!memberId) return res.status(400).json({ error: 'memberId required' });
    await electionTeams.updateMemberPermissions(accountId, SHARED_DATA_DIR, { memberId, permissionsPatch });
    res.json({ success: true });
  } catch (error) {
    logger.error('Election teams update-permissions error', error);
    res.status(400).json({ error: error.message || 'Update failed' });
  }
});

app.post('/election/teams/member/suspend', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const { memberId, suspended } = req.body || {};
    if (!memberId) return res.status(400).json({ error: 'memberId required' });
    await electionTeams.setMemberSuspended(accountId, SHARED_DATA_DIR, { memberId, suspended: !!suspended });
    res.json({ success: true });
  } catch (error) {
    logger.error('Election teams suspend error', error);
    res.status(400).json({ error: error.message || 'Update failed' });
  }
});

app.delete('/election/teams/member/remove', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const body = req.body && typeof req.body === 'object' ? req.body : {};
    const memberId = body.memberId || (req.query && req.query.memberId);
    if (!memberId) return res.status(400).json({ error: 'memberId required' });
    await electionTeams.removeMember(accountId, SHARED_DATA_DIR, { memberId });
    res.json({ success: true });
  } catch (error) {
    logger.error('Election teams remove member error', error);
    res.status(400).json({ error: error.message || 'Remove failed' });
  }
});

app.post('/election/roles/create', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const { roleName, defaultPermissions } = req.body || {};
    const role = await electionTeams.createRole(accountId, SHARED_DATA_DIR, { roleName, defaultPermissions });
    res.json(role);
  } catch (error) {
    logger.error('Election roles create error', error);
    res.status(400).json({ error: error.message || 'Create failed' });
  }
});

app.post('/election/roles/update', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const { roleId, roleName, defaultPermissions } = req.body || {};
    if (!roleId) return res.status(400).json({ error: 'roleId required' });
    const role = await electionTeams.updateRole(accountId, SHARED_DATA_DIR, { roleId, roleName, defaultPermissions });
    res.json(role);
  } catch (error) {
    logger.error('Election roles update error', error);
    res.status(400).json({ error: error.message || 'Update failed' });
  }
});

app.delete('/election/roles/delete', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const body = req.body && typeof req.body === 'object' ? req.body : {};
    const roleId = body.roleId || (req.query && req.query.roleId);
    if (!roleId) return res.status(400).json({ error: 'roleId required' });
    await electionTeams.deleteRole(accountId, SHARED_DATA_DIR, { roleId });
    res.json({ success: true });
  } catch (error) {
    logger.error('Election roles delete error', error);
    res.status(400).json({ error: error.message || 'Delete failed' });
  }
});

app.post('/election/assignments/create', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const { memberId, listId } = req.body || {};
    if (!memberId || !listId) return res.status(400).json({ error: 'memberId and listId required' });
    const assignment = await electionTeams.createAssignment(accountId, SHARED_DATA_DIR, { memberId, listId }, user.id);
    res.json(assignment);
  } catch (error) {
    logger.error('Election assignments create error', error);
    res.status(400).json({ error: error.message || 'Create failed' });
  }
});

app.get('/election/assignments', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const memberId = req.query && req.query.memberId;
    const list = await electionTeams.getAssignments(accountId, SHARED_DATA_DIR, { memberId });
    res.json(list);
  } catch (error) {
    logger.error('Election assignments get error', error);
    res.status(500).json({ error: error.message || 'Failed to load assignments' });
  }
});

app.post('/election/assignments/update-status', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const { assignmentId, status } = req.body || {};
    if (!assignmentId) return res.status(400).json({ error: 'assignmentId required' });
    const assignment = await electionTeams.updateAssignmentStatus(accountId, SHARED_DATA_DIR, { assignmentId, status });
    res.json(assignment);
  } catch (error) {
    logger.error('Election assignments update-status error', error);
    res.status(400).json({ error: error.message || 'Update failed' });
  }
});

app.delete('/election/assignments/remove', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const body = req.body && typeof req.body === 'object' ? req.body : {};
    const assignmentId = body.assignmentId || (req.query && req.query.assignmentId);
    if (!assignmentId) return res.status(400).json({ error: 'assignmentId required' });
    await electionTeams.removeAssignment(accountId, SHARED_DATA_DIR, { assignmentId });
    res.json({ success: true });
  } catch (error) {
    logger.error('Election assignments remove error', error);
    res.status(400).json({ error: error.message || 'Remove failed' });
  }
});

app.get('/dashboard', auth, requireNdaAcceptance, async (req, res) => {
  try {
    let user = await findUserById(req.user.id);
    if (!user && req.user) user = req.user;
    if (!user) return redirectToLogin(res, req, 'dashboard', 'NO_USER');
    const isElectionAccount = user.electionMode || user.accountType === 'election';
    const pageTitle = isElectionAccount ? 'Election Dashboard' : 'Dashboard';

    const subscriptionInfo = {
      accountType: user.accountType || ACCOUNT_TYPES.REG_CLIENT,
      subscriptionStatus: user.subscriptionStatus || SUBSCRIPTION_STATUS.NONE,
      subscriptionId: user.subscriptionId || null,
      trialEndsAt: user.trialEndsAt || null,
      requiresSubscription: false,
      hasActiveSubscription: true,
      isExpired: false
    };

    const smsVal = user.smsTokens;
    const emailVal = user.emailTokens;
    const aiVal = user.aiTokens;
    const smsTokens = typeof smsVal === 'number' ? smsVal : (smsVal && typeof smsVal === 'object' && typeof smsVal.balance === 'number' ? smsVal.balance : 0);
    const emailTokens = typeof emailVal === 'number' ? emailVal : (emailVal && typeof emailVal === 'object' && typeof emailVal.balance === 'number' ? emailVal.balance : 0);
    const aiTokens = typeof aiVal === 'number' ? aiVal : (aiVal && typeof aiVal === 'object' && typeof aiVal.balance === 'number' ? aiVal.balance : 0);
    const totalContacts = user.contacts && Array.isArray(user.contacts) ? user.contacts.length : 0;
    const templates = Array.isArray(user.messageTemplates) ? user.messageTemplates : [];

    res.render('dashboard', {
      user: req.user || user,
      subscriptionInfo: subscriptionInfo,
      path: '/dashboard',
      layout: 'layout',
      isElectionAccount: !!isElectionAccount,
      pageTitle: pageTitle || 'Dashboard',
      smsTokens: typeof smsTokens === 'number' ? smsTokens : 0,
      emailTokens: typeof emailTokens === 'number' ? emailTokens : 0,
      aiTokens: typeof aiTokens === 'number' ? aiTokens : 0,
      totalContacts: typeof totalContacts === 'number' ? totalContacts : 0,
      templates: Array.isArray(templates) ? templates : []
    }, (err, html) => {
      if (err) {
        console.error('Dashboard render error:', err.message, err.stack);
        if (res.headersSent) return;
        const showStack = process.env.NODE_ENV === 'development' || process.env.IS_STAGING === 'true';
        const body = '<!DOCTYPE html><html><head><title>Dashboard Error</title></head><body><h1>Dashboard Error</h1><p><strong>' +
          (err.message || 'Something went wrong') + '</strong></p>' +
          (showStack && err.stack ? '<pre>' + String(err.stack) + '</pre>' : '') +
          '<p><a href="/dashboard">Try again</a> | <a href="/login">Login</a></p></body></html>';
        res.status(500).send(body);
        return;
      }
      res.send(html);
    });
  } catch (error) {
    console.error('Dashboard error:', error);
    if (res.headersSent) return;
    res.status(500).send(
      '<!DOCTYPE html><html><head><title>Dashboard Error</title></head><body><h1>Something went wrong</h1><p>Please try again or <a href="/login">log in again</a>.</p></body></html>'
    );
  }
});

// Election Mode HTML Routes
app.get('/election/scrutineering', auth, requireActiveAccount, requireNdaAcceptance, requireElectionMode, async (req, res) => {
  try {
    res.render('election-scrutineering', {
      user: req.user,
      path: '/election/scrutineering',
      layout: 'layout',
      pageTitle: 'Vote Tracking'
    });
  } catch (error) {
    console.error('Scrutineering page error:', error);
    res.redirect('/dashboard');
  }
});

app.get('/election/interactions', auth, requireActiveAccount, requireNdaAcceptance, requireElectionMode, async (req, res) => {
  try {
    res.render('election-interactions', {
      user: req.user,
      path: '/election/interactions',
      layout: 'layout',
      pageTitle: 'Voter Interactions',
      stats: { strong: 0, leaning: 0, opposed: 0, undecided: 0 }
    });
  } catch (error) {
    console.error('Interactions page error:', error);
    res.redirect('/dashboard');
  }
});

app.get('/election/lists', auth, requireActiveAccount, requireNdaAcceptance, requireElectionMode, async (req, res) => {
  try {
    res.render('election-lists', {
      user: req.user,
      path: '/election/lists',
      layout: 'layout',
      pageTitle: 'Election Lists'
    });
  } catch (error) {
    console.error('Lists page error:', error);
    res.redirect('/dashboard');
  }
});

app.get('/election/navigation', auth, requireActiveAccount, requireNdaAcceptance, requireElectionMode, async (req, res) => {
  try {
    const mapboxToken = (mapboxConfig && mapboxConfig.token) ? String(mapboxConfig.token) : '';
    res.render('election-navigation', {
      user: req.user,
      path: '/election/navigation',
      layout: 'layout',
      pageTitle: 'Navigation',
      mapboxToken
    });
  } catch (error) {
    console.error('Navigation page error:', error);
    if (!res.headersSent) res.redirect('/dashboard');
  }
});

// POST /api/election/navigation/optimize - Mapbox route optimization (driving or walking)
// Body: { stops: [{ contactId, fullAddress, contact: {...} }, ...], profile: 'driving'|'walking' }
// Returns: { stops: ordered stops with coordinates, routeGeometry: GeoJSON for map }
const MAPBOX_MAX_WAYPOINTS = Math.min(12, mapboxConfig.maxWaypoints || 12);
app.post('/api/election/navigation/optimize', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    if (!mapboxConfig.token || !mapboxConfig.token.trim()) {
      return res.status(503).json({ error: 'Mapbox is not configured. Add MAPBOX_ACCESS_TOKEN to .env to use route optimization.' });
    }
    const { stops: rawStops, profile, origin } = req.body || {};
    const requestedProfile = (profile === 'walking') ? 'mapbox/walking' : 'mapbox/driving';
    const limit = Math.min(MAPBOX_MAX_WAYPOINTS, rawStops && rawStops.length ? rawStops.length : 0);
    if (!Array.isArray(rawStops) || limit < 2) {
      return res.status(400).json({ error: 'Send at least 2 stops with fullAddress. Max ' + MAPBOX_MAX_WAYPOINTS + ' for optimization.' });
    }
    const toGeocode = rawStops.slice(0, limit).filter(s => s.fullAddress && String(s.fullAddress).trim());
    if (toGeocode.length < 2) {
      return res.status(400).json({ error: 'At least 2 stops must have a valid fullAddress.' });
    }
    const token = mapboxConfig.token;
    const geocodeOne = async (address) => {
      const url = 'https://api.mapbox.com/geocoding/v5/mapbox.places/' + encodeURIComponent(address) + '.json?access_token=' + token + '&country=CA&limit=1';
      const r = await fetch(url);
      if (!r.ok) return null;
      const data = await r.json();
      const feat = data.features && data.features[0];
      return feat && feat.center ? feat.center : null;
    };
    const coordinates = [];
    const stopsWithCoords = [];
    let originCoords = null;
    if (origin && Array.isArray(origin) && origin.length >= 2 && typeof origin[0] === 'number' && typeof origin[1] === 'number') {
      originCoords = [Number(origin[0]), Number(origin[1])];
      coordinates.push(originCoords);
    }
    for (let i = 0; i < toGeocode.length; i++) {
      const coords = await geocodeOne(toGeocode[i].fullAddress);
      if (coords) {
        coordinates.push(coords);
        stopsWithCoords.push({ ...toGeocode[i], coordinates: coords });
      }
    }
    if (coordinates.length < 2) {
      return res.status(400).json({ error: 'Could not geocode enough addresses. Check addresses and try again.' });
    }
    const coordStr = coordinates.map(c => c[0] + ',' + c[1]).join(';');
    const optimizeUrl = 'https://api.mapbox.com/optimized-trips/v1/' + requestedProfile + '/' + coordStr + '?access_token=' + token + '&source=first&destination=last';
    const optRes = await fetch(optimizeUrl);
    if (!optRes.ok) {
      const errText = await optRes.text();
      logger.warn('[navigation/optimize] Mapbox API error', { status: optRes.status, body: errText });
      return res.status(502).json({ error: 'Route optimization failed. Try again or use fewer stops.' });
    }
    const optData = await optRes.json();
    const waypoints = (optData.waypoints || []).sort((a, b) => (a.waypoint_index || 0) - (b.waypoint_index || 0));
    const locKey = (c) => (c && c[0] != null && c[1] != null) ? c[0].toFixed(5) + ',' + c[1].toFixed(5) : '';
    const originKey = originCoords ? locKey(originCoords) : null;
    let orderedStops = waypoints.map(w => {
      const loc = w.location || w.rawLocation;
      if (!loc || loc.length < 2) return null;
      if (originKey && locKey(loc) === originKey) return null;
      const stop = stopsWithCoords.find(s => locKey(s.coordinates) === locKey(loc)) || stopsWithCoords.find(s => Math.abs((s.coordinates[0] - loc[0])) < 1e-4 && Math.abs((s.coordinates[1] - loc[1])) < 1e-4);
      return stop ? { ...stop, waypointIndex: w.waypoint_index } : null;
    }).filter(Boolean);
    const trip = optData.trips && optData.trips[0];
    const routeGeometry = trip && trip.geometry ? trip.geometry : null;
    res.json({ stops: orderedStops, routeGeometry });
  } catch (error) {
    logger.error('Navigation optimize error', error);
    res.status(500).json({ error: error.message || 'Optimization failed.' });
  }
});

app.get('/election/canvassing', auth, requireActiveAccount, requireNdaAcceptance, requireElectionMode, (req, res) => {
  res.redirect(302, '/election/navigation');
});

app.get('/messages', auth, requireActiveAccount, requireNdaAcceptance, async (req, res) => {
  try {
    res.render('messages', {
      user: req.user,
      path: '/messages',
      layout: 'layout'
    });
  } catch (error) {
    return redirectToLogin(res, req, 'messages', 'CATCH');
  }
});

app.get('/management', adminAuth, requireActiveAccount, requireNdaAcceptance, async (req, res) => {
  try {
    res.render('management', {
      user: req.user,
      path: '/management',
      layout: 'layout'
    });
  } catch (error) {
    return redirectToLogin(res, req, 'management', 'CATCH');
  }
});

app.get('/my-numbers', auth, requireActiveAccount, requireNdaAcceptance, async (req, res) => {
  try {
    // Only app owner can access: purchase numbers and manage sender settings. Account holders get numbers assigned from Management.
    if (req.user.userType !== 'app_owner') {
      return res.status(403).send('Access denied. Phone numbers are assigned by the app owner from Admin > User Management.');
    }
    
    res.render('my-numbers', {
      user: req.user,
      path: '/my-numbers',
      layout: 'layout'
    });
  } catch (error) {
    return redirectToLogin(res, req, 'my-numbers', 'CATCH');
  }
});

// AI Calling - View Route
app.get('/ai-calling', auth, requireActiveAccount, requireNdaAcceptance, async (req, res) => {
  try {
    res.render('ai-calling', {
      user: req.user,
      path: '/ai-calling',
      layout: 'layout'
    });
  } catch (error) {
    return redirectToLogin(res, req, 'ai-calling', 'CATCH');
  }
});

// Google Places API endpoints
app.get('/api/places/autocomplete', auth, async (req, res) => {
  try {
    const { input } = req.query;
    
    if (!input || input.length < 2) {
      return res.json({ predictions: [] });
    }

    // Try LocationIQ first
    const locationiqToken = process.env.LOCATIONIQ_AUTOCOMPLETE_TOKEN || process.env.locationIqToken;
    
    // Build a more specific search for Canadian addresses
    let searchQuery = input;
    if (!input.includes('Canada') && !input.includes('CA') && !input.includes(',') && !input.includes(' ')) {
      // Only append Canada for very short, single-word searches
      searchQuery = `${input}, Canada`;
    }
    
    const url = `https://api.locationiq.com/v1/autocomplete?key=${locationiqToken}&q=${encodeURIComponent(searchQuery)}&countrycodes=ca&format=json&limit=10`;
    
    try {
      const response = await fetch(url);
      
      if (response.ok) {
        const data = await response.json();

        if (Array.isArray(data) && data.length > 0) {
          // Extract house number from input FIRST - this is the key fix
          const inputHouseNumberMatch = input.match(/^(\d+)/);
          const inputHouseNumber = inputHouseNumberMatch ? inputHouseNumberMatch[1] : '';
          
          // Map LocationIQ results to Google-like structure for frontend compatibility
          const predictions = data.map(item => {
            const address = item.address || {};
            
            // ALWAYS use the house number from the input if it exists
            // This ensures we preserve what the user typed
            let houseNumber = inputHouseNumber;
            if (!houseNumber) {
              // Only fall back to LocationIQ house number if no input house number
              houseNumber = address.house_number;
            }
            
            // Build a better main text from address components
            let mainText = '';
            if (houseNumber && address.road) {
              mainText = `${houseNumber} ${address.road}`;
            } else if (houseNumber && address.name) {
              mainText = `${houseNumber} ${address.name}`;
            } else if (address.road) {
              mainText = address.road;
            } else if (address.name) {
              mainText = address.name;
            } else if (address.neighbourhood) {
              mainText = address.neighbourhood;
            } else if (address.suburb) {
              mainText = address.suburb;
            } else if (address.city) {
              mainText = address.city;
            } else {
              mainText = item.display_name.split(',')[0] || '';
            }
            
            // Build secondary text with city, province, and postal code
            let secondaryText = '';
            if (address.city && address.state) {
              secondaryText = `${address.city}, ${address.state}`;
              if (address.postcode) {
                secondaryText += `, ${address.postcode}`;
              }
            } else if (address.city) {
              secondaryText = address.city;
              if (address.postcode) {
                secondaryText += `, ${address.postcode}`;
              }
            } else if (address.postcode) {
              secondaryText = address.postcode;
            } else {
              secondaryText = item.display_name;
            }
            
            // Ensure description includes postal code
            let description = item.display_name;
            if (!description.includes(address.postcode) && address.postcode) {
              // Add postal code to description if not already present
              description = description.replace(', Canada', `, ${address.postcode}, Canada`);
            }
            
            return {
              description: description,
              place_id: item.place_id || item.osm_id,
              structured_formatting: {
                main_text: mainText,
                secondary_text: secondaryText
              },
              address: {
                ...address,
                // Ensure we have the street name in the road field for consistency
                road: address.road || address.name || '',
                // ALWAYS use the input house number if available
                house_number: houseNumber || ''
              },
              lat: item.lat,
              lon: item.lon
            };
          });
          
          // LESS STRICT FILTERING: Show results earlier and be more flexible
          let filteredPredictions = predictions;
          
          // Extract context from input for filtering
          let contextPostalCode = null;
          let contextCity = null;
          let contextProvince = null;
          
          // Try to extract postal code from input
          const postalMatch = input.match(/\b[A-Z]\d[A-Z]\s?\d[A-Z]\d\b/);
          if (postalMatch) {
            contextPostalCode = postalMatch[0].replace(/\s/g, '');
          }
          
          // Try to extract city and province from input
          const parts = input.split(',').map(part => part.trim());
          for (const part of parts) {
            // Check if part is a known city
            const cities = [
              { city: 'Toronto', province: 'ON' },
              { city: 'Vancouver', province: 'BC' },
              { city: 'Montreal', province: 'QC' },
              { city: 'Calgary', province: 'AB' },
              { city: 'Edmonton', province: 'AB' },
              { city: 'Ottawa', province: 'ON' },
              { city: 'Winnipeg', province: 'MB' },
              { city: 'Quebec City', province: 'QC' },
              { city: 'Hamilton', province: 'ON' },
              { city: 'Kitchener', province: 'ON' },
              { city: 'London', province: 'ON' },
              { city: 'Victoria', province: 'BC' },
              { city: 'Halifax', province: 'NS' },
              { city: 'Saskatoon', province: 'SK' },
              { city: 'Regina', province: 'SK' },
              { city: 'St. John\'s', province: 'NL' },
              { city: 'Fredericton', province: 'NB' },
              { city: 'Charlottetown', province: 'PE' },
              { city: 'Whitehorse', province: 'YT' },
              { city: 'Yellowknife', province: 'NT' },
              { city: 'Iqaluit', province: 'NU' },
              { city: 'Trail', province: 'BC' },
              { city: 'Kelowna', province: 'BC' },
              { city: 'Nanaimo', province: 'BC' },
              { city: 'Prince George', province: 'BC' }
            ];
            
            for (const cityData of cities) {
              if (part.toLowerCase() === cityData.city.toLowerCase()) {
                contextCity = cityData.city;
                contextProvince = cityData.province;
                break;
              }
            }
          }
          
          // STRICT POSTAL CODE FILTERING: If we have a postal code in the input, ONLY show results that match
          if (contextPostalCode) {

            filteredPredictions = predictions.filter(prediction => {
              const predPostalCode = prediction.address.postcode;
              if (predPostalCode) {
                const cleanPredPostal = predPostalCode.replace(/\s/g, '');
                const matches = cleanPredPostal === contextPostalCode;

                return matches;
              }
              return false;
            });

            // If no postal code matches found, return empty results instead of falling back
            // This ensures we only show results that match the exact postal code
            if (filteredPredictions.length === 0) {

              return res.json({ predictions: [] });
            }
          } else {
            // If no postal code in input, try city filtering if we have a city
            if (contextCity) {

              filteredPredictions = predictions.filter(prediction => {
                const predCity = prediction.address.city;
                if (predCity) {
                  const matches = predCity.toLowerCase() === contextCity.toLowerCase();

                  return matches;
                }
                return false;
              });

            }
          }
          
          return res.json({ predictions: filteredPredictions });
        }
      } else {
        console.error('LocationIQ API error:', response.status, response.statusText);
      }
    } catch (locationiqError) {
      console.error('LocationIQ API failed:', locationiqError.message);
    }

    // If LocationIQ fails, return empty results instead of fake addresses

    return res.json({ predictions: [] });
    
  } catch (error) {
    console.error('Places autocomplete error:', error);
    res.status(500).json({ error: 'Failed to get address suggestions' });
  }
});

app.get('/api/places/details', auth, async (req, res) => {
  try {
    const { placeId, lat, lon } = req.query;
    const locationiqToken = process.env.locationIqToken;
    
    // For LocationIQ, we need to use the data that was already returned from autocomplete
    // Since LocationIQ doesn't have a direct place details endpoint, we'll use reverse geocoding
    // but we'll also handle the case where we don't have lat/lon
    
    let result = null;

    if (lat && lon) {
      try {
        const url = `https://api.locationiq.com/v1/reverse?key=${locationiqToken}&lat=${lat}&lon=${lon}&format=json`;
        const response = await fetch(url);
        
        if (response.ok) {
          const data = await response.json();
          if (data && data.address) {
            result = data;
          }
        } else {

        }
      } catch (error) {
        console.error('LocationIQ reverse geocoding error:', error);
      }
    }

    if (result) {
      const address = result.address || {};
      res.json({
        success: true,
        address: address,
        formatted_address: result.display_name,
        geometry: result.lat && result.lon ? { lat: result.lat, lng: result.lon } : undefined
      });
    } else {
      // If we can't get details, return a helpful error

      res.status(404).json({ 
        error: 'Place details not available',
        message: 'Unable to retrieve detailed address information for this location'
      });
    }
  } catch (error) {
    console.error('Places details error:', error);
    res.status(500).json({ error: 'Failed to get place details' });
  }
});

app.get('/api/geocode/postalcode', auth, async (req, res) => {
  try {
    const { postalCode } = req.query;
    
    if (!postalCode) {
      return res.status(400).json({ error: 'Postal code is required' });
    }

    // Clean and validate postal code format
    const cleanPostalCode = postalCode.replace(/\s/g, '').toUpperCase();
    
    // More flexible validation - just check if it's 6 characters and has letters/numbers
    if (cleanPostalCode.length !== 6 || !/^[A-Z0-9]{6}$/.test(cleanPostalCode)) {
      return res.status(400).json({ error: 'Invalid postal code format' });
    }

    // 1. Try Geocoder.ca first
    const geoUrl = `https://geocoder.ca/?postal=${encodeURIComponent(cleanPostalCode)}&json=1`;
    let geoResponse, geoData;
    try {
      geoResponse = await fetch(geoUrl);
      geoData = await geoResponse.json();
      
      // Check if we got rate limited
      if (geoData && geoData.error && geoData.error.code === '006') {

        geoData = null; // Reset to try LocationIQ
      }
    } catch (err) {
      console.error('Geocoder.ca fetch error:', err);
      geoData = null;
    }

    if (geoData && geoData.standard && geoData.standard.city && geoData.standard.prov) {
      const city = geoData.standard.city;
      const province = geoData.standard.prov;
      const responseData = {
        success: true,
        location: {
          city,
          province,
          postal_code: cleanPostalCode,
          country: 'CA'
        },
        formatted_address: `${city}, ${province}, Canada`,
        geometry: geoData.latt && geoData.longt ? { lat: geoData.latt, lng: geoData.longt } : undefined
      };
      return res.json(responseData);
    }

    // 2. Fallback to LocationIQ
    const locationiqToken = process.env.locationIqToken;
    if (locationiqToken) {
      try {
        const url = `https://api.locationiq.com/v1/search?key=${locationiqToken}&q=${encodeURIComponent(cleanPostalCode + ', Canada')}&countrycodes=ca&format=json`;
        const response = await fetch(url);
        const data = await response.json();

        if (Array.isArray(data) && data.length > 0) {
          const result = data[0];
          const address = result.address || {};
          const city = address.city || address.town || address.village || address.hamlet || '';
          const province = address.state || '';
          const responseData = {
            success: true,
            location: {
              city,
              province,
              postal_code: cleanPostalCode,
              country: 'CA'
            },
            formatted_address: result.display_name,
            geometry: result.lat && result.lon ? { lat: result.lat, lng: result.lon } : undefined
          };
          return res.json(responseData);
        }
      } catch (err) {
        console.error('LocationIQ fetch error:', err);
      }
    } else {

    }

    // 3. Fallback: Return a generic response for Canadian postal codes

    const responseData = {
      success: false,
      error: 'Postal code lookup service unavailable',
      location: {
        city: '',
        province: '',
        postal_code: cleanPostalCode,
        country: 'CA'
      },
      formatted_address: `${cleanPostalCode}, Canada`,
      message: 'Please enter city and province manually'
    };
    return res.json(responseData);
  } catch (error) {
    console.error('Geocoding error:', error);
    res.status(500).json({ error: 'Failed to geocode postal code' });
  }
});

// Update contact endpoint
app.put('/api/contacts/:id', auth, async (req, res) => {
  try {
    const contactId = req.params.id;
    const user = await findUserById(req.user.id);
    const accountId = getEffectiveAccountId(user);
    const isSpecial = await isSpecialContactStructure(accountId);
    
    // Validate field lengths based on structure type
    if (isSpecial) {
      if (req.body.name && req.body.name.length > 200) {
        throw new Error('Name must be 200 characters or less');
      }
    } else {
      if (req.body.address && req.body.address.length > 200) {
        throw new Error('Address must be 200 characters or less');
      }
      
      if (req.body.firstName && req.body.firstName.length > 100) {
        throw new Error('First name must be 100 characters or less');
      }
      
      if (req.body.lastName && req.body.lastName.length > 100) {
        throw new Error('Last name must be 100 characters or less');
      }
    }
    
    // Get contacts using standardized function
    const contacts = await getAccountContacts(accountId);
    const contactIndex = contacts.findIndex(c => c.id === contactId);
    
    if (contactIndex === -1) {
      throw new Error('Contact not found');
    }
    
    const updatedContact = {
      ...contacts[contactIndex],
      ...req.body,
      id: contactId,
      updatedAt: new Date().toISOString(),
      updatedBy: user.id
    };
    if (req.body.notes !== undefined) {
      updatedContact.notes = Array.isArray(req.body.notes)
        ? req.body.notes.map(n => ({
            text: n && n.text != null ? String(n.text) : '',
            updatedAt: n && n.updatedAt || null,
            authorName: n && n.authorName != null ? String(n.authorName).trim() || null : null
          }))
        : (() => { const t = String(req.body.notes || '').trim(); return t ? [{ text: t, updatedAt: req.body.notesUpdatedAt || new Date().toISOString() }] : []; })();
      if (updatedContact.notesUpdatedAt !== undefined) delete updatedContact.notesUpdatedAt;
    }
    ensureNotesArray(updatedContact);

    // Ensure categories is an array (for backwards compatibility)
    if (updatedContact.category && !updatedContact.categories) {
      updatedContact.categories = [updatedContact.category];
      delete updatedContact.category;
    }
    if (!updatedContact.categories) {
      updatedContact.categories = [];
    }
    
    // Update the contact in shared-data
    contacts[contactIndex] = updatedContact;
    
    // Update shared contacts using standardized function
    await updateAccountContacts(accountId, contacts);
    
    res.json(updatedContact);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Delete all contacts endpoint (must come before /:id route) - Account holders only
app.delete('/api/contacts/bulk-delete', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    // Check if user has permission to delete all contacts (only account holders and app owners)
    if (user.userType === 'team_member') {
      return res.status(403).json({ 
        error: 'Permission denied', 
        message: 'Team members cannot delete all contacts. Only account holders and app owners can perform this action.' 
      });
    }

    if (!user) {
      console.error('User not found in delete all contacts:', req.user);
      throw new Error('User not found');
    }
    
    // Get current contacts count using standardized function
    const accountId = getEffectiveAccountId(user);
    const contacts = await getAccountContacts(accountId);
    const contactCount = contacts.length;

    // Soft delete all contacts using shared-data structure
    const result = await softDeleteContacts(req.user.id);
    
    // Log the audit event
    await logAuditEvent(req.user.id, 'DELETE_ALL_CONTACTS', {
      deletedCount: result.deletedCount,
      remainingCount: result.remainingCount,
      userEmail: user.email
    }, req);

    // Get the updated contacts from shared-data
    const updatedContacts = await getAccountContacts(accountId);
    
    res.json({
      contacts: updatedContacts,
      deletedCount: result.deletedCount,
      message: `Moved ${result.deletedCount} contacts to trash. They can be restored within 30 days.`
    });
  } catch (error) {
    console.error('Delete all contacts error:', error.stack || error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      userId: req.user?.id
    });
    res.status(400).json({ error: error.message });
  }
});

// Permanently delete contacts from trash endpoint (must come before /:id route)
app.delete('/api/contacts/trash', auth, async (req, res) => {
  try {

    const { ids } = req.body || {};
    const user = await findUserById(req.user.id);
    
    // Get trash from shared-data structure
    const accountId = user.accountId || user.id;
    const trashPath = path.join(__dirname, 'data', 'shared-data', accountId, 'trash.json');
    
    let trash = [];
    try {
      const trashData = await fsPromises.readFile(trashPath, 'utf8');
      trash = JSON.parse(trashData);
    } catch (error) {
      // File doesn't exist, start with empty trash
      trash = [];
    }

    // If ids is provided and not empty, delete specific contacts, otherwise delete all
    const contactsToDelete = ids && Array.isArray(ids) && ids.length > 0
      ? trash.filter(c => ids.includes(c.id))
      : trash;

    // Remove the contacts from trash
    if (ids && Array.isArray(ids) && ids.length > 0) {
      const originalTrashLength = trash.length;
      trash = trash.filter(c => !ids.includes(c.id));

    } else {
      trash = [];

    }

    // Update shared trash file
    await fsPromises.writeFile(trashPath, JSON.stringify(trash, null, 2), 'utf8');
    
    // Log the audit event
    await logAuditEvent(req.user.id, 'PERMANENT_DELETE_CONTACTS', {
      deletedCount: contactsToDelete.length,
      deletedIds: ids && Array.isArray(ids) && ids.length > 0 ? ids : 'all',
      userEmail: user.email
    }, req);
    
    res.json({
      deletedCount: contactsToDelete.length,
      message: `Permanently deleted ${contactsToDelete.length} contacts from trash.`
    });
  } catch (error) {
    console.error('Trash deletion error:', error);
    console.error('Error stack:', error.stack);
    res.status(400).json({ error: error.message });
  }
});

// Delete contact endpoint
app.delete('/api/contacts/:id', auth, async (req, res) => {
  try {
    const contactId = req.params.id;
    const user = await findUserById(req.user.id);
    
    // Check if contact exists using standardized function
    const accountId = getEffectiveAccountId(user);
    const contacts = await getAccountContacts(accountId);
    
    const contactIndex = contacts.findIndex(c => c.id === contactId);
    if (contactIndex === -1) {
      throw new Error('Contact not found');
    }
    
    // Soft delete the contact
    const result = await softDeleteContacts(req.user.id, [contactId]);
    
    // Log the audit event
    await logAuditEvent(req.user.id, 'DELETE_CONTACT', {
      deletedCount: 1,
      deletedId: contactId,
      remainingCount: result.remainingCount,
      userEmail: user.email
    }, req);
    
    // Get the updated contacts from shared-data
    const updatedContacts = await getAccountContacts(accountId);
    
    res.json({
      contacts: updatedContacts,
      deletedCount: 1,
      message: 'Contact moved to trash. It can be restored within 30 days.'
    });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Bulk delete contacts endpoint
app.post('/api/contacts/bulk-delete', auth, async (req, res) => {
  try {
    const { ids } = req.body;
    const user = await findUserById(req.user.id);
    
    if (ids && ids.length > 0) {
      // Soft delete specific contacts
      const result = await softDeleteContacts(req.user.id, ids);
      
      // Log the audit event
      await logAuditEvent(req.user.id, 'BULK_DELETE_CONTACTS', {
        deletedCount: result.deletedCount,
        deletedIds: ids,
        remainingCount: result.remainingCount,
        userEmail: user.email
      }, req);
      
      // Get the updated contacts using standardized function
      const accountId = getEffectiveAccountId(user);
      const updatedContacts = await getAccountContacts(accountId);
      
      res.json({
        contacts: updatedContacts,
        deletedCount: result.deletedCount,
        message: `Moved ${result.deletedCount} contacts to trash. They can be restored within 30 days.`
      });
    } else {
      // Delete all contacts (soft delete)
      const result = await softDeleteContacts(req.user.id);
      
      // Log the audit event
      await logAuditEvent(req.user.id, 'DELETE_ALL_CONTACTS', {
        deletedCount: result.deletedCount,
        remainingCount: result.remainingCount,
        userEmail: user.email
      }, req);
      
      // Get the updated contacts using standardized function
      const accountId = getEffectiveAccountId(user);
      const updatedContacts = await getAccountContacts(accountId);
      
      res.json({
        contacts: updatedContacts,
        deletedCount: result.deletedCount,
        message: `Moved ${result.deletedCount} contacts to trash. They can be restored within 30 days.`
      });
    }
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Bulk update contacts endpoint
app.post('/api/contacts/bulk-update', auth, async (req, res) => {
  try {
    const { ids, updates } = req.body;
    const user = await findUserById(req.user.id);
    
    // Get contacts from shared-data
    const accountId = user.accountId || user.id;
    const contacts = await getAccountContacts(accountId);
    
    const updatedContacts = contacts.map(contact => {
      if (ids.includes(contact.id)) {
        return { ...contact, ...updates, updatedAt: new Date().toISOString(), updatedBy: user.id };
      }
      return contact;
    });
    
    // Update shared contacts file
    const sharedContactsPath = path.join(__dirname, 'data', 'shared-data', accountId, 'contacts.json');
    await fsPromises.writeFile(sharedContactsPath, JSON.stringify(updatedContacts, null, 2), 'utf8');
    
    res.json(updatedContacts);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get trash endpoint
app.get('/api/contacts/trash', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    // Get trash using standardized function
    const accountId = getEffectiveAccountId(user);
    const trashPath = path.join(__dirname, 'data', 'shared-data', accountId, 'trash.json');
    
    let trash = [];
    try {
      const trashData = await fsPromises.readFile(trashPath, 'utf8');
      trash = JSON.parse(trashData);
    } catch (error) {
      // File doesn't exist, start with empty trash
      trash = [];
    }
    
    // Clean up old trash entries
    await cleanupOldTrash(req.user.id);
    
    res.json(trash);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Restore contacts from trash endpoint
app.post('/api/contacts/restore', auth, async (req, res) => {
  try {
    const { ids } = req.body;
    const user = await findUserById(req.user.id);
    
    if (!ids || ids.length === 0) {
      throw new Error('No contact IDs provided');
    }
    
    const result = await restoreContacts(req.user.id, ids);
    
    // Log the audit event
    await logAuditEvent(req.user.id, 'RESTORE_CONTACTS', {
      restoredCount: result.restoredCount,
      restoredIds: ids,
      userEmail: user.email
    }, req);
    
    // Get the updated contacts using standardized function
    const accountId = getEffectiveAccountId(user);
    const updatedContacts = await getAccountContacts(accountId);
    
    res.json({
      contacts: updatedContacts,
      restoredCount: result.restoredCount,
      message: `Restored ${result.restoredCount} contacts from trash.`
    });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get audit logs endpoint (admin only)
app.get('/api/admin/audit-logs', adminAuth, async (req, res) => {
  try {

    const auditDir = 'data/audit-logs';
    
    // Create audit directory if it doesn't exist
    if (!fs.existsSync(auditDir)) {

      fs.mkdirSync(auditDir, { recursive: true });
      return res.json([]);
    }
    
    const files = fs.readdirSync(auditDir).filter(file => file.endsWith('.json'));

    const allLogs = [];
    
    for (const file of files) {
      try {
        const filePath = `${auditDir}/${file}`;

        const logs = JSON.parse(fs.readFileSync(filePath, 'utf8'));
        allLogs.push(...logs);
      } catch (e) {
        console.error('Error reading audit log file:', file, e);
      }
    }
    
    // Sort by timestamp (newest first)
    allLogs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    // Only return allowed audit action types
    const allowed = new Set(['TEAM_MEMBER_ADDED', 'TEAM_MEMBER_REMOVED', 'DELETE_ALL_CONTACTS', 'UNSUBSCRIBE', 'FAILED_BULK_EMAIL', 'FAILED_BULK_SMS', 'FAILED_BULK_AI']);
    const filtered = allLogs.filter(log => allowed.has(log.action));

    res.json(filtered);
  } catch (error) {
    console.error('Audit logs API error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Bulk import contacts endpoint
app.post('/api/contacts/bulk-import', auth, async (req, res) => {
  try {
    const { contacts } = req.body;
    const user = await findUserById(req.user.id);
    const accountId = getEffectiveAccountId(user);
    const isSpecial = await isSpecialContactStructure(accountId);
    
    // Get existing contacts for deduplication
    const existingContacts = await getAccountContacts(accountId);
    
    // Helper function to check if two contacts are EXACTLY the same
    const isExactDuplicate = (contact1, contact2, isSpecial) => {
      if (isSpecial) {
        // For special structure (EDA)
        return (
          (contact1.name || '').toLowerCase().trim() === (contact2.name || '').toLowerCase().trim() &&
          (contact1.riding || '').toLowerCase().trim() === (contact2.riding || '').toLowerCase().trim() &&
          (contact1.province || '').toLowerCase().trim() === (contact2.province || '').toLowerCase().trim() &&
          (contact1.email || '').toLowerCase().trim() === (contact2.email || '').toLowerCase().trim() &&
          (contact1.role || '').toLowerCase().trim() === (contact2.role || '').toLowerCase().trim() &&
          (contact1.phone || '').replace(/\D/g, '') === (contact2.phone || '').replace(/\D/g, '')
        );
      } else {
        // For standard structure
        const cats1 = Array.isArray(contact1.categories) ? [...contact1.categories].sort().join('|') : '';
        const cats2 = Array.isArray(contact2.categories) ? [...contact2.categories].sort().join('|') : '';
        
        return (
          (contact1.firstName || '').toLowerCase().trim() === (contact2.firstName || '').toLowerCase().trim() &&
          (contact1.lastName || '').toLowerCase().trim() === (contact2.lastName || '').toLowerCase().trim() &&
          (contact1.email || '').toLowerCase().trim() === (contact2.email || '').toLowerCase().trim() &&
          (contact1.phone || '').replace(/\D/g, '') === (contact2.phone || '').replace(/\D/g, '') &&
          (contact1.address || '').toLowerCase().trim() === (contact2.address || '').toLowerCase().trim() &&
          (contact1.city || '').toLowerCase().trim() === (contact2.city || '').toLowerCase().trim() &&
          (contact1.province || '').toLowerCase().trim() === (contact2.province || '').toLowerCase().trim() &&
          (contact1.postalCode || '').replace(/\s/g, '').toUpperCase() === (contact2.postalCode || '').replace(/\s/g, '').toUpperCase() &&
          cats1 === cats2
        );
      }
    };
    
    // USER REQUIREMENT: Skip EXACT duplicates only - if record exists exactly, don't import
    // If same name but different data, DO import
    const uniqueContacts = [];
    const skippedDuplicates = [];
    
    for (const contact of contacts) {
      // First check if this is an exact duplicate within the batch
      let isDuplicateInBatch = false;
      for (const existingInBatch of uniqueContacts) {
        if (isExactDuplicate(contact, existingInBatch, isSpecial)) {
          isDuplicateInBatch = true;
          skippedDuplicates.push({ 
            contact: isSpecial ? contact.name : `${contact.firstName} ${contact.lastName}`, 
            reason: 'Exact duplicate in import file' 
          });
          break;
        }
      }
      
      if (isDuplicateInBatch) {
        continue;
      }
      
      // Check against existing contacts - skip ONLY if exact duplicate
      let isExactDupe = false;
      for (const existingContact of existingContacts) {
        if (isExactDuplicate(contact, existingContact, isSpecial)) {
          isExactDupe = true;
          skippedDuplicates.push({ 
            contact: isSpecial ? contact.name : `${contact.firstName} ${contact.lastName}`, 
            reason: 'Exact duplicate already exists in database' 
          });
          break;
        }
      }
      
      if (isExactDupe) {
        continue;
      }
      
      // Not an exact duplicate - add to import list
      uniqueContacts.push(contact);
    }
    
    // Add IDs and timestamps to unique contacts
    const newContacts = uniqueContacts.map(contact => ({
      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
      ...contact,
      uploadedAt: new Date().toISOString()
    }));
    
    // Add to shared contacts using standardized function
    const updatedContacts = existingContacts.concat(newContacts);
    
    // Update shared contacts using standardized function
    await updateAccountContacts(accountId, updatedContacts);
    
    // Track the upload operation for undo functionality in shared-data
    const uploadHistoryPath = path.join(__dirname, 'data', 'shared-data', accountId, 'upload-history.json');
    
    let uploadHistory = [];
    try {
      const uploadHistoryData = await fsPromises.readFile(uploadHistoryPath, 'utf8');
      uploadHistory = JSON.parse(uploadHistoryData);
    } catch (error) {
      // File doesn't exist, start with empty history
      uploadHistory = [];
    }
    
    const uploadOperation = {
      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
      timestamp: new Date().toISOString(),
      contactIds: newContacts.map(c => c.id),
      contactCount: newContacts.length,
      skippedCount: skippedDuplicates.length
    };
    
    // Keep only the last 5 upload operations for undo
    uploadHistory.unshift(uploadOperation);
    uploadHistory = uploadHistory.slice(0, 5);
    
    // Update shared upload history file
    await fsPromises.writeFile(uploadHistoryPath, JSON.stringify(uploadHistory, null, 2), 'utf8');
    
    res.json(updatedContacts);
    
    // Log the bulk import operation
    await logAuditEvent(req.user.id, 'BULK_IMPORT_CONTACTS', {
      contactCount: newContacts.length,
      skippedCount: skippedDuplicates.length,
      uploadOperationId: newContacts.length > 0 ? newContacts[0].id : 'unknown'
    }, req);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get upload history endpoint
app.get('/api/contacts/upload-history', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    // Get upload history using standardized function
    const accountId = getEffectiveAccountId(user);
    const uploadHistoryPath = path.join(__dirname, 'data', 'shared-data', accountId, 'upload-history.json');
    
    let uploadHistory = [];
    try {
      const uploadHistoryData = await fsPromises.readFile(uploadHistoryPath, 'utf8');
      uploadHistory = JSON.parse(uploadHistoryData);
    } catch (error) {
      // File doesn't exist, start with empty history
      uploadHistory = [];
    }
    
    res.json(uploadHistory);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Undo most recent contact upload endpoint
app.post('/api/contacts/undo-upload', auth, async (req, res) => {
  try {
    const { uploadOperationId } = req.body;
    const user = await findUserById(req.user.id);
    
    // Get upload history using standardized function
    const accountId = getEffectiveAccountId(user);
    const uploadHistoryPath = path.join(__dirname, 'data', 'shared-data', accountId, 'upload-history.json');
    
    let uploadHistory = [];
    try {
      const uploadHistoryData = await fsPromises.readFile(uploadHistoryPath, 'utf8');
      uploadHistory = JSON.parse(uploadHistoryData);
    } catch (error) {
      // File doesn't exist, start with empty history
      uploadHistory = [];
    }
    
    if (!uploadHistory || uploadHistory.length === 0) {
      return res.status(400).json({ error: 'No upload history found' });
    }
    
    // Find the upload operation to undo
    let uploadToUndo;
    if (uploadOperationId) {
      uploadToUndo = uploadHistory.find(op => op.id === uploadOperationId);
      if (!uploadToUndo) {
        return res.status(400).json({ error: 'Upload operation not found' });
      }
    } else {
      // Use the most recent upload if no specific ID provided
      uploadToUndo = uploadHistory[0];
    }
    
    // Remove contacts that were part of this upload from shared-data
    const contactIdsToRemove = uploadToUndo.contactIds;
    const contacts = await getAccountContacts(accountId);
    const originalContactCount = contacts.length;
    
    const remainingContacts = contacts.filter(contact => 
      !contactIdsToRemove.includes(contact.id)
    );
    
    const removedContactCount = originalContactCount - remainingContacts.length;
    
    // Update shared contacts using standardized function
    await updateAccountContacts(accountId, remainingContacts);
    
    // Remove the upload operation from history
    uploadHistory = uploadHistory.filter(op => op.id !== uploadToUndo.id);
    
    // Update shared upload history file
    await fsPromises.writeFile(uploadHistoryPath, JSON.stringify(uploadHistory, null, 2), 'utf8');
    
    // Log the undo operation
    await logAuditEvent(req.user.id, 'UNDO_UPLOAD_CONTACTS', {
      uploadOperationId: uploadToUndo.id,
      originalUploadTimestamp: uploadToUndo.timestamp,
      removedContactCount: removedContactCount,
      expectedContactCount: uploadToUndo.contactCount
    }, req);
    
    res.json({
      success: true,
      message: `Successfully undone upload of ${removedContactCount} contacts`,
      contacts: remainingContacts,
      undoneOperation: {
        id: uploadToUndo.id,
        timestamp: uploadToUndo.timestamp,
        contactCount: uploadToUndo.contactCount
      }
    });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Smart Contact Import - Helper Functions
const detectColumnType = (header, sampleValues) => {
  const headerLower = header.toLowerCase().trim();
  const headerNormalized = headerLower.replace(/[_\s-]/g, '');
  
  // Pattern-based detection from sample values FIRST (more accurate)
  if (sampleValues && sampleValues.length > 0) {
    const sampleStr = sampleValues.join(' ').toLowerCase();
    const firstSample = String(sampleValues[0] || '').trim();
    
    // Date detection - check if values look like dates (YYYY-MM-DD or similar)
    // This should NOT be mapped to phone
    const datePattern = /^\d{4}-\d{2}-\d{2}$|^\d{2}\/\d{2}\/\d{4}$|^\d{4}\/\d{2}\/\d{2}$/;
    if (datePattern.test(firstSample) || 
        (sampleValues.length > 1 && sampleValues.slice(0, 3).every(v => datePattern.test(String(v).trim())))) {
      // This is a date column - don't map it to anything (or map to 'unmapped')
      return null;
    }
    
    // Email pattern - check sample values first
    if (/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/.test(sampleStr)) {
      return 'email';
    }
    
    // Phone pattern - but exclude dates
    const phonePattern = /[\d\s\-\(\)]{10,}/;
    const digitsOnly = sampleStr.replace(/\D/g, '');
    if (phonePattern.test(sampleStr) && digitsOnly.length >= 10 && digitsOnly.length <= 11 && 
        !datePattern.test(firstSample)) {
      return 'phone';
    }
  }
  
  // Email detection by header
  if (headerNormalized.includes('email') || headerNormalized.includes('e-mail')) {
    return 'email';
  }
  
  // Phone detection by header - but verify it's not dates in sample values
  if (headerNormalized.includes('phone') || headerNormalized.includes('tel') || 
      headerNormalized.includes('mobile') || headerNormalized.includes('cell') ||
      (headerNormalized.includes('res') && headerNormalized.includes('number'))) {
    // Double-check: if sample values look like dates, don't map to phone
    if (sampleValues && sampleValues.length > 0) {
      const firstSample = String(sampleValues[0] || '').trim();
      const datePattern = /^\d{4}-\d{2}-\d{2}$/;
      if (datePattern.test(firstSample)) {
        return null; // It's dates, not phone
      }
    }
    return 'phone';
  }
  
  // Name detection - be more aggressive
  if (headerNormalized.includes('firstname') || headerNormalized === 'first' || 
      headerNormalized === 'fname' || headerNormalized === 'givenname' ||
      headerNormalized === 'firstname' || headerNormalized.includes('firstname')) {
    return 'firstName';
  }
  if (headerNormalized.includes('lastname') || headerNormalized === 'last' || 
      headerNormalized === 'lname' || headerNormalized === 'surname' || 
      headerNormalized === 'familyname' || headerNormalized.includes('lastname')) {
    return 'lastName';
  }
  if (headerNormalized.includes('fullname') || headerNormalized === 'name' || 
      headerNormalized.includes('contactname') || headerNormalized.includes('fullname') ||
      headerNormalized.includes('membername') || headerNormalized.includes('membernameid') ||
      (headerNormalized.includes('name') && !headerNormalized.includes('address') && 
       !headerNormalized.includes('addresses') && !headerNormalized.includes('file') && 
       !headerNormalized.includes('user') && !headerNormalized.includes('first') && 
       !headerNormalized.includes('last'))) {
    return 'fullName';
  }
  
  // Pattern-based name detection from sample values
  if (sampleValues && sampleValues.length > 0) {
    const firstSample = String(sampleValues[0] || '').trim();
    const sampleStr = sampleValues.join(' ').trim();
    
    // Check for "Last, First" format (highest priority)
    if (/^[A-Z][a-z]+,\s+[A-Z]/.test(firstSample)) {
      return 'fullName';
    }
    
    // Check if it looks like a name (2-3 capitalized words, no numbers, no @ symbol)
    if (sampleStr.length > 3 && sampleStr.length < 50 && 
        !sampleStr.includes('@') && !/\d{4,}/.test(sampleStr) &&
        !sampleStr.toLowerCase().includes('poll') &&
        !sampleStr.toLowerCase().includes('address') &&
        (/^[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2}$/.test(sampleStr.trim()) ||
         /^[A-Z][a-z]+,\s+[A-Z]/.test(sampleStr.trim()))) {
      // If it's a single capitalized word or two capitalized words, likely a name
      const words = sampleStr.trim().split(/\s+/);
      if (words.length >= 1 && words.length <= 4) {
        return 'fullName';
      }
    }
  }
  
  // Address detection - check for "addresses" (plural) too
  // Also detect "Member Information" or similar columns that contain multiple data types
  if (headerNormalized.includes('address') || headerNormalized.includes('street') || 
      headerNormalized.includes('addr') || headerNormalized.includes('addresses') ||
      headerNormalized.includes('memberinformation') || headerNormalized.includes('memberinfo')) {
    // Check if sample values contain multiple data types (address, phone, email)
    if (sampleValues && sampleValues.length > 0) {
      const sampleStr = sampleValues.join(' ').toLowerCase();
      const hasAddress = sampleStr.includes('res. add:') || sampleStr.includes('mailing add:') || 
                        sampleStr.includes('address') || sampleStr.includes('road') || 
                        sampleStr.includes('street') || sampleStr.includes('ave');
      const hasPhone = sampleStr.includes('phone:') || sampleStr.includes('cell phone:') || 
                      /\(?\d{3}\)?\s*\d{3}[-.]?\d{4}/.test(sampleStr);
      const hasEmail = sampleStr.includes('e-mail') || sampleStr.includes('email') || 
                      /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/.test(sampleStr);
      
      // If it has multiple data types, treat as fullAddress (will be parsed later)
      if (hasAddress && (hasPhone || hasEmail)) {
        return 'fullAddress';
      }
    }
    return 'address';
  }
  if (headerNormalized === 'city' || headerNormalized === 'town') {
    return 'city';
  }
  if (headerNormalized === 'province' || headerNormalized === 'state' || 
      headerNormalized === 'prov') {
    return 'province';
  }
  if (headerNormalized.includes('postal') || headerNormalized.includes('zip') || 
      headerNormalized === 'postcode') {
    return 'postalCode';
  }
  
  // Category detection
  if (headerNormalized.includes('category') || headerNormalized.includes('cat') || 
      headerNormalized.includes('tag') || headerNormalized.includes('type')) {
    return 'category';
  }
  
  // Additional pattern-based detection from sample values (for remaining fields)
  if (sampleValues && sampleValues.length > 0) {
    const sampleStr = sampleValues.join(' ').toLowerCase();
    
    // Postal code pattern (Canadian: A1A 1A1 or US: 12345)
    const postalPattern = /[A-Z]\d[A-Z]\s?\d[A-Z]\d|\d{5}(-\d{4})?/i;
    if (postalPattern.test(sampleStr)) {
      return 'postalCode';
    }
  }
  
  return null;
};

const splitFullName = (fullName) => {
  if (!fullName || typeof fullName !== 'string') {
    return { firstName: '', lastName: '' };
  }
  
  let trimmed = fullName.trim();
  if (!trimmed) {
    return { firstName: '', lastName: '' };
  }
  
  // Skip if it looks like a poll/location header (starts with "Poll" or is just a number)
  if (/^(Poll\s+\d+|^\d+$)/i.test(trimmed)) {
    return { firstName: '', lastName: '' };
  }
  
  // Remove common titles (Mr., Mrs., Ms., Miss, Dr., etc.)
  trimmed = trimmed.replace(/^(Mr\.|Mrs\.|Ms\.|Miss|Dr\.|Prof\.|Rev\.)\s+/i, '');
  
  // Remove common suffixes (e.g., "- CPC Membership", "- Membership", etc.)
  trimmed = trimmed.replace(/\s*-\s*(CPC\s+)?Membership.*$/i, '');
  trimmed = trimmed.replace(/\s*-\s*.*$/i, ''); // Remove any other "- suffix" patterns
  
  // Clean up extra spaces
  trimmed = trimmed.replace(/\s+/g, ' ').trim();
  
  // If there's a comma, the format is likely "Last, First" or "Last, First Middle"
  if (trimmed.includes(',')) {
    const commaParts = trimmed.split(',').map(p => p.trim()).filter(p => p);
    if (commaParts.length >= 2) {
      // Format: "Last, First" or "Last, First Middle"
      const lastName = commaParts[0];
      const firstName = commaParts.slice(1).join(' ');
      return { firstName, lastName };
    }
  }
  
  // Default: split by spaces
  const parts = trimmed.split(/\s+/).filter(p => p.length > 0);
  
  if (parts.length === 0) {
    return { firstName: '', lastName: '' };
  }
  
  if (parts.length === 1) {
    return { firstName: parts[0], lastName: '' };
  }
  
  // Last name is typically the last word, first name is everything else
  const lastName = parts[parts.length - 1];
  const firstName = parts.slice(0, -1).join(' ');
  
  return { firstName, lastName };
};

// Ensure contacts imported with combined names have separated first/last fields
const normalizeContactName = (contact) => {
  if (!contact) {
    return false;
  }

  const originalFirst = contact.firstName || '';
  const originalLast = contact.lastName || '';
  const trimmedFirst = originalFirst.trim();
  const trimmedLast = originalLast.trim();
  let updated = false;

  const shouldSplitFirst = (!trimmedLast || trimmedLast.length === 0) &&
    trimmedFirst &&
    /[\s,]/.test(trimmedFirst);

  if (shouldSplitFirst) {
    const { firstName, lastName } = splitFullName(trimmedFirst);
    if (lastName) {
      contact.firstName = firstName || contact.firstName;
      contact.lastName = lastName;
      updated = true;
    }
  }

  const shouldSplitLastOnly = (!trimmedFirst || trimmedFirst.length === 0) &&
    trimmedLast &&
    /[\s,]/.test(trimmedLast);

  if (shouldSplitLastOnly) {
    const { firstName, lastName } = splitFullName(trimmedLast);
    if (firstName || lastName) {
      if (firstName) {
        contact.firstName = firstName;
      }
      if (lastName) {
        contact.lastName = lastName;
      }
      updated = true;
    }
  }

  return updated;
};

const parseAddress = (fullAddress) => {
  if (!fullAddress || typeof fullAddress !== 'string') {
    return { address: '', city: '', province: '', postalCode: '' };
  }
  
  let trimmed = fullAddress.trim();
  if (!trimmed) {
    return { address: '', city: '', province: '', postalCode: '' };
  }
  
  // Handle "Res.:" and "Post.:" format - prefer postal address for mailing
  // Also handle "Res. Add:" and "Mailing Add:" formats
  let addressToParse = trimmed;
  
  // Normalize newlines first
  const normalized = trimmed.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  
  // Check for "Mailing Add:" (postal address) - preferred for mailing
  const mailingMatch = normalized.match(/Mailing\s+Add\.?:\s*([\s\S]+?)(?:\n|$|"|'|Res\.|Home|E-mail)/i);
  // Check for "Post.:" (postal address) - preferred for mailing
  const postMatch = !mailingMatch ? normalized.match(/Post\.:\s*([\s\S]+?)(?:\s*$|"|'|\s*Res\.:)/i) : null;
  // Check for "Res. Add:" (residential address)
  const resAddMatch = !mailingMatch && !postMatch ? normalized.match(/Res\.\s+Add\.?:\s*([\s\S]+?)(?:\n|$|"|'|Mailing|Home|E-mail)/i) : null;
  // Check for "Res.:" (residential address) - only if no postal found
  const resMatch = !mailingMatch && !postMatch && !resAddMatch ? normalized.match(/Res\.:\s*([\s\S]+?)(?:\s*Post\.:|$|"|')/i) : null;
  
  if (mailingMatch) {
    // Use mailing address (preferred for mailing)
    addressToParse = mailingMatch[1].trim();
  } else if (postMatch) {
    // Use postal address (preferred for mailing)
    addressToParse = postMatch[1].trim();
  } else if (resAddMatch) {
    // Fall back to residential address
    addressToParse = resAddMatch[1].trim();
  } else if (resMatch) {
    // Fall back to residential address if no postal
    addressToParse = resMatch[1].trim();
  }
  
  // Clean up the address - remove newlines, quotes, and extra whitespace
  addressToParse = addressToParse.replace(/["']/g, '').replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
  trimmed = addressToParse;
  
  // Province map (full names and abbreviations)
  const provinceMap = {
    'ontario': 'ON', 'on': 'ON',
    'quebec': 'QC', 'qc': 'QC', 'quÃ©bec': 'QC',
    'british columbia': 'BC', 'bc': 'BC', 'b.c.': 'BC',
    'alberta': 'AB', 'ab': 'AB',
    'manitoba': 'MB', 'mb': 'MB',
    'saskatchewan': 'SK', 'sk': 'SK',
    'nova scotia': 'NS', 'ns': 'NS',
    'new brunswick': 'NB', 'nb': 'NB',
    'newfoundland': 'NL', 'nl': 'NL', 'newfoundland and labrador': 'NL',
    'prince edward island': 'PE', 'pe': 'PE', 'pei': 'PE',
    'northwest territories': 'NT', 'nt': 'NT',
    'nunavut': 'NU', 'nu': 'NU',
    'yukon': 'YT', 'yt': 'YT'
  };
  
  // Step 1: Extract postal code (most reliable - Canadian format: A1A 1A1)
  let postalCode = '';
  const postalCodeRegex = /\b([A-Z]\d[A-Z]\s?\d[A-Z]\d)\b/i;
  const postalMatch = trimmed.match(postalCodeRegex);
  if (postalMatch) {
    postalCode = postalMatch[1].replace(/\s/g, '').toUpperCase();
    if (postalCode.length === 6) {
      postalCode = postalCode.slice(0, 3) + ' ' + postalCode.slice(3);
    }
    // Remove postal code from string for further processing
    trimmed = trimmed.replace(postalCodeRegex, '').trim();
  }
  
  // Step 2: Extract province (look for abbreviations first, then full names)
  let province = '';
  let provinceMatch = null;
  
  // Try province abbreviations (2 letters) - must be word boundaries
  const provinceAbbrevRegex = /\b(ON|QC|BC|AB|MB|SK|NS|NB|NL|PE|NT|NU|YT)\b/i;
  const abbrevMatch = trimmed.match(provinceAbbrevRegex);
  if (abbrevMatch) {
    province = abbrevMatch[1].toUpperCase();
    provinceMatch = abbrevMatch;
  } else {
    // Try full province names
    const addressLower = trimmed.toLowerCase();
    for (const [key, value] of Object.entries(provinceMap)) {
      if (key.length > 2 && addressLower.includes(key)) {
        // Use word boundary to avoid partial matches
        const regex = new RegExp('\\b' + key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
        const match = trimmed.match(regex);
        if (match) {
          province = value;
          provinceMatch = match;
          break;
        }
      }
    }
  }
  
  // Remove province from string
  if (provinceMatch) {
    trimmed = trimmed.replace(provinceMatch[0], '').trim();
    // Remove any trailing commas
    trimmed = trimmed.replace(/,\s*$/, '').trim();
  }
  
  // Step 3: Extract city (usually the last word/phrase before province/postal code)
  let city = '';
  
  // Common street suffixes that should NOT be part of city name
  // Note: Some words like "Trail" can be both a street suffix and a city name
  // We'll check for cities first, then street suffixes
  const streetSuffixes = [
    'Ave', 'Avenue', 'St', 'Street', 'Rd', 'Road', 'Dr', 'Drive', 'Ct', 'Court', 'Crt',
    'Cres', 'Crescent', 'Blvd', 'Boulevard', 'Way', 'Gate', 'Hwy', 'Highway', 'Ln', 'Lane',
    'Pl', 'Place', 'Tr', 'Cir', 'Circle', 'Pkwy', 'Parkway', 'Cove', 'Pt', 'Point',
    'Bay', 'Bend', 'Close', 'Wynd', 'Green', 'Fairway', 'Landng', 'Crt', 'Court'
    // Note: "Trail" removed from street suffixes - it's a city name, handled separately
  ];
  
  // Known Canadian cities (multi-word cities that might be confused with street names)
  // Note: Do NOT include "Glen Invermere" or "Terr Kimberley" - these should be parsed
  // as "Invermere" and "Kimberley" respectively, with "Glen" and "Terr" staying in address
  const knownCities = [
    // Multi-word cities
    'Spruce Grove', 'Stony Plain', 'Parkland County', 'Yellowhead County', 
    'Lac Ste. Anne County', 'Brazeau County', 'St. Albert', 'Fort McMurray', 
    'Grande Prairie', 'Red Deer', 'Medicine Hat', 'Lethbridge', 'Calgary', 
    'Edmonton', 'Fort Saskatchewan', 'Seba Beach', 'Evansburg', 'Wildwood', 
    'Fallis', 'Wabamun', 'Breton', 'Mayerthorpe', 'Duffield', 'Drayton Valley',
    'Rocky Rapids', 'Lodgepole', 'Lindale', 'Carnwood', 'Onoway', 'Tomahawk',
    'Acheson', 'Carvel', 'Spring Lake', 'Meadow Creek',
    'Kootenay Central', 'Grassland', 'Edgewater'
  ];
  
  // Single-word cities that commonly appear after street addresses
  // These are checked separately to avoid false matches
  const commonSingleWordCities = [
    'Trail', 'Invermere', 'Kimberley', 'Kaslo', 'Windermere', 'Cranbrook',
    'Jaffray', 'Fernie', 'Sparwood', 'Elkford', 'Golden', 'Revelstoke',
    'Nelson', 'Castlegar', 'Rossland', 'Salmo', 'Creston', 'Nakusp',
    'New Denver', 'Slocan', 'Vancouver', 'Victoria', 'Surrey', 'Burnaby',
    'Richmond', 'Coquitlam', 'Langley', 'North Vancouver', 'West Vancouver',
    'Kelowna', 'Kamloops', 'Prince George', 'Nanaimo', 'Abbotsford',
    'Chilliwack', 'Maple Ridge', 'New Westminster', 'Port Coquitlam'
  ];
  
  // Split by commas first - city is often comma-separated
  const parts = trimmed.split(',').map(p => p.trim()).filter(p => p);
  
  if (parts.length > 1) {
    // If there are commas, city is likely the last part before province/postal
    // But we already removed province/postal, so it's the last part
    const lastPart = parts[parts.length - 1];
    // Check if last part looks like a city (starts with capital, no numbers, reasonable length)
    if (/^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*$/.test(lastPart) && lastPart.length > 2 && lastPart.length < 50) {
      city = lastPart;
      parts.pop(); // Remove city from parts
      trimmed = parts.join(', ').trim();
    }
  }
  
  // If no city found yet, try to extract from end of string
  if (!city && trimmed) {
    // First, check for known multi-word cities (check from the end of the string)
    for (const knownCity of knownCities) {
      // Create regex that matches the city at the end of the string
      const escapedCity = knownCity.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const cityRegex = new RegExp('\\b' + escapedCity + '\\b\\s*$', 'i');
      const cityMatch = trimmed.match(cityRegex);
      if (cityMatch) {
        city = knownCity;
        // Remove city from the end of the string
        trimmed = trimmed.replace(cityRegex, '').trim();
        // Remove trailing commas
        trimmed = trimmed.replace(/,\s*$/, '').trim();
        break;
      }
    }
    
    // If still no city, check for known single-word cities at the end
    // This should happen BEFORE checking street suffixes to avoid conflicts
    // (e.g., "Trail" can be both a street suffix and a city name)
    // Also check if the last word is a known city, even if preceded by other words
    // (e.g., "Glen Invermere" -> extract "Invermere", keep "Glen" in address)
    if (!city && trimmed) {
      const words = trimmed.split(/\s+/);
      if (words.length > 0) {
        // Check last word first
        const lastWord = words[words.length - 1].replace(/[.,]/g, '');
        let matchingCity = commonSingleWordCities.find(cityName => 
          cityName.toLowerCase() === lastWord.toLowerCase()
        );
        
        // If last word is a known city, extract it (even if preceded by other words)
        if (matchingCity) {
          city = matchingCity;
          // Remove city from the end (only the city name, not preceding words)
          const escapedCity = city.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const cityPattern = new RegExp('\\b' + escapedCity + '\\b\\s*$', 'i');
          trimmed = trimmed.replace(cityPattern, '').trim();
          trimmed = trimmed.replace(/,\s*$/, '').trim();
        } else if (words.length >= 2) {
          // Check second-to-last word + last word combination
          // But only if the last word is a known city
          const secondLastWord = words[words.length - 2].replace(/[.,]/g, '');
          const twoWordCity = `${secondLastWord} ${lastWord}`;
          matchingCity = commonSingleWordCities.find(cityName => 
            cityName.toLowerCase() === twoWordCity.toLowerCase()
          );
          // Don't match two-word combinations - we want to extract just the city
          // So if last word is a known city, use it even if preceded by another word
        }
      }
    }
    
    // If still no city, work backwards from the end to find city name
    // Stop when we encounter a street suffix
    if (!city && trimmed) {
      const words = trimmed.split(/\s+/);
      let cityWords = [];
      let foundStreetSuffix = false;
      let streetSuffixIndex = -1;
      
      // First pass: find street suffix and check for known cities after it
      for (let i = words.length - 1; i >= 0; i--) {
        const word = words[i];
        const wordUpper = word.replace(/[.,]/g, ''); // Remove punctuation
        
        // Check if this word is a street suffix
        if (streetSuffixes.some(suffix => 
          wordUpper.toLowerCase() === suffix.toLowerCase() || 
          wordUpper.toLowerCase() === (suffix + '.').toLowerCase()
        )) {
          foundStreetSuffix = true;
          streetSuffixIndex = i;
          
          // Check if the word immediately after the street suffix is a known city
          if (i + 1 < words.length) {
            const wordAfterSuffix = words[i + 1].replace(/[.,]/g, '');
            const matchingCity = commonSingleWordCities.find(cityName => 
              cityName.toLowerCase() === wordAfterSuffix.toLowerCase()
            );
            if (matchingCity) {
              city = matchingCity;
              // Remove city from the end
              const escapedCity = city.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const cityPattern = new RegExp('\\b' + escapedCity + '\\b\\s*$', 'i');
              trimmed = trimmed.replace(cityPattern, '').trim();
              trimmed = trimmed.replace(/,\s*$/, '').trim();
              break;
            }
          }
          
          // If no city found immediately after suffix, collect words after suffix as potential city
          // But limit to 1-2 words max
          for (let j = i + 1; j < words.length && cityWords.length < 2; j++) {
            const word = words[j].replace(/[.,]/g, '');
            if (/^[A-Z][a-z]+$/.test(word)) {
              cityWords.push(word);
            } else {
              break;
            }
          }
          
          // If we collected city words, check if the last one is a known city
          if (cityWords.length > 0) {
            const lastCityWord = cityWords[cityWords.length - 1];
            const matchingCity = commonSingleWordCities.find(cityName => 
              cityName.toLowerCase() === lastCityWord.toLowerCase()
            );
            if (matchingCity) {
              // Use just the known city name (not the preceding words like "Glen" or "Terr")
              city = matchingCity;
              // Remove city from the end
              const escapedCity = city.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const cityPattern = new RegExp('\\b' + escapedCity + '\\b\\s*$', 'i');
              trimmed = trimmed.replace(cityPattern, '').trim();
              trimmed = trimmed.replace(/,\s*$/, '').trim();
              break;
            }
          }
          
          // If we found a street suffix but no city after it, everything from suffix onward is address
          // City words collected before the suffix (if any) would be the city
          // But in this case, we've already checked, so break
          break;
        }
      }
      
      // If we didn't find a street suffix, work backwards to find potential city
      if (!foundStreetSuffix && !city && trimmed) {
        const words = trimmed.split(/\s+/);
        let cityWords = [];
        
        // Work backwards from the end
        for (let i = words.length - 1; i >= 0; i--) {
          const word = words[i];
          const cleanWord = word.replace(/[.,]/g, '');
          
          // Check if this word is a known city
          const matchingCity = commonSingleWordCities.find(cityName => 
            cityName.toLowerCase() === cleanWord.toLowerCase()
          );
          if (matchingCity) {
            city = matchingCity;
            // Remove city from the end
            const escapedCity = city.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const cityPattern = new RegExp('\\b' + escapedCity + '\\b\\s*$', 'i');
            trimmed = trimmed.replace(cityPattern, '').trim();
            trimmed = trimmed.replace(/,\s*$/, '').trim();
            break;
          }
          
          // Check if word looks like part of a city name (capitalized, no numbers)
          if (/^[A-Z][a-z]+$/.test(cleanWord)) {
            cityWords.unshift(cleanWord);
          } else {
            // If we hit a non-city-like word and we have city words, stop
            if (cityWords.length > 0) {
              break;
            }
          }
        }
        
        // If we collected city words but didn't find a known city, check if last word is known
        if (!city && cityWords.length > 0) {
          const lastWord = cityWords[cityWords.length - 1];
          const matchingCity = commonSingleWordCities.find(cityName => 
            cityName.toLowerCase() === lastWord.toLowerCase()
          );
          if (matchingCity) {
            city = matchingCity;
            // Remove city from the end
            const escapedCity = city.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const cityPattern = new RegExp('\\b' + escapedCity + '\\b\\s*$', 'i');
            trimmed = trimmed.replace(cityPattern, '').trim();
            trimmed = trimmed.replace(/,\s*$/, '').trim();
          } else if (cityWords.length > 0) {
            // Fallback: use last 1-2 words as city (most Canadian cities are 1-2 words)
            const cityWordCount = Math.min(2, cityWords.length);
            city = cityWords.slice(-cityWordCount).join(' ');
            // Remove city from the end of trimmed string
            const escapedCity = city.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const cityPattern = new RegExp('\\b' + escapedCity + '\\b\\s*$', 'i');
            trimmed = trimmed.replace(cityPattern, '').trim();
            trimmed = trimmed.replace(/,\s*$/, '').trim();
          }
        }
      }
    }
  }
  
  // Step 4: Everything remaining is the street address
  let address = trimmed.trim();
  
  // Clean up address - remove any trailing commas or extra spaces
  address = address.replace(/,\s*$/, '').trim();
  
  // If address is empty but we have other components, the original might have been malformed
  // In that case, try to reconstruct
  if (!address && fullAddress) {
    // If we extracted components but address is empty, the whole thing might be the address
    // This handles cases where parsing failed
    address = fullAddress;
    // Try to remove known components
    if (postalCode) {
      address = address.replace(postalCode.replace(/\s/g, ''), '').replace(postalCode, '').trim();
    }
    if (province) {
      address = address.replace(new RegExp('\\b' + province + '\\b', 'gi'), '').trim();
      // Also try full province names
      for (const [key, value] of Object.entries(provinceMap)) {
        if (value === province) {
          address = address.replace(new RegExp('\\b' + key + '\\b', 'gi'), '').trim();
        }
      }
    }
    if (city) {
      address = address.replace(new RegExp('\\b' + city + '\\b', 'gi'), '').trim();
    }
    address = address.replace(/,\s*,/g, ',').replace(/,\s*$/, '').trim();
  }
  
  return { 
    address: address || '', 
    city: city || '', 
    province: province || '', 
    postalCode: postalCode || '' 
  };
};

const normalizePhone = (phone) => {
  if (!phone || typeof phone !== 'string') {
    return '';
  }
  
  // Remove all non-digits
  const digits = phone.replace(/\D/g, '');
  
  if (digits.length === 10) {
    return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
  } else if (digits.length === 11 && digits[0] === '1') {
    return `1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;
  }
  
  return phone.trim();
};

const normalizePostalCode = (postalCode) => {
  if (!postalCode || typeof postalCode !== 'string') {
    return '';
  }
  
  // Remove spaces and convert to uppercase
  let cleaned = postalCode.replace(/\s/g, '').toUpperCase();
  
  // Format Canadian postal code: A1A1A1 -> A1A 1A1
  if (cleaned.length === 6 && /^[A-Z]\d[A-Z]\d[A-Z]\d$/.test(cleaned)) {
    return cleaned.slice(0, 3) + ' ' + cleaned.slice(3);
  }
  
  return cleaned;
};

const normalizeProvince = (province) => {
  if (!province || typeof province !== 'string') {
    return '';
  }
  
  const provinceMap = {
    'ontario': 'ON', 'on': 'ON',
    'quebec': 'QC', 'qc': 'QC', 'quÃ©bec': 'QC',
    'british columbia': 'BC', 'bc': 'BC', 'b.c.': 'BC',
    'alberta': 'AB', 'ab': 'AB',
    'manitoba': 'MB', 'mb': 'MB',
    'saskatchewan': 'SK', 'sk': 'SK',
    'nova scotia': 'NS', 'ns': 'NS',
    'new brunswick': 'NB', 'nb': 'NB',
    'newfoundland': 'NL', 'nl': 'NL', 'newfoundland and labrador': 'NL',
    'prince edward island': 'PE', 'pe': 'PE', 'pei': 'PE',
    'northwest territories': 'NT', 'nt': 'NT',
    'nunavut': 'NU', 'nu': 'NU',
    'yukon': 'YT', 'yt': 'YT'
  };
  
  const normalized = province.trim().toLowerCase();
  return provinceMap[normalized] || province.trim().toUpperCase();
};

// Smart Import - Upload and Parse Excel File
const excelUpload = multer({
  storage: excelStorage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB limit for Excel files
  },
  fileFilter: (req, file, cb) => {
    const filetypes = /xlsx|xls|csv/;
    const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = filetypes.test(file.mimetype) || 
                     file.mimetype === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
                     file.mimetype === 'application/vnd.ms-excel' ||
                     file.mimetype === 'text/csv';
    
    if (!mimetype || !extname) {
      return cb(new Error('Only Excel files (.xlsx, .xls) and CSV files are allowed!'));
    }
    cb(null, true);
  }
});

app.post('/api/contacts/smart-import/parse', auth, (req, res, next) => {
  excelUpload.single('file')(req, res, (err) => {
    if (err) {
      console.error('File upload error:', err);
      return res.status(400).json({ error: err.message || 'File upload failed. Please ensure the file is a valid .xlsx, .xls, or .csv file and is under 10MB.' });
    }
    next();
  });
}, async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }
    
    const filePath = req.file.path;
    const ext = path.extname(req.file.originalname).toLowerCase();
    const data = [];
    const headers = [];
    
    // Handle Excel/CSV files
    if (ext === '.xlsx' || ext === '.xls' || ext === '.csv') {
      const workbook = new ExcelJS.Workbook();
      
      if (ext === '.csv') {
        await workbook.csv.readFile(filePath);
      } else {
        await workbook.xlsx.readFile(filePath);
      }
      
      // Get first worksheet
      const worksheet = workbook.worksheets[0];
      if (!worksheet) {
        return res.status(400).json({ error: 'Excel file has no worksheets' });
      }
      
      // Find the header row - look for row with header keywords
      const headerKeywords = ['name', 'address', 'email', 'phone', 'city', 'province', 'postal', 'category', 'barcode', 'res', 'number'];
      let headerRowNumber = 1;
      let maxHeaderScore = 0;
      
      // Check first 5 rows to find the best header row
      for (let rowNum = 1; rowNum <= Math.min(5, worksheet.rowCount); rowNum++) {
        const row = worksheet.getRow(rowNum);
        let headerScore = 0;
        let hasHeaderKeywords = false;
        
        row.eachCell({ includeEmpty: false }, (cell) => {
          const cellValue = String(cell.value || '').toLowerCase().trim();
          if (headerKeywords.some(keyword => cellValue.includes(keyword))) {
            headerScore++;
            hasHeaderKeywords = true;
          }
        });
        
        // Prefer rows with multiple header keywords
        if (hasHeaderKeywords && headerScore > maxHeaderScore) {
          maxHeaderScore = headerScore;
          headerRowNumber = rowNum;
        }
      }
      
      // Get headers from the detected header row
      const headerRow = worksheet.getRow(headerRowNumber);
      headerRow.eachCell({ includeEmpty: true }, (cell, colNumber) => {
        const header = cell.value ? String(cell.value).trim() : `Column${colNumber}`;
        headers.push(header);
      });
      
      // If no headers found, generate generic column names
      if (headers.length === 0 || headers.every(h => !h || h.startsWith('Column'))) {
        // Try to determine column count from first data row
        const firstDataRow = worksheet.getRow(headerRowNumber + 1);
        let maxCol = 0;
        firstDataRow.eachCell({ includeEmpty: false }, (cell, colNumber) => {
          maxCol = Math.max(maxCol, colNumber);
        });
        headers.length = 0;
        for (let i = 1; i <= Math.max(maxCol, 10); i++) {
          headers.push(`Column${i}`);
        }
      }
      
      // Convert rows to JSON objects, starting after header row
      // Track previous row to merge "Post.:" continuation rows
      let previousRowData = null;
      
      worksheet.eachRow({ includeEmpty: false }, (row, rowNumber) => {
        if (rowNumber <= headerRowNumber) return; // Skip header row(s)
        
        const rowData = {};
        row.eachCell({ includeEmpty: true }, (cell, colNumber) => {
          const header = headers[colNumber - 1];
          if (header) {
            // Get cell value, handling different types
            let value = '';
            if (cell.value !== null && cell.value !== undefined) {
              if (cell.value instanceof Date) {
                // Format dates as YYYY-MM-DD - but mark them so we can detect them later
                value = cell.value.toISOString().split('T')[0];
              } else if (typeof cell.value === 'object' && cell.value.text) {
                value = cell.value.text; // Handle rich text
              } else {
                value = String(cell.value);
              }
            }
            // Store the value - keep dates as date strings for detection
            rowData[header] = value.trim();
          }
        });
        
        // Only process row if it has at least one non-empty value
        if (Object.values(rowData).some(val => val && val.trim() !== '')) {
          const rowString = Object.values(rowData).join(' ').toLowerCase();
          const rowValues = Object.values(rowData).map(v => String(v || '').trim()).filter(v => v);
          
          // Check if this is a "Post.:" continuation row that should be merged with previous
          const isPostContinuation = rowValues.some(v => /^post\.:/i.test(v)) && 
                                     (!rowValues.some(v => /^[A-Z][a-z]+,\s+[A-Z]/i.test(v))); // No name pattern
          
          if (isPostContinuation && previousRowData) {
            // Merge "Post.:" address with previous row's address field
            // Find the address column and append the postal address
            for (const [header, value] of Object.entries(rowData)) {
              if (value && /^post\.:/i.test(value)) {
                // Find address-related column in previous row
                const addressHeaders = ['address', 'addresses', 'fulladdress', 'residential', 'postal'];
                let merged = false;
                for (const addrHeader of addressHeaders) {
                  const matchingHeader = Object.keys(previousRowData).find(h => 
                    h.toLowerCase().includes(addrHeader));
                  if (matchingHeader) {
                    const existingAddr = previousRowData[matchingHeader] || '';
                    previousRowData[matchingHeader] = existingAddr ? 
                      `${existingAddr}\n${value}` : value;
                    merged = true;
                    break;
                  }
                }
                // If no address column found, use the first column that has data
                if (!merged) {
                  const firstDataCol = Object.keys(previousRowData).find(h => 
                    previousRowData[h] && previousRowData[h].trim());
                  if (firstDataCol) {
                    previousRowData[firstDataCol] = `${previousRowData[firstDataCol]}\n${value}`;
                  }
                }
              }
            }
            // Update the last row in data array with merged address
            if (data.length > 0) {
              data[data.length - 1] = { ...previousRowData };
            }
            // Don't add this row as a separate contact, it's merged
            return;
          }
          
          // USER REQUEST: Don't skip any rows - all rows contain data in the Excel sheet
          // Process all rows that have data - let the finalize endpoint handle filtering
          // Save this as the previous row for potential merging
          previousRowData = { ...rowData };
          data.push(rowData);
        }
      });
    } else {
      return res.status(400).json({ error: 'Unsupported file type. Please upload an Excel (.xlsx, .xls) or CSV file.' });
    }
    
    if (data.length === 0) {
      return res.status(400).json({ error: 'File is empty or has no data rows' });
    }
    
    // Get sample values for each column (first 10 non-empty rows for better detection)
    const columnSamples = {};
    headers.forEach(header => {
      columnSamples[header] = data
        .slice(0, 10)
        .map(row => {
          const val = row[header];
          if (val === null || val === undefined) return null;
          // Convert dates to strings, ensure we get the actual value
          if (val instanceof Date) {
            return val.toISOString().split('T')[0]; // YYYY-MM-DD format
          }
          return String(val).trim();
        })
        .filter(val => val && val !== '')
        .slice(0, 5);
    });
    
    // Auto-detect column types
    const columnMapping = {};
    const detectedFields = new Set();
    
    headers.forEach(header => {
      const detectedType = detectColumnType(header, columnSamples[header]);
      if (detectedType) {
        columnMapping[header] = detectedType;
        detectedFields.add(detectedType);
      }
    });
    
    // CRITICAL: Always check for "Name" column and map it to fullName if not already mapped
    // This ensures names are always extracted, even if detectColumnType missed it
    // USER REQUEST: All rows contain data, so always map "Name" column to fullName
    headers.forEach(header => {
      const headerLower = header.toLowerCase().trim();
      const headerNormalized = headerLower.replace(/[_\s-]/g, '');
      
      // If header is "Name" (exact match or normalized), ALWAYS map to fullName
      // Don't check samples - just map it. The backend will handle parsing.
      if ((headerLower === 'name' || headerNormalized === 'name') && !columnMapping[header]) {
        columnMapping[header] = 'fullName';
        detectedFields.add('fullName');
      }
    });
    
    // Post-process: Fix common mis-detections
    // If a column was mapped to 'phone' but contains dates, unmap it
    headers.forEach(header => {
      if (columnMapping[header] === 'phone') {
        const samples = columnSamples[header] || [];
        if (samples.length > 0) {
          const firstSample = String(samples[0] || '').trim();
          const datePattern = /^\d{4}-\d{2}-\d{2}$/;
          if (datePattern.test(firstSample)) {
            // This is dates, not phone - remove the mapping
            delete columnMapping[header];
            detectedFields.delete('phone');
          }
        }
      }
      
      // If Email column exists but wasn't detected, try harder
      const headerLower = header.toLowerCase().trim();
      if (headerLower.includes('email') && !columnMapping[header]) {
        const samples = columnSamples[header] || [];
        const sampleStr = samples.join(' ').toLowerCase();
        if (/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/.test(sampleStr)) {
          columnMapping[header] = 'email';
          detectedFields.add('email');
        }
      }
    });
    
    // For PDFs, improve column detection by analyzing data patterns
    if (ext === '.pdf') {
      headers.forEach(header => {
        const headerLower = header.toLowerCase().trim();
        const samples = columnSamples[header] || [];
        
        // If header contains "name" and samples look like names, map to fullName (will be split to firstName/lastName)
        if ((headerLower === 'name' || headerLower.includes('name')) && 
            !columnMapping[header] && 
            samples.length > 0) {
          const sampleStr = samples.join(' ').toLowerCase();
          const firstSample = String(samples[0] || '');
          // Check if samples look like names (contain commas like "Last, First", capitalized words, no @, no long numbers)
          // Also check for patterns like "Benesch, Walter Edward" or "Walter Edward Benesch"
          if ((sampleStr.includes(',') || /^[A-Z][a-z]+/.test(firstSample)) && 
              !sampleStr.includes('@') && !/\d{4,}/.test(sampleStr) &&
              !sampleStr.includes('poll') && !sampleStr.includes('address') &&
              !/^\d+/.test(firstSample.trim())) {
            columnMapping[header] = 'fullName';
            detectedFields.add('fullName');
          }
        }
        
        // If header contains "address" and samples contain address-like text, map to address
        if ((headerLower.includes('address') || headerLower.includes('addresses')) && 
            !columnMapping[header] && 
            samples.length > 0) {
          const sampleStr = samples.join(' ').toLowerCase();
          if (sampleStr.includes('res.:') || sampleStr.includes('post.:') || 
              sampleStr.includes('road') || sampleStr.includes('street') || 
              sampleStr.includes('box') || sampleStr.includes('ave')) {
            columnMapping[header] = 'address';
            detectedFields.add('address');
          }
        }
        
        // If header contains "res" and "number" and samples look like phone numbers
        if ((headerLower.includes('res') && headerLower.includes('number')) && 
            !columnMapping[header] && 
            samples.length > 0) {
          const sampleStr = samples.join(' ');
          if (/\(?\d{3}\)?\s*\d{3}[-.]?\d{4}/.test(sampleStr)) {
            columnMapping[header] = 'phone';
            detectedFields.add('phone');
          }
        }
      });
    }
    
    // Clean up uploaded file after parsing
    try {
      await fsPromises.unlink(filePath);
    } catch (err) {
      console.error('Error deleting temp file:', err);
    }
    
    res.json({
      success: true,
      headers,
      columnMapping,
      detectedFields: Array.from(detectedFields),
      sampleData: data.slice(0, 10), // First 10 rows for preview display
      fileData: data, // Full file data for processing
      totalRows: data.length
    });
  } catch (error) {
    console.error('Smart import parse error:', error);
    console.error('Error stack:', error.stack);
    // Clean up uploaded file if it exists
    if (req.file && req.file.path) {
      try {
        await fsPromises.unlink(req.file.path);
      } catch (unlinkError) {
        console.error('Error deleting temp file:', unlinkError);
      }
    }
    res.status(400).json({ 
      error: error.message || 'Failed to parse file',
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

// Smart Import - Preview with Mapping
app.post('/api/contacts/smart-import/preview', auth, async (req, res) => {
  try {
    const { fileData, columnMapping } = req.body;
    
    if (!fileData || !Array.isArray(fileData) || fileData.length === 0) {
      return res.status(400).json({ error: 'Invalid file data' });
    }
    
    if (!columnMapping || typeof columnMapping !== 'object') {
      return res.status(400).json({ error: 'Invalid column mapping' });
    }
    
    const user = await findUserById(req.user.id);
    const accountId = getEffectiveAccountId(user);
    const isSpecial = await isSpecialContactStructure(accountId);
    
    // Helper function to clean "Res.:" and "Post.:" prefixes from address
    const cleanAddressPrefix = (address) => {
      if (!address || typeof address !== 'string') return address;
      // Remove "Res.:" and "Post.:" prefixes (case-insensitive, with optional spaces)
      return address
        .replace(/^Res\.:\s*/i, '')
        .replace(/^Post\.:\s*/i, '')
        .replace(/^Res\.\s+Add\.?:\s*/i, '')
        .replace(/^Mailing\s+Add\.?:\s*/i, '')
        .trim();
    };
    
    const previewContacts = [];
    const errors = [];
    
    for (let i = 0; i < Math.min(fileData.length, 20); i++) {
      const row = fileData[i];
      const contact = isSpecial ? {
        name: '',
        riding: '',
        province: '',
        email: '',
        role: '',
        phone: '',
        categories: [],
        pollNumber: ''
      } : {
        firstName: '',
        lastName: '',
        email: '',
        phone: '',
        address: '',
        city: '',
        province: '',
        postalCode: '',
        categories: [],
        pollNumber: ''
      };
      
      try {
        // First, check if this row should be skipped (not a contact)
        const rowValues = Object.values(row).map(v => String(v || '').trim()).filter(v => v);
        
        // Skip completely empty rows (no data at all)
        if (rowValues.length === 0) {
          continue; // Skip this row entirely
        }
        
        const rowString = rowValues.join(' ').toLowerCase();
        
        // Check for actual contact data (email, phone, name patterns) before skipping
        const hasEmail = rowValues.some(v => /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/.test(v));
        const hasPhone = rowValues.some(v => /\(?\d{3}\)?\s*\d{3}[-.]?\d{4}/.test(v));
        // Name pattern: "First Last", "Last, First", or "Last, First Middle" format
        const hasNamePattern = rowValues.some(v => 
          /^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+/.test(v) ||  // "First Last" or "First Middle Last"
          /^[A-Z][a-z]+,\s+[A-Z]/.test(v)  // "Last, First" format
        );
        
        // Skip rows with no contact data at all (completely empty or just whitespace/dashes)
        const hasAnyData = hasEmail || hasPhone || hasNamePattern || 
                          rowValues.some(v => v && v !== '-' && v !== 'N/A' && v.length > 1);
        if (!hasAnyData) {
          continue; // Skip completely empty rows
        }
        
        // Skip rows that are clearly not contact data
        // Be more lenient - only skip if we have NO contact data AND it matches skip patterns
        const isPollRow = !hasEmail && !hasPhone && !hasNamePattern && (rowString.includes('poll') || /^poll\s+\d+/i.test(rowString));
        const isPostOnlyRow = !hasEmail && !hasPhone && !hasNamePattern && (/^post\.:\s*/i.test(rowString) || (rowValues.length === 1 && rowValues.some(v => /^post\.:\s*/i.test(v))));
        const isNumberOnlyRow = !hasEmail && !hasPhone && !hasNamePattern && (/^\d+\s+[a-z]+$/i.test(rowString.trim()) || /^\d+$/i.test(rowString.trim()));
        
        // Check if first value is a location identifier (number + single word like "48031 Parkland")
        const firstValue = rowValues[0] || '';
        const isLocationIdentifier = !hasEmail && !hasPhone && !hasNamePattern && /^\d+\s+[A-Z][a-z]+$/.test(firstValue) && rowValues.length <= 2;
        
        // Check if row is mostly just a postal address continuation
        const isAddressContinuation = !hasEmail && !hasPhone && !hasNamePattern && rowValues.length <= 2 && 
          (rowValues.some(v => /^post\.:/i.test(v)) || 
           rowValues.some(v => /^[A-Z]\d[A-Z]\s?\d[A-Z]\d\s*"?$/.test(v)) ||
           (rowValues.length === 1 && /^[A-Z]\d[A-Z]\s?\d[A-Z]\d/.test(firstValue)));
        
        // Check if row looks like a header row (contains header keywords but no actual data)
        const headerKeywords = ['expiry', 'date', 'start date', 'end date', 'selection', 'criteria', 'report', 'membership'];
        const isHeaderRow = !hasEmail && !hasPhone && !hasNamePattern && headerKeywords.some(keyword => rowString.includes(keyword)) && 
                           rowValues.length <= 3;
        
        // USER REQUEST: Don't skip rows - all rows contain data in the Excel sheet
        // Process all rows and let name extraction handle parsing
        // Only skip completely empty rows (handled by hasContactData check later)
        
        // First, check if row already has extracted fields from frontend transformations
        // (e.g., from CPC format parsing - these take priority)
        if (row.email && typeof row.email === 'string' && row.email.trim() && 
            /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/.test(row.email)) {
          contact.email = row.email.trim().toLowerCase();
        }
        if (row.phone && typeof row.phone === 'string' && row.phone.trim()) {
          const phoneDigits = row.phone.replace(/\D/g, '');
          if (phoneDigits.length >= 10 && phoneDigits.length <= 11) {
            contact.phone = normalizePhone(row.phone);
          }
        }
        if (row.firstName && typeof row.firstName === 'string' && row.firstName.trim()) {
          contact.firstName = row.firstName.trim();
        }
        if (row.lastName && typeof row.lastName === 'string' && row.lastName.trim()) {
          contact.lastName = row.lastName.trim();
        }
        if (row.address && typeof row.address === 'string' && row.address.trim()) {
          contact.address = row.address.trim();
        }
        if (row.city && typeof row.city === 'string' && row.city.trim()) {
          contact.city = row.city.trim();
        }
        if (row.province && typeof row.province === 'string' && row.province.trim()) {
          contact.province = normalizeProvince(row.province);
        }
        if (row.postalCode && typeof row.postalCode === 'string' && row.postalCode.trim()) {
          contact.postalCode = normalizePostalCode(row.postalCode);
        }
        if (row.categories && Array.isArray(row.categories)) {
          contact.categories = row.categories.filter(c => c && c.trim());
        }
        
        // BEFORE column mapping, extract email/phone/address from ALL columns
        // This handles CPC format "Member Information" style columns
        // Check ALL columns because column mapping might be incorrect
        for (const [sourceColumn, value] of Object.entries(row)) {
          // Convert value to string for processing (handle all types, not just strings)
          let stringValue = '';
          if (value === null || value === undefined) continue;
          if (typeof value === 'string') {
            stringValue = value.trim();
          } else if (typeof value === 'number' || typeof value === 'boolean') {
            stringValue = String(value).trim();
          } else if (Array.isArray(value)) {
            stringValue = value.map(v => String(v || '')).join(' ').trim();
          } else if (typeof value === 'object') {
            // For objects, try to extract meaningful string representation
            stringValue = JSON.stringify(value).trim();
          } else {
            stringValue = String(value).trim();
          }
          
          if (!stringValue || stringValue === '-' || stringValue === 'N/A' || stringValue === 'null' || stringValue === 'undefined') continue;
          const normalized = stringValue.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
          
          // Extract email if missing
          if (!contact.email) {
            const emailMatch = normalized.match(/(?:E-mail\s+Address|Email|e-mail)[:\s]+([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,})/i);
            if (emailMatch && emailMatch[1]) {
              contact.email = emailMatch[1].trim().toLowerCase();
            } else {
              const simpleEmailMatch = normalized.match(/\b([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,})\b/);
              if (simpleEmailMatch && simpleEmailMatch[1]) {
                contact.email = simpleEmailMatch[1].trim().toLowerCase();
              }
            }
          }
          
          // Extract phone if missing
          if (!contact.phone) {
            const phoneMatches = normalized.match(/(?:Home\s+)?(?:Cell\s+)?(?:Phone|Fax)[:\s]+(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/gi);
            if (phoneMatches && phoneMatches.length > 0) {
              const phoneMatch = phoneMatches[0].match(/(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/);
              if (phoneMatch && phoneMatch[1]) {
                const phoneDigits = phoneMatch[1].replace(/\D/g, '');
                if (phoneDigits.length >= 10 && phoneDigits.length <= 11) {
                  contact.phone = normalizePhone(phoneMatch[1]);
                }
              }
            } else {
              const simplePhoneMatch = normalized.match(/(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/);
              if (simplePhoneMatch && simplePhoneMatch[1]) {
                const phoneDigits = simplePhoneMatch[1].replace(/\D/g, '');
                if (phoneDigits.length >= 10 && phoneDigits.length <= 11) {
                  contact.phone = normalizePhone(simplePhoneMatch[1]);
                }
              }
            }
          }
          
          // Extract address if missing
          if (!contact.address) {
            const addressMatch = normalized.match(/(?:Res\.\s+Add|Address|Res\.\s+Address)[:\s]+(.+?)(?:\n|$)/i);
            if (addressMatch && addressMatch[1]) {
              let addressLine = addressMatch[1].trim();
              const parsed = parseAddress(addressLine);
              if (parsed.address) {
                contact.address = parsed.address;
                if (!contact.city && parsed.city) contact.city = parsed.city;
                if (!contact.province && parsed.province) contact.province = parsed.province;
                if (!contact.postalCode && parsed.postalCode) contact.postalCode = parsed.postalCode;
              } else {
                contact.address = addressLine;
              }
            }
          }
        }
        
        // Map columns - process in order: fullAddress first, then individual fields
        // This allows fullAddress to populate empty individual fields
        // Only map if the field is still empty (extracted fields take priority)
        
        // First pass: collect all mapped values
        const mappedValues = {};
        for (const [sourceColumn, targetField] of Object.entries(columnMapping)) {
          if (!targetField || targetField === 'unmapped') continue;
          
          const value = row[sourceColumn];
          if (!value || (typeof value === 'string' && value.trim() === '')) continue;
          
          const stringValue = String(value).trim();
          
          // Skip if value is just a dash (common placeholder for empty)
          if (stringValue === '-' || stringValue === 'N/A' || stringValue === 'n/a') continue;
          
          if (!mappedValues[targetField]) {
            mappedValues[targetField] = [];
          }
          mappedValues[targetField].push({ column: sourceColumn, value: stringValue });
        }
        
        // Process fullAddress first if present
        if (mappedValues['fullAddress'] && mappedValues['fullAddress'].length > 0) {
          const fullAddressValue = mappedValues['fullAddress'][0].value;
          const parsed = parseAddress(fullAddressValue);
          
          // Only use parsed values if the individual fields are empty
          if (parsed.address && !contact.address) contact.address = parsed.address;
          if (parsed.city && !contact.city) contact.city = parsed.city;
          if (parsed.province && !contact.province) contact.province = parsed.province;
          if (parsed.postalCode && !contact.postalCode) contact.postalCode = parsed.postalCode;
        }
        
        // Process individual fields (they override fullAddress parsing if present)
        // But only if the field is still empty (extracted fields take priority)
        for (const [targetField, entries] of Object.entries(mappedValues)) {
          if (targetField === 'fullAddress') continue; // Already processed
          
          const stringValue = entries[0].value;
          
          if (isSpecial) {
            // Special EDA structure fields
            if (targetField === 'name' && !contact.name) {
              contact.name = stringValue;
            } else if (targetField === 'riding' && !contact.riding) {
              contact.riding = stringValue;
            } else if (targetField === 'role' && !contact.role) {
              contact.role = stringValue;
            } else if (targetField === 'province' && !contact.province) {
              contact.province = stringValue;
            } else if (targetField === 'phone' && !contact.phone) {
              contact.phone = normalizePhone(stringValue);
            } else if (targetField === 'email' && !contact.email) {
              contact.email = stringValue.toLowerCase();
            } else if (targetField === 'category') {
              // Handle multiple categories (comma-separated)
              const categories = stringValue.split(',').map(c => c.trim()).filter(c => c);
              if (categories.length > 0) {
                // Merge with existing categories
                contact.categories = [...new Set([...contact.categories, ...categories])];
              }
            } else if (targetField in contact && typeof contact[targetField] === 'string' && !contact[targetField]) {
              contact[targetField] = stringValue;
            }
          } else {
            // Standard structure fields
            if (targetField === 'fullName') {
              const { firstName, lastName } = splitFullName(stringValue);
              if (firstName && !contact.firstName) contact.firstName = firstName;
              if (lastName && !contact.lastName) contact.lastName = lastName;
            } else if (targetField === 'firstName' && !contact.firstName) {
              contact.firstName = stringValue;
            } else if (targetField === 'lastName' && !contact.lastName) {
              contact.lastName = stringValue;
            } else if (targetField === 'address' && !contact.address) {
              contact.address = stringValue;
            } else if (targetField === 'city' && !contact.city) {
              contact.city = stringValue;
            } else if (targetField === 'province' && !contact.province) {
              contact.province = normalizeProvince(stringValue);
            } else if (targetField === 'postalCode' && !contact.postalCode) {
              contact.postalCode = normalizePostalCode(stringValue);
            } else if (targetField === 'phone' && !contact.phone) {
              contact.phone = normalizePhone(stringValue);
            } else if (targetField === 'category') {
              // Handle multiple categories (comma-separated)
              const categories = stringValue.split(',').map(c => c.trim()).filter(c => c);
              if (categories.length > 0) {
                // Merge with existing categories
                contact.categories = [...new Set([...contact.categories, ...categories])];
              }
            } else if (targetField === 'pollNumber' || targetField === 'poll #' || targetField === 'poll') {
              contact.pollNumber = stringValue;
            } else if (targetField === 'email' && !contact.email) {
              contact.email = stringValue.toLowerCase();
            } else if (targetField in contact && typeof contact[targetField] === 'string' && !contact[targetField]) {
              contact[targetField] = stringValue;
            }
          }
        }
        
        // Always parse address field to extract and remove city/province/postalCode
        // This ensures the address field only contains street address (or PO Box)
        if (contact.address && contact.address.trim()) {
          try {
            const parsed = parseAddress(contact.address);
            // Always update address to use parsed address (which has city/province/postalCode removed)
            if (parsed.address) {
              contact.address = parsed.address;
            }
            // Fill in missing fields from parsed data
            if (!contact.city && parsed.city) contact.city = parsed.city;
            if (!contact.province && parsed.province) contact.province = parsed.province;
            if (!contact.postalCode && parsed.postalCode) contact.postalCode = parsed.postalCode;
          } catch (parseError) {
            // If address parsing fails, just keep the original address
          }
        }
        
        // If still no names, try to find them in unmapped columns or ALL columns
        if (!contact.firstName && !contact.lastName) {
          // First, scan all unmapped columns
          for (const [sourceColumn, targetField] of Object.entries(columnMapping)) {
            if (targetField && targetField !== 'unmapped') continue; // Skip mapped columns
            
            const value = row[sourceColumn];
            if (!value || typeof value !== 'string') continue;
            
            const stringValue = String(value).trim();
            if (!stringValue || stringValue === '-' || stringValue === 'N/A' || stringValue.length < 2) continue;
            
            // Skip if it looks like a poll/location header or address
            if (/^(Poll\s+\d+|^\d+$|^Post\.:|^Res\.:)/i.test(stringValue)) {
              continue;
            }
            
            // Check if it looks like a name (capitalized words, reasonable length)
            // More flexible pattern - allows for hyphens, apostrophes, commas, etc.
            const namePattern = /^[A-Z][a-z]+(?:['-][A-Z][a-z]+)?(?:\s*,\s*[A-Z][a-z]+)?(?:\s+[A-Z][a-z]+(?:['-][A-Z][a-z]+)?){0,2}$/;
            // Also check if it's mostly letters (at least 70% letters, no @, no long number sequences)
            const isMostlyLetters = /^[A-Za-z\s',-]+$/.test(stringValue) && 
                                   stringValue.replace(/[^A-Za-z]/g, '').length >= stringValue.length * 0.7 &&
                                   !stringValue.includes('@') && 
                                   !/\d{4,}/.test(stringValue) &&
                                   !stringValue.toLowerCase().includes('box') &&
                                   !stringValue.toLowerCase().includes('po ') &&
                                   !stringValue.toLowerCase().includes('range road') &&
                                   !stringValue.toLowerCase().includes('township') &&
                                   !stringValue.toLowerCase().includes('poll') &&
                                   !stringValue.toLowerCase().includes('community') &&
                                   !stringValue.toLowerCase().includes('association');
            
            if ((namePattern.test(stringValue) || isMostlyLetters) && stringValue.length < 60) {
              // This looks like a name - try to split it
              const { firstName, lastName } = splitFullName(stringValue);
              if (firstName || lastName) {
                if (!contact.firstName) contact.firstName = firstName;
                if (!contact.lastName) contact.lastName = lastName;
                break; // Found a name, stop searching
              }
            }
          }
          
          // If still no name found, scan ALL columns (including mapped ones that might have names)
          if (!contact.firstName && !contact.lastName) {
            for (const [sourceColumn, value] of Object.entries(row)) {
              if (!value || typeof value !== 'string') continue;
              
              const stringValue = String(value).trim();
              if (!stringValue || stringValue === '-' || stringValue === 'N/A' || stringValue.length < 2) continue;
              
              // Skip if this column is already mapped to something else (unless it's unmapped)
              const mappedField = columnMapping[sourceColumn];
              if (mappedField && mappedField !== 'unmapped' && 
                  mappedField !== 'fullName' && mappedField !== 'firstName' && mappedField !== 'lastName') {
                continue;
              }
              
              // Skip if it looks like a poll/location header or address
              if (/^(Poll\s+\d+|^\d+$|^Post\.:|^Res\.:)/i.test(stringValue)) {
                continue;
              }
              
              // Check if it looks like a name
              const namePattern2 = /^[A-Z][a-z]+(?:['-][A-Z][a-z]+)?(?:\s*,\s*[A-Z][a-z]+)?(?:\s+[A-Z][a-z]+(?:['-][A-Z][a-z]+)?){0,2}$/;
              const isMostlyLetters2 = /^[A-Za-z\s',-]+$/.test(stringValue) && 
                                     stringValue.replace(/[^A-Za-z]/g, '').length >= stringValue.length * 0.7 &&
                                     !stringValue.includes('@') && 
                                     !/\d{4,}/.test(stringValue) &&
                                     !stringValue.toLowerCase().includes('box') &&
                                     !stringValue.toLowerCase().includes('po ') &&
                                     !stringValue.toLowerCase().includes('range road') &&
                                     !stringValue.toLowerCase().includes('township') &&
                                     !stringValue.toLowerCase().includes('poll') &&
                                     !stringValue.toLowerCase().includes('community') &&
                                     !stringValue.toLowerCase().includes('association');
              
              if ((namePattern2.test(stringValue) || isMostlyLetters2) && stringValue.length < 60) {
                const { firstName, lastName } = splitFullName(stringValue);
                if (firstName || lastName) {
                  if (!contact.firstName) contact.firstName = firstName;
                  if (!contact.lastName) contact.lastName = lastName;
                  break; // Found a name, stop searching
                }
              }
            }
          }
        }
        
        // Additional validation: skip rows that are clearly not contacts
        if (isSpecial) {
          // Special structure validation
          const allContactData = [
            contact.name, contact.riding, contact.province, contact.email, contact.role, contact.phone
          ].join(' ').toLowerCase();
          
          // Validate required fields for special structure
          if (!contact.name || !contact.name.trim()) {
            // Check if we have any identifying information
            if (contact.phone || contact.email) {
              // Use placeholder name - user can edit later
              contact.name = contact.phone ? `Contact (${contact.phone.replace(/\D/g, '').slice(-4)})` : 
                            contact.email ? contact.email.split('@')[0] : 
                            `Row ${i + 2}`;
            } else {
              // No identifying info at all - skip this row
              throw new Error('Missing required name field and no other identifying information');
            }
          }
        } else {
          // Standard structure validation
          // Check if this looks like a "Post.:" continuation row or other non-contact data
          const allContactData = [
            contact.firstName, contact.lastName, contact.email, contact.phone,
            contact.address, contact.city, contact.province, contact.postalCode
          ].join(' ').toLowerCase();
          
          // Skip if it's just a "Post.:" address line or similar continuation
          if ((!contact.firstName && !contact.lastName) && 
              (allContactData.includes('post.:') || allContactData.match(/^post\.:\s*/i))) {
            throw new Error('Postal address continuation row (not a contact)');
          }
          
          // Skip if it's just a number or number + single word (like "48031 Parkland")
          if ((!contact.firstName && !contact.lastName) && 
              (!contact.email && !contact.phone) &&
              (/^\d+\s+[a-z]+$/i.test(allContactData.trim()) || /^\d+$/i.test(allContactData.trim()))) {
            throw new Error('Location identifier row (not a contact)');
          }
          
          // Validate required fields - make names optional if we have other identifying info
          // If no name but we have address/phone/email, use placeholder
          if (!contact.firstName && !contact.lastName) {
            // Check if we have any identifying information
            if (contact.address || contact.phone || contact.email) {
              // Use placeholder names - user can edit later
              contact.firstName = 'Contact';
              contact.lastName = contact.phone ? `(${contact.phone.replace(/\D/g, '').slice(-4)})` : 
                                contact.email ? contact.email.split('@')[0] : 
                                `Row ${i + 2}`;
            } else {
              // No identifying info at all - skip this row
              throw new Error('Missing required name fields and no other identifying information');
            }
          }
        }
        
        // Clean address prefix before adding to preview
        if (contact.address) {
          contact.address = cleanAddressPrefix(contact.address);
        }
        
        previewContacts.push(contact);
      } catch (error) {
        errors.push({ row: i + 2, message: error.message, data: row });
      }
    }
    
    res.json({
      success: true,
      preview: previewContacts,
      errors,
      totalRows: fileData.length
    });
  } catch (error) {
    console.error('Smart import preview error:', error);
    res.status(400).json({ error: error.message || 'Failed to generate preview' });
  }
});

// Smart Import - Final Import
app.post('/api/contacts/smart-import/finalize', auth, async (req, res) => {
  try {
    const { fileData, columnMapping, bulkCategory } = req.body;
    
    if (!fileData || !Array.isArray(fileData) || fileData.length === 0) {
      return res.status(400).json({ error: 'Invalid file data' });
    }
    
    if (!columnMapping || typeof columnMapping !== 'object') {
      return res.status(400).json({ error: 'Invalid column mapping' });
    }
    
    const user = await findUserById(req.user.id);
    const accountId = getEffectiveAccountId(user);
    const isSpecial = await isSpecialContactStructure(accountId);
    
    const contacts = [];
    const errors = [];
    
    for (let i = 0; i < fileData.length; i++) {
      const row = fileData[i];
      const contact = isSpecial ? {
        name: '',
        riding: '',
        province: '',
        email: '',
        role: '',
        phone: '',
        categories: [],
        pollNumber: ''
      } : {
        firstName: '',
        lastName: '',
        email: '',
        phone: '',
        address: '',
        city: '',
        province: '',
        postalCode: '',
        categories: [],
        pollNumber: ''
      };
      
      try {
        // First, check if this row should be skipped (not a contact)
        const rowValues = Object.values(row).map(v => String(v || '').trim()).filter(v => v);
        
        // Skip completely empty rows (no data at all)
        if (rowValues.length === 0) {
          continue; // Skip this row entirely
        }
        
        const rowString = rowValues.join(' ').toLowerCase();
        
        // Check for actual contact data (email, phone, name patterns) before skipping
        const hasEmail = rowValues.some(v => /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/.test(v));
        const hasPhone = rowValues.some(v => /\(?\d{3}\)?\s*\d{3}[-.]?\d{4}/.test(v));
        // Name pattern: "First Last", "Last, First", or "Last, First Middle" format
        const hasNamePattern = rowValues.some(v => 
          /^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+/.test(v) ||  // "First Last" or "First Middle Last"
          /^[A-Z][a-z]+,\s+[A-Z]/.test(v)  // "Last, First" format
        );
        
        // Skip rows with no contact data at all (completely empty or just whitespace/dashes)
        const hasAnyData = hasEmail || hasPhone || hasNamePattern || 
                          rowValues.some(v => v && v !== '-' && v !== 'N/A' && v.length > 1);
        if (!hasAnyData) {
          continue; // Skip completely empty rows
        }
        
        // Skip rows that are clearly not contact data
        // Be more lenient - only skip if we have NO contact data AND it matches skip patterns
        const isPollRow = !hasEmail && !hasPhone && !hasNamePattern && (rowString.includes('poll') || /^poll\s+\d+/i.test(rowString));
        const isPostOnlyRow = !hasEmail && !hasPhone && !hasNamePattern && (/^post\.:\s*/i.test(rowString) || (rowValues.length === 1 && rowValues.some(v => /^post\.:\s*/i.test(v))));
        const isNumberOnlyRow = !hasEmail && !hasPhone && !hasNamePattern && (/^\d+\s+[a-z]+$/i.test(rowString.trim()) || /^\d+$/i.test(rowString.trim()));
        
        // Check if first value is a location identifier (number + single word like "48031 Parkland")
        const firstValue = rowValues[0] || '';
        const isLocationIdentifier = !hasEmail && !hasPhone && !hasNamePattern && /^\d+\s+[A-Z][a-z]+$/.test(firstValue) && rowValues.length <= 2;
        
        // Check if row is mostly just a postal address continuation
        const isAddressContinuation = !hasEmail && !hasPhone && !hasNamePattern && rowValues.length <= 2 && 
          (rowValues.some(v => /^post\.:/i.test(v)) || 
           rowValues.some(v => /^[A-Z]\d[A-Z]\s?\d[A-Z]\d\s*"?$/.test(v)) ||
           (rowValues.length === 1 && /^[A-Z]\d[A-Z]\s?\d[A-Z]\d/.test(firstValue)));
        
        // Check if row looks like a header row (contains header keywords but no actual data)
        const headerKeywords = ['expiry', 'date', 'start date', 'end date', 'selection', 'criteria', 'report', 'membership'];
        const isHeaderRow = !hasEmail && !hasPhone && !hasNamePattern && headerKeywords.some(keyword => rowString.includes(keyword)) && 
                           rowValues.length <= 3;
        
        // USER REQUEST: Don't skip rows - all rows contain data in the Excel sheet
        // Process all rows and let name extraction handle parsing
        // Only skip completely empty rows (handled by hasContactData check later)
        
        // First, check if row already has extracted fields from frontend transformations
        // (e.g., from CPC format parsing - these take priority)
        if (row.email && typeof row.email === 'string' && row.email.trim() && 
            /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/.test(row.email)) {
          contact.email = row.email.trim().toLowerCase();
        }
        if (row.phone && typeof row.phone === 'string' && row.phone.trim()) {
          const phoneDigits = row.phone.replace(/\D/g, '');
          if (phoneDigits.length >= 10 && phoneDigits.length <= 11) {
            contact.phone = normalizePhone(row.phone);
          }
        }
        if (row.firstName && typeof row.firstName === 'string' && row.firstName.trim()) {
          contact.firstName = row.firstName.trim();
        }
        if (row.lastName && typeof row.lastName === 'string' && row.lastName.trim()) {
          contact.lastName = row.lastName.trim();
        }
        if (row.address && typeof row.address === 'string' && row.address.trim()) {
          contact.address = row.address.trim();
        }
        if (row.city && typeof row.city === 'string' && row.city.trim()) {
          contact.city = row.city.trim();
        }
        if (row.province && typeof row.province === 'string' && row.province.trim()) {
          contact.province = normalizeProvince(row.province);
        }
        if (row.postalCode && typeof row.postalCode === 'string' && row.postalCode.trim()) {
          contact.postalCode = normalizePostalCode(row.postalCode);
        }
        if (row.categories && Array.isArray(row.categories)) {
          contact.categories = row.categories.filter(c => c && c.trim());
        }
        
        // BEFORE column mapping, extract email/phone/address from ALL columns
        // This handles CPC format "Member Information" style columns
        // Check ALL columns because column mapping might be incorrect
        for (const [sourceColumn, value] of Object.entries(row)) {
          // Convert value to string for processing (handle all types, not just strings)
          let stringValue = '';
          if (value === null || value === undefined) continue;
          if (typeof value === 'string') {
            stringValue = value.trim();
          } else if (typeof value === 'number' || typeof value === 'boolean') {
            stringValue = String(value).trim();
          } else if (Array.isArray(value)) {
            stringValue = value.map(v => String(v || '')).join(' ').trim();
          } else if (typeof value === 'object') {
            // For objects, try to extract meaningful string representation
            stringValue = JSON.stringify(value).trim();
          } else {
            stringValue = String(value).trim();
          }
          
          if (!stringValue || stringValue === '-' || stringValue === 'N/A' || stringValue === 'null' || stringValue === 'undefined') continue;
          const normalized = stringValue.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
          
          // Extract email if missing
          if (!contact.email) {
            const emailMatch = normalized.match(/(?:E-mail\s+Address|Email|e-mail)[:\s]+([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,})/i);
            if (emailMatch && emailMatch[1]) {
              contact.email = emailMatch[1].trim().toLowerCase();
            } else {
              const simpleEmailMatch = normalized.match(/\b([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,})\b/);
              if (simpleEmailMatch && simpleEmailMatch[1]) {
                contact.email = simpleEmailMatch[1].trim().toLowerCase();
              }
            }
          }
          
          // Extract phone if missing
          if (!contact.phone) {
            const phoneMatches = normalized.match(/(?:Home\s+)?(?:Cell\s+)?(?:Phone|Fax)[:\s]+(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/gi);
            if (phoneMatches && phoneMatches.length > 0) {
              const phoneMatch = phoneMatches[0].match(/(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/);
              if (phoneMatch && phoneMatch[1]) {
                const phoneDigits = phoneMatch[1].replace(/\D/g, '');
                if (phoneDigits.length >= 10 && phoneDigits.length <= 11) {
                  contact.phone = normalizePhone(phoneMatch[1]);
                }
              }
            } else {
              const simplePhoneMatch = normalized.match(/(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/);
              if (simplePhoneMatch && simplePhoneMatch[1]) {
                const phoneDigits = simplePhoneMatch[1].replace(/\D/g, '');
                if (phoneDigits.length >= 10 && phoneDigits.length <= 11) {
                  contact.phone = normalizePhone(simplePhoneMatch[1]);
                }
              }
            }
          }
          
          // Extract address if missing
          if (!contact.address) {
            const addressMatch = normalized.match(/(?:Res\.\s+Add|Address|Res\.\s+Address)[:\s]+(.+?)(?:\n|$)/i);
            if (addressMatch && addressMatch[1]) {
              let addressLine = addressMatch[1].trim();
              const parsed = parseAddress(addressLine);
              if (parsed.address) {
                contact.address = parsed.address;
                if (!contact.city && parsed.city) contact.city = parsed.city;
                if (!contact.province && parsed.province) contact.province = parsed.province;
                if (!contact.postalCode && parsed.postalCode) contact.postalCode = parsed.postalCode;
              } else {
                contact.address = addressLine;
              }
            }
          }
        }
        
        // Map columns - process in order: fullAddress first, then individual fields
        // This allows fullAddress to populate empty individual fields
        // Only map if the field is still empty (extracted fields take priority)
        
        // First pass: collect all mapped values
        const mappedValues = {};
        for (const [sourceColumn, targetField] of Object.entries(columnMapping)) {
          if (!targetField || targetField === 'unmapped') continue;
          
          const value = row[sourceColumn];
          if (!value || (typeof value === 'string' && value.trim() === '')) continue;
          
          const stringValue = String(value).trim();
          
          // Skip if value is just a dash (common placeholder for empty)
          if (stringValue === '-' || stringValue === 'N/A' || stringValue === 'n/a') continue;
          
          if (!mappedValues[targetField]) {
            mappedValues[targetField] = [];
          }
          mappedValues[targetField].push({ column: sourceColumn, value: stringValue });
        }
        
        // Process fullAddress first if present
        // Wrap in try-catch to prevent failures from breaking the entire row
        try {
          if (mappedValues['fullAddress'] && mappedValues['fullAddress'].length > 0 && mappedValues['fullAddress'][0] && mappedValues['fullAddress'][0].value) {
            const fullAddressValue = String(mappedValues['fullAddress'][0].value).trim();
            if (fullAddressValue && fullAddressValue !== '-' && fullAddressValue !== 'N/A') {
              // Parse address from the fullAddress field
              const parsed = parseAddress(fullAddressValue);
              
              // Only use parsed values if the individual fields are empty
              if (parsed && parsed.address && !contact.address) contact.address = parsed.address;
              if (parsed && parsed.city && !contact.city) contact.city = parsed.city;
              if (parsed && parsed.province && !contact.province) contact.province = parsed.province;
              if (parsed && parsed.postalCode && !contact.postalCode) contact.postalCode = parsed.postalCode;
              
              // Also extract phone and email from "Member Information" style multi-line format
              const normalized = fullAddressValue.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
              
              // Extract phone numbers (look for "Phone:", "Cell Phone:", etc.)
              if (!contact.phone) {
                try {
                  const phoneMatches = normalized.match(/(?:Home\s+)?(?:Cell\s+)?Phone[:\s]+(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/gi);
                  if (phoneMatches && phoneMatches.length > 0) {
                    // Take the first phone number found
                    const phoneMatch = phoneMatches[0].match(/(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/);
                    if (phoneMatch && phoneMatch[1]) {
                      contact.phone = normalizePhone(phoneMatch[1]);
                    }
                  }
                } catch (phoneError) {
                  // If phone extraction fails, just skip it
                }
              }
              
              // Extract email (look for "E-mail Address:", "Email:", etc.)
              if (!contact.email) {
                try {
                  const emailMatch = normalized.match(/(?:E-mail\s+Address|Email)[:\s]+([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,})/i);
                  if (emailMatch && emailMatch[1]) {
                    contact.email = emailMatch[1].trim().toLowerCase();
                  }
                } catch (emailError) {
                  // If email extraction fails, just skip it
                }
              }
            }
          }
        } catch (fullAddressError) {
          // If fullAddress processing fails, just skip it and continue
        }
        
        // CRITICAL: Process fullName FIRST (before other fields) to ensure names are extracted early
        // This prevents placeholder names from being created
        // Also check for "Name" column directly if fullName wasn't mapped
        let nameProcessed = false;
        
        if (mappedValues['fullName'] && mappedValues['fullName'].length > 0 && mappedValues['fullName'][0] && mappedValues['fullName'][0].value) {
          try {
            const fullNameValue = String(mappedValues['fullName'][0].value).trim();
            if (fullNameValue && fullNameValue !== '-' && fullNameValue !== 'N/A') {
              if (!isSpecial) {
                const { firstName, lastName } = splitFullName(fullNameValue);
                // Always use fullName parsing - it's more accurate than placeholders
                if (firstName) {
                  contact.firstName = firstName;
                  nameProcessed = true;
                }
                if (lastName) {
                  contact.lastName = lastName;
                  nameProcessed = true;
                }
              } else {
                // For special structure, use the full name as-is
                if (!contact.name) contact.name = fullNameValue;
                nameProcessed = true;
              }
            }
          } catch (fullNameError) {
            // If fullName processing fails, continue with other fields
          }
        }
        
        // CRITICAL FIX: If fullName wasn't mapped or processing failed, check for "Name" column directly
        // This catches cases where the Name column wasn't properly mapped
        // Do this BEFORE any other processing to ensure names are extracted
        if (!isSpecial && (!nameProcessed || (!contact.firstName && !contact.lastName))) {
          // First, check if there's a column named "Name" (case-insensitive, with variations)
          for (const [sourceColumn, value] of Object.entries(row)) {
            if (value === null || value === undefined) continue;
            
            const columnLower = sourceColumn.toLowerCase().trim();
            const columnNormalized = columnLower.replace(/[_\s-]/g, '');
            
            // Check if this is a "Name" column (exact match or normalized)
            const isNameColumn = columnLower === 'name' || columnLower === 'names' || 
                                columnNormalized === 'name' || columnNormalized === 'names' ||
                                (columnLower.includes('name') && !columnLower.includes('first') && 
                                 !columnLower.includes('last') && !columnLower.includes('company') &&
                                 !columnLower.includes('organization') && !columnLower.includes('membernameid'));
            
            if (isNameColumn) {
              let stringValue = '';
              if (typeof value === 'string') {
                stringValue = value.trim();
              } else {
                stringValue = String(value).trim();
              }
              
              if (stringValue && stringValue !== '-' && stringValue !== 'N/A' && stringValue.length > 2) {
                // Skip if it looks like a location identifier (e.g., "48031 Parkland")
                if (/^\d+\s+[A-Z][a-z]+$/.test(stringValue)) continue;
                
                // Try to parse the name - works for "Last, First" and other formats
                try {
                  const { firstName, lastName } = splitFullName(stringValue);
                  if (firstName || lastName) {
                    if (firstName && !contact.firstName) contact.firstName = firstName;
                    if (lastName && !contact.lastName) contact.lastName = lastName;
                    nameProcessed = true;
                    break; // Found name, stop searching
                  }
                } catch (nameError) {
                  // If parsing fails, continue to next column
                }
              }
            }
          }
        }
        
        // Process individual fields (they override fullAddress parsing if present)
        // But only if the field is still empty (extracted fields take priority)
        // Wrap in try-catch to prevent one field from failing the entire row
        for (const [targetField, entries] of Object.entries(mappedValues)) {
          if (targetField === 'fullAddress' || targetField === 'fullName') continue; // Already processed
          
          try {
            if (!entries || !entries[0] || !entries[0].value) continue;
            const stringValue = String(entries[0].value).trim();
            if (!stringValue || stringValue === '-' || stringValue === 'N/A') continue;
            
            if (isSpecial) {
              // Special EDA structure fields
              if (targetField === 'name' && !contact.name) {
                contact.name = stringValue;
              } else if (targetField === 'riding' && !contact.riding) {
                contact.riding = stringValue;
              } else if (targetField === 'role' && !contact.role) {
                contact.role = stringValue;
              } else if (targetField === 'province' && !contact.province) {
                contact.province = stringValue;
              } else if (targetField === 'phone' && !contact.phone) {
                try {
                  contact.phone = normalizePhone(stringValue);
                } catch (e) {
                  contact.phone = stringValue; // Use raw value if normalization fails
                }
              } else if (targetField === 'email' && !contact.email) {
                try {
                  contact.email = stringValue.toLowerCase();
                } catch (e) {
                  contact.email = stringValue; // Use raw value if toLowerCase fails
                }
              } else if (targetField === 'category') {
                try {
                  const categories = stringValue.split(',').map(c => c.trim()).filter(c => c);
                  if (categories.length > 0) {
                    // Merge with existing categories
                    contact.categories = [...new Set([...contact.categories, ...categories])];
                  }
                } catch (e) {
                  // If category processing fails, skip it
                }
              } else if (targetField in contact && typeof contact[targetField] === 'string' && !contact[targetField]) {
                contact[targetField] = stringValue;
              }
            } else {
              // Standard structure fields
              if (targetField === 'fullName') {
                const { firstName, lastName } = splitFullName(stringValue);
                // Always use fullName parsing if we have a valid name - it's more accurate than placeholders
                if (firstName) contact.firstName = firstName;
                if (lastName) contact.lastName = lastName;
              } else if (targetField === 'firstName' && !contact.firstName) {
                contact.firstName = stringValue;
              } else if (targetField === 'lastName' && !contact.lastName) {
                contact.lastName = stringValue;
              } else if (targetField === 'address' && !contact.address) {
                contact.address = stringValue;
              } else if (targetField === 'city' && !contact.city) {
                contact.city = stringValue;
              } else if (targetField === 'province' && !contact.province) {
                try {
                  contact.province = normalizeProvince(stringValue);
                } catch (e) {
                  contact.province = stringValue; // Use raw value if normalization fails
                }
              } else if (targetField === 'postalCode' && !contact.postalCode) {
                try {
                  contact.postalCode = normalizePostalCode(stringValue);
                } catch (e) {
                  contact.postalCode = stringValue; // Use raw value if normalization fails
                }
              } else if (targetField === 'phone' && !contact.phone) {
                try {
                  contact.phone = normalizePhone(stringValue);
                } catch (e) {
                  contact.phone = stringValue; // Use raw value if normalization fails
                }
              } else if (targetField === 'category') {
                try {
                  const categories = stringValue.split(',').map(c => c.trim()).filter(c => c);
                  if (categories.length > 0) {
                    // Merge with existing categories
                    contact.categories = [...new Set([...contact.categories, ...categories])];
                  }
                } catch (e) {
                  // If category processing fails, skip it
                }
              } else if (targetField === 'email' && !contact.email) {
                try {
                  contact.email = stringValue.toLowerCase();
                } catch (e) {
                  contact.email = stringValue; // Use raw value if toLowerCase fails
                }
              } else if (targetField in contact && typeof contact[targetField] === 'string' && !contact[targetField]) {
                contact[targetField] = stringValue;
              }
            }
          } catch (fieldError) {
            // If processing this field fails, just skip it and continue with other fields
            // Don't let one field break the entire contact
          }
        }
        
        // Always parse address field to extract and remove city/province/postalCode
        // This ensures the address field only contains street address (or PO Box)
        try {
          if (contact.address && contact.address.trim()) {
            const parsed = parseAddress(contact.address);
            // Always update address to use parsed address (which has city/province/postalCode removed)
            if (parsed.address) {
              contact.address = parsed.address;
            }
            // Fill in missing fields from parsed data
            if (!contact.city && parsed.city) contact.city = parsed.city;
            if (!contact.province && parsed.province) contact.province = parsed.province;
            if (!contact.postalCode && parsed.postalCode) contact.postalCode = parsed.postalCode;
          }
        } catch (parseError) {
          // If address parsing fails, just keep the original address
        }
        
        // If still no names, try to find them in unmapped columns or ALL columns
        // Wrap in try-catch to prevent name extraction failures from breaking the row
        try {
          if (!contact.firstName && !contact.lastName) {
            // First, scan all unmapped columns
            for (const [sourceColumn, targetField] of Object.entries(columnMapping)) {
              if (targetField && targetField !== 'unmapped') continue; // Skip mapped columns
              
              try {
                const value = row[sourceColumn];
                if (!value) continue;
                
                let stringValue = '';
                if (typeof value === 'string') {
                  stringValue = value.trim();
                } else {
                  stringValue = String(value).trim();
                }
                
                if (!stringValue || stringValue === '-' || stringValue === 'N/A' || stringValue.length < 2) continue;
                
                // Skip if it looks like a poll/location header or address
                if (/^(Poll\s+\d+|^\d+$|^Post\.:|^Res\.:)/i.test(stringValue)) {
                  continue;
                }
                
                // Check if it looks like a name (capitalized words, reasonable length)
                // More flexible pattern - allows for hyphens, apostrophes, commas, etc.
                const namePattern = /^[A-Z][a-z]+(?:['-][A-Z][a-z]+)?(?:\s*,\s*[A-Z][a-z]+)?(?:\s+[A-Z][a-z]+(?:['-][A-Z][a-z]+)?){0,2}$/;
                // Also check if it's mostly letters (at least 70% letters, no @, no long number sequences)
                const isMostlyLetters = /^[A-Za-z\s',-]+$/.test(stringValue) && 
                                       stringValue.replace(/[^A-Za-z]/g, '').length >= stringValue.length * 0.7 &&
                                       !stringValue.includes('@') && 
                                       !/\d{4,}/.test(stringValue) &&
                                       !stringValue.toLowerCase().includes('box') &&
                                       !stringValue.toLowerCase().includes('po ') &&
                                       !stringValue.toLowerCase().includes('range road') &&
                                       !stringValue.toLowerCase().includes('township') &&
                                       !stringValue.toLowerCase().includes('poll') &&
                                       !stringValue.toLowerCase().includes('community') &&
                                       !stringValue.toLowerCase().includes('association');
                
                if ((namePattern.test(stringValue) || isMostlyLetters) && stringValue.length < 60) {
                  // This looks like a name - try to split it
                  const { firstName, lastName } = splitFullName(stringValue);
                  if (firstName || lastName) {
                    if (!contact.firstName) contact.firstName = firstName;
                    if (!contact.lastName) contact.lastName = lastName;
                    break; // Found a name, stop searching
                  }
                }
              } catch (nameExtractError) {
                // If name extraction from this column fails, continue to next column
                continue;
              }
            }
            
            // If still no name found, scan ALL columns (including mapped ones that might have names)
            if (!contact.firstName && !contact.lastName) {
              for (const [sourceColumn, value] of Object.entries(row)) {
                if (!value) continue;
                
                try {
                  let stringValue = '';
                  if (typeof value === 'string') {
                    stringValue = value.trim();
                  } else {
                    stringValue = String(value).trim();
                  }
                  
                  if (!stringValue || stringValue === '-' || stringValue === 'N/A' || stringValue.length < 2) continue;
                  
                  // Skip if this column is already mapped to something else (unless it's unmapped)
                  const mappedField = columnMapping[sourceColumn];
                  if (mappedField && mappedField !== 'unmapped' && 
                      mappedField !== 'fullName' && mappedField !== 'firstName' && mappedField !== 'lastName') {
                    continue;
                  }
                  
                  // Skip if it looks like a poll/location header or address
                  if (/^(Poll\s+\d+|^\d+$|^Post\.:|^Res\.:)/i.test(stringValue)) {
                    continue;
                  }
                  
                  // Check if it looks like a name
                  const namePattern2 = /^[A-Z][a-z]+(?:['-][A-Z][a-z]+)?(?:\s*,\s*[A-Z][a-z]+)?(?:\s+[A-Z][a-z]+(?:['-][A-Z][a-z]+)?){0,2}$/;
                  const isMostlyLetters2 = /^[A-Za-z\s',-]+$/.test(stringValue) && 
                                         stringValue.replace(/[^A-Za-z]/g, '').length >= stringValue.length * 0.7 &&
                                         !stringValue.includes('@') && 
                                         !/\d{4,}/.test(stringValue) &&
                                         !stringValue.toLowerCase().includes('box') &&
                                         !stringValue.toLowerCase().includes('po ') &&
                                         !stringValue.toLowerCase().includes('range road') &&
                                         !stringValue.toLowerCase().includes('township') &&
                                         !stringValue.toLowerCase().includes('poll') &&
                                         !stringValue.toLowerCase().includes('community') &&
                                         !stringValue.toLowerCase().includes('association');
                  
                  if ((namePattern2.test(stringValue) || isMostlyLetters2) && stringValue.length < 60) {
                    const { firstName, lastName } = splitFullName(stringValue);
                    if (firstName || lastName) {
                      if (!contact.firstName) contact.firstName = firstName;
                      if (!contact.lastName) contact.lastName = lastName;
                      break; // Found a name, stop searching
                    }
                  }
                } catch (nameExtractError2) {
                  // If name extraction from this column fails, continue to next column
                  continue;
                }
              }
            }
          }
        } catch (nameSearchError) {
          // If name search fails entirely, we'll use placeholder names below
        }
        
        // Before final validation, try one more time to extract from ALL columns
        // This handles CPC format "Member Information" style columns that might not have been transformed
        // Do this as a final pass before validation to catch any missed data
        // Check ALL columns, not just unmapped, because mapping might be wrong
        // Handle all value types, not just strings
        for (const [sourceColumn, value] of Object.entries(row)) {
          // Convert value to string for processing (handle all types)
          let stringValue = '';
          if (value === null || value === undefined) continue;
          if (typeof value === 'string') {
            stringValue = value.trim();
          } else if (typeof value === 'number' || typeof value === 'boolean') {
            stringValue = String(value).trim();
          } else if (Array.isArray(value)) {
            stringValue = value.map(v => String(v || '')).join(' ').trim();
          } else if (typeof value === 'object') {
            // For objects, try to extract meaningful string representation
            stringValue = JSON.stringify(value).trim();
          } else {
            stringValue = String(value).trim();
          }
          
          if (!stringValue || stringValue === '-' || stringValue === 'N/A' || stringValue === 'null' || stringValue === 'undefined') continue;
          const normalized = stringValue.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
          
          // Extract email if missing
          if (!contact.email) {
            const emailMatch = normalized.match(/(?:E-mail\s+Address|Email|e-mail)[:\s]+([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,})/i);
            if (emailMatch && emailMatch[1]) {
              contact.email = emailMatch[1].trim().toLowerCase();
            } else {
              const simpleEmailMatch = normalized.match(/\b([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,})\b/);
              if (simpleEmailMatch && simpleEmailMatch[1]) {
                contact.email = simpleEmailMatch[1].trim().toLowerCase();
              }
            }
          }
          
          // Extract phone if missing
          if (!contact.phone) {
            const phoneMatches = normalized.match(/(?:Home\s+)?(?:Cell\s+)?(?:Phone|Fax)[:\s]+(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/gi);
            if (phoneMatches && phoneMatches.length > 0) {
              const phoneMatch = phoneMatches[0].match(/(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/);
              if (phoneMatch && phoneMatch[1]) {
                const phoneDigits = phoneMatch[1].replace(/\D/g, '');
                if (phoneDigits.length >= 10 && phoneDigits.length <= 11) {
                  contact.phone = normalizePhone(phoneMatch[1]);
                }
              }
            } else {
              const simplePhoneMatch = normalized.match(/(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/);
              if (simplePhoneMatch && simplePhoneMatch[1]) {
                const phoneDigits = simplePhoneMatch[1].replace(/\D/g, '');
                if (phoneDigits.length >= 10 && phoneDigits.length <= 11) {
                  contact.phone = normalizePhone(simplePhoneMatch[1]);
                }
              }
            }
          }
          
          // Extract address if missing
          if (!contact.address) {
            const addressMatch = normalized.match(/(?:Res\.\s+Add|Address|Res\.\s+Address)[:\s]+(.+?)(?:\n|$)/i);
            if (addressMatch && addressMatch[1]) {
              let addressLine = addressMatch[1].trim();
              const parsed = parseAddress(addressLine);
              if (parsed.address) {
                contact.address = parsed.address;
                if (!contact.city && parsed.city) contact.city = parsed.city;
                if (!contact.province && parsed.province) contact.province = parsed.province;
                if (!contact.postalCode && parsed.postalCode) contact.postalCode = parsed.postalCode;
              } else {
                contact.address = addressLine;
              }
            }
          }
        }
        
        // CRITICAL: If we still don't have names, scan ALL columns for name-like data
        // This catches cases where the name column wasn't properly mapped
        // Do this BEFORE creating placeholder names
        // USER REQUEST: All rows contain data, so be very aggressive in finding names
        if (!isSpecial && !contact.firstName && !contact.lastName) {
          // First, prioritize columns that look like name columns (case-insensitive header check)
          for (const [sourceColumn, value] of Object.entries(row)) {
            if (value === null || value === undefined) continue;
            
            const columnLower = sourceColumn.toLowerCase().trim();
            const columnNormalized = columnLower.replace(/[_\s-]/g, '');
            const isNameColumn = columnLower === 'name' || columnLower === 'names' || 
                                columnNormalized === 'name' || columnNormalized === 'names' ||
                                (columnLower.includes('name') && !columnLower.includes('first') && 
                                 !columnLower.includes('last') && !columnLower.includes('company') &&
                                 !columnLower.includes('organization') && !columnLower.includes('membernameid'));
            
            // If this is a Name column, process it FIRST (highest priority)
            if (isNameColumn) {
              let stringValue = '';
              if (typeof value === 'string') {
                stringValue = value.trim();
              } else {
                stringValue = String(value).trim();
              }
              
              if (stringValue && stringValue !== '-' && stringValue !== 'N/A' && stringValue.length > 2) {
                // Skip if it looks like a location identifier (e.g., "48031 Parkland")
                if (/^\d+\s+[A-Z][a-z]+$/.test(stringValue)) continue;
                
                // Try to parse the name - works for "Last, First" and other formats
                try {
                  const { firstName, lastName } = splitFullName(stringValue);
                  if (firstName || lastName) {
                    if (firstName) contact.firstName = firstName;
                    if (lastName) contact.lastName = lastName;
                    break; // Found name, stop searching
                  }
                } catch (nameError) {
                  // If parsing fails, continue to next column
                }
              }
            }
          }
          
          // If still no names, check ALL columns for "Last, First" format (second priority)
          if (!contact.firstName && !contact.lastName) {
            for (const [sourceColumn, value] of Object.entries(row)) {
              if (value === null || value === undefined) continue;
              
              let stringValue = '';
              if (typeof value === 'string') {
                stringValue = value.trim();
              } else {
                stringValue = String(value).trim();
              }
              
              if (!stringValue || stringValue === '-' || stringValue === 'N/A' || stringValue.length < 2) continue;
              
              // Skip if it looks like a poll/location header, address, or phone
              if (/^(Poll\s+\d+|^\d+\s+[A-Z][a-z]+$|^Post\.:|^Res\.:|^\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/i.test(stringValue)) {
                continue;
              }
              
              // Check if it looks like a "Last, First" name (highest priority pattern)
              if (/^[A-Z][a-z]+,\s+[A-Z]/.test(stringValue)) {
                try {
                  const { firstName, lastName } = splitFullName(stringValue);
                  if (firstName || lastName) {
                    if (firstName) contact.firstName = firstName;
                    if (lastName) contact.lastName = lastName;
                    break; // Found a name, stop searching
                  }
                } catch (nameError) {
                  // Continue searching
                }
              }
            }
          }
          
          // If still no names, check ALL columns for general name patterns (third priority)
          if (!contact.firstName && !contact.lastName) {
            for (const [sourceColumn, value] of Object.entries(row)) {
              if (value === null || value === undefined) continue;
              
              let stringValue = '';
              if (typeof value === 'string') {
                stringValue = value.trim();
              } else {
                stringValue = String(value).trim();
              }
              
              if (!stringValue || stringValue === '-' || stringValue === 'N/A' || stringValue.length < 2) continue;
              
              // Skip if it looks like a poll/location header, address, or phone
              if (/^(Poll\s+\d+|^\d+\s+[A-Z][a-z]+$|^Post\.:|^Res\.:|^\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/i.test(stringValue)) {
                continue;
              }
              
              // If this looks like a name column, be more aggressive in checking
              const columnLower = sourceColumn.toLowerCase();
              const isNameColumn = columnLower === 'name' || columnLower.includes('name') && 
                                  !columnLower.includes('first') && !columnLower.includes('last') &&
                                  !columnLower.includes('company') && !columnLower.includes('organization');
              
              if (isNameColumn) {
                try {
                  const { firstName, lastName } = splitFullName(stringValue);
                  if (firstName || lastName) {
                    if (firstName) contact.firstName = firstName;
                    if (lastName) contact.lastName = lastName;
                    break; // Found a name, stop searching
                  }
                } catch (nameError) {
                  // Continue searching
                }
              }
              
              // Check if it looks like a regular name pattern
              const namePattern = /^[A-Z][a-z]+(?:['-][A-Z][a-z]+)?(?:\s*,\s*[A-Z][a-z]+)?(?:\s+[A-Z][a-z]+(?:['-][A-Z][a-z]+)?){0,2}$/;
              const isMostlyLetters = /^[A-Za-z\s',-]+$/.test(stringValue) &&
                                     stringValue.length > 2 &&
                                     stringValue.length < 60 &&
                                     !stringValue.toLowerCase().includes('association');
              
              if ((namePattern.test(stringValue) || isMostlyLetters) && stringValue.length < 60) {
                // This looks like a name - try to split it
                try {
                  const { firstName, lastName } = splitFullName(stringValue);
                  if (firstName || lastName) {
                    if (firstName) contact.firstName = firstName;
                    if (lastName) contact.lastName = lastName;
                    break; // Found a name, stop searching
                  }
                } catch (nameError) {
                  // Continue searching
                }
              }
            }
          }
        }
        
        // Check if row has any valid contact data before creating placeholder names
        // Skip rows that have no contact data (no email, phone, address, or name)
        const hasContactData = contact.email || contact.phone || contact.address || 
                              (isSpecial ? contact.name : (contact.firstName || contact.lastName));
        
        if (!hasContactData) {
          // No contact data at all - skip this row (should have been caught earlier, but double-check)
          errors.push({ row: i + 2, message: 'Skipped: No contact data found', data: row });
          continue;
        }
        
        // NO VALIDATION - Accept ALL rows with contact data, no exceptions
        // The preview already validated the data, so trust it and import everything
        // This ensures we import as many contacts as possible - user can clean up later if needed
        
        if (isSpecial) {
          // Special structure - ensure we have placeholder name
          if (!contact.name || !contact.name.trim()) {
            contact.name = contact.phone ? `Contact (${contact.phone.replace(/\D/g, '').slice(-4)})` : 
                          contact.email ? contact.email.split('@')[0] : 
                          contact.riding ? `Contact (${contact.riding})` :
                          'Contact';
          }
        } else {
          // Standard structure - DO NOT create placeholder names
          // If names weren't extracted, the contact will be saved without names
          // This prevents "Row X" contacts from being created
          // Only ensure categories is an array
          
          // Ensure categories is always an array
          if (!Array.isArray(contact.categories)) {
            contact.categories = [];
          }
          
          // Apply bulk category if provided
          if (bulkCategory && bulkCategory.trim()) {
            const normalizedBulkCategory = bulkCategory.trim();
            // Ensure categories is an array
            if (!Array.isArray(contact.categories)) {
              contact.categories = contact.category ? [contact.category] : [];
            }
            // Add bulk category if not already present
            if (!contact.categories.includes(normalizedBulkCategory)) {
              contact.categories.push(normalizedBulkCategory);
            }
          }
          
          // Final safety check - ensure contact has minimum required fields
          if (!contact.firstName) contact.firstName = 'Contact';
          if (!contact.lastName) contact.lastName = `Row ${i + 2}`;
          if (!Array.isArray(contact.categories)) contact.categories = [];
        }
        
        // Ensure categories is always an array (for both structures)
        if (!Array.isArray(contact.categories)) {
          contact.categories = contact.category ? [contact.category] : [];
        }
        
        // Generate ID (use timestamp + random to ensure uniqueness even for fast processing)
        contact.id = Date.now().toString() + '-' + i + '-' + Math.random().toString(36).substr(2, 9);
        contact.uploadedAt = new Date().toISOString();
        
        // Apply bulk category if provided (for both structures)
        if (bulkCategory && bulkCategory.trim()) {
          const normalizedBulkCategory = bulkCategory.trim();
          // Add bulk category if not already present
          if (!contact.categories.includes(normalizedBulkCategory)) {
            contact.categories.push(normalizedBulkCategory);
          }
        }
        
        // Final safety check - ensure contact has minimum required fields
        if (!contact.id) contact.id = Date.now().toString() + '-' + i + '-' + Math.random().toString(36).substr(2, 9);
        if (!contact.uploadedAt) contact.uploadedAt = new Date().toISOString();
        if (!Array.isArray(contact.categories)) contact.categories = [];
        
        contacts.push(contact);
      } catch (error) {
        // Check if this row has any contact data before creating a fallback contact
        // Skip rows that are clearly not contacts (location identifiers, headers, etc.)
        const rowValues = Object.values(row).map(v => String(v || '').trim()).filter(v => v);
        const rowString = rowValues.join(' ').toLowerCase();
        const firstValue = rowValues[0] || '';
        
        // Check for contact data
        const hasEmail = rowValues.some(v => /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/.test(v));
        const hasPhone = rowValues.some(v => /\(?\d{3}\)?\s*\d{3}[-.]?\d{4}/.test(v));
        const hasNamePattern = rowValues.some(v => /^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+/.test(v) || /^[A-Z][a-z]+,\s+[A-Z]/.test(v));
        const hasAddress = rowValues.some(v => /Res\.:\s*|Post\.:\s*|Res\.\s+Add\.?:/i.test(v));
        
        // Skip rows that are clearly not contacts (location identifiers, headers, etc.)
        const isLocationIdentifier = !hasEmail && !hasPhone && !hasNamePattern && /^\d+\s+[A-Z][a-z]+$/.test(firstValue) && rowValues.length <= 2;
        const isHeaderRow = !hasEmail && !hasPhone && !hasNamePattern && ['expiry', 'date', 'start date', 'end date', 'selection', 'criteria', 'report', 'membership'].some(keyword => rowString.includes(keyword)) && rowValues.length <= 3;
        const isPollRow = !hasEmail && !hasPhone && !hasNamePattern && (rowString.includes('poll') || /^poll\s+\d+/i.test(rowString));
        const isNumberOnlyRow = !hasEmail && !hasPhone && !hasNamePattern && (/^\d+\s+[a-z]+$/i.test(rowString.trim()) || /^\d+$/i.test(rowString.trim()));
        
        // Skip these rows - don't create fallback contacts for them
        if (isLocationIdentifier || isHeaderRow || isPollRow || isNumberOnlyRow) {
          errors.push({ row: i + 2, message: 'Skipped: Not a contact row (location identifier, header, or invalid data)', data: row });
          continue;
        }
        
        // Only create fallback contact if there's at least some contact data
        if (!hasEmail && !hasPhone && !hasNamePattern && !hasAddress) {
          // No contact data at all - skip this row
          errors.push({ row: i + 2, message: 'Skipped: No contact data found', data: row });
          continue;
        }
        
        // If ANY error occurs but row has contact data, create a minimal contact with placeholder data
        // This ensures we import as many contacts as possible while skipping invalid rows
        // BUT: Try to extract names FIRST before creating placeholders
        let extractedFirstName = '';
        let extractedLastName = '';
        let extractedName = '';
        
        // CRITICAL: Always check for "Name" column in the row, even in error cases
        for (const [sourceColumn, value] of Object.entries(row)) {
          if (value === null || value === undefined) continue;
          
          const columnLower = sourceColumn.toLowerCase().trim();
          const columnNormalized = columnLower.replace(/[_\s-]/g, '');
          const isNameColumn = columnLower === 'name' || columnLower === 'names' || 
                              columnNormalized === 'name' || columnNormalized === 'names' ||
                              (columnLower.includes('name') && !columnLower.includes('first') && 
                               !columnLower.includes('last') && !columnLower.includes('company') &&
                               !columnLower.includes('organization') && !columnLower.includes('membernameid'));
          
          if (isNameColumn) {
            let stringValue = '';
            if (typeof value === 'string') {
              stringValue = value.trim();
            } else {
              stringValue = String(value).trim();
            }
            
            if (stringValue && stringValue !== '-' && stringValue !== 'N/A' && stringValue.length > 2) {
              // Skip if it looks like a location identifier
              if (/^\d+\s+[A-Z][a-z]+$/.test(stringValue)) continue;
              
              try {
                if (isSpecial) {
                  extractedName = stringValue;
                } else {
                  const { firstName, lastName } = splitFullName(stringValue);
                  if (firstName) extractedFirstName = firstName;
                  if (lastName) extractedLastName = lastName;
                }
                break; // Found name, stop searching
              } catch (nameError) {
                // Continue searching
              }
            }
          }
        }
        
        const fallbackContact = isSpecial ? {
          id: Date.now().toString() + '-' + i + '-fallback-' + Math.random().toString(36).substr(2, 9),
          name: extractedName || 'Unknown',
          riding: '',
          province: '',
          email: '',
          role: '',
          phone: '',
          uploadedAt: new Date().toISOString()
        } : {
          id: Date.now().toString() + '-' + i + '-fallback-' + Math.random().toString(36).substr(2, 9),
          firstName: extractedFirstName || 'Unknown',
          lastName: extractedLastName || 'Unknown',
          email: '',
          phone: '',
          address: '',
          city: '',
          province: '',
          postalCode: '',
          categories: bulkCategory && bulkCategory.trim() ? [bulkCategory.trim()] : [],
          uploadedAt: new Date().toISOString()
        };
        
        // Try to extract at least something from the row - wrap each extraction in try-catch
        for (const [key, value] of Object.entries(row)) {
          if (!value) continue;
          
          try {
            let str = '';
            if (typeof value === 'string') {
              str = value.trim();
            } else if (typeof value === 'number' || typeof value === 'boolean') {
              str = String(value).trim();
            } else if (Array.isArray(value)) {
              str = value.map(v => String(v || '')).join(' ').trim();
            } else if (typeof value === 'object') {
              str = JSON.stringify(value).trim();
            } else {
              str = String(value).trim();
            }
            
            if (!str || str === '-' || str === 'N/A' || str === 'null' || str === 'undefined') continue;
            
            // Try to find email
            if (!fallbackContact.email) {
              try {
                const emailMatch = str.match(/\b([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,})\b/);
                if (emailMatch && emailMatch[1]) {
                  fallbackContact.email = emailMatch[1].toLowerCase();
                }
              } catch (e) {
                // Skip email extraction if it fails
              }
            }
            
            // Try to find phone
            if (!fallbackContact.phone) {
              try {
                const phoneMatch = str.match(/(\(?\d{3}\)?\s*\d{3}[-.]?\d{4})/);
                if (phoneMatch && phoneMatch[1]) {
                  const digits = phoneMatch[1].replace(/\D/g, '');
                  if (digits.length >= 10 && digits.length <= 11) {
                    fallbackContact.phone = normalizePhone(phoneMatch[1]);
                  }
                }
              } catch (e) {
                // Skip phone extraction if it fails
              }
            }
          } catch (valueError) {
            // If processing this value fails, continue to next value
            continue;
          }
        }
        
        // Always add the fallback contact - even if extraction failed, we have a placeholder contact
        // Ensure it has a unique identifier so it's not marked as duplicate
        if (!fallbackContact.email && !fallbackContact.phone) {
          // If no email/phone, use a unique identifier in the name to prevent false duplicates
          if (isSpecial) {
            fallbackContact.name = `Row ${i + 2} (${contact.id || Date.now() + i})`;
          } else {
            fallbackContact.lastName = `Row ${i + 2} (${contact.id || Date.now() + i})`;
          }
        }
        contacts.push(fallbackContact);
        // Don't count fallback contacts as errors - they're successfully imported with minimal data
        // Only log for debugging, but don't add to errors array
        // errors.push({ row: i + 2, message: `Error processing row, imported with minimal data: ${error.message}` });
      }
    }
    
    if (contacts.length === 0) {
      return res.status(400).json({ error: 'No valid contacts to import', errors });
    }
    
    // Get existing contacts for deduplication
    const existingContacts = await getAccountContacts(accountId);
    
    // Helper function to clean "Res.:" and "Post.:" prefixes from address
    const cleanAddressPrefix = (address) => {
      if (!address || typeof address !== 'string') return address;
      // Remove "Res.:" and "Post.:" prefixes (case-insensitive, with optional spaces)
      return address
        .replace(/^Res\.:\s*/i, '')
        .replace(/^Post\.:\s*/i, '')
        .replace(/^Res\.\s+Add\.?:\s*/i, '')
        .replace(/^Mailing\s+Add\.?:\s*/i, '')
        .trim();
    };
    
    // Clean addresses in all contacts before processing
    for (const contact of contacts) {
      if (contact.address) {
        contact.address = cleanAddressPrefix(contact.address);
      }
    }
    
    // Helper function to check if two contacts are EXACTLY the same
    const isExactDuplicate = (contact1, contact2, isSpecial) => {
      if (isSpecial) {
        // For special structure (EDA)
        return (
          (contact1.name || '').toLowerCase().trim() === (contact2.name || '').toLowerCase().trim() &&
          (contact1.riding || '').toLowerCase().trim() === (contact2.riding || '').toLowerCase().trim() &&
          (contact1.province || '').toLowerCase().trim() === (contact2.province || '').toLowerCase().trim() &&
          (contact1.email || '').toLowerCase().trim() === (contact2.email || '').toLowerCase().trim() &&
          (contact1.role || '').toLowerCase().trim() === (contact2.role || '').toLowerCase().trim() &&
          (contact1.phone || '').replace(/\D/g, '') === (contact2.phone || '').replace(/\D/g, '')
        );
      } else {
        // For standard structure
        const cats1 = Array.isArray(contact1.categories) ? [...contact1.categories].sort().join('|') : '';
        const cats2 = Array.isArray(contact2.categories) ? [...contact2.categories].sort().join('|') : '';
        
        return (
          (contact1.firstName || '').toLowerCase().trim() === (contact2.firstName || '').toLowerCase().trim() &&
          (contact1.lastName || '').toLowerCase().trim() === (contact2.lastName || '').toLowerCase().trim() &&
          (contact1.email || '').toLowerCase().trim() === (contact2.email || '').toLowerCase().trim() &&
          (contact1.phone || '').replace(/\D/g, '') === (contact2.phone || '').replace(/\D/g, '') &&
          (contact1.address || '').toLowerCase().trim() === (contact2.address || '').toLowerCase().trim() &&
          (contact1.city || '').toLowerCase().trim() === (contact2.city || '').toLowerCase().trim() &&
          (contact1.province || '').toLowerCase().trim() === (contact2.province || '').toLowerCase().trim() &&
          (contact1.postalCode || '').replace(/\s/g, '').toUpperCase() === (contact2.postalCode || '').replace(/\s/g, '').toUpperCase() &&
          cats1 === cats2
        );
      }
    };
    
    // Helper function to check if two contacts match (same person, different/missing data)
    const isMatchingContact = (contact1, contact2, isSpecial) => {
      // Don't match if they're exact duplicates (already handled)
      if (isExactDuplicate(contact1, contact2, isSpecial)) {
        return false;
      }
      
      if (isSpecial) {
        // For special structure: match by name + (email OR phone OR riding+province)
        const name1 = (contact1.name || '').toLowerCase().trim();
        const name2 = (contact2.name || '').toLowerCase().trim();
        
        if (!name1 || !name2 || name1 !== name2) {
          return false;
        }
        
        // Must have at least one matching identifier OR one missing that the other can fill
        const email1 = (contact1.email || '').toLowerCase().trim();
        const email2 = (contact2.email || '').toLowerCase().trim();
        const phone1 = (contact1.phone || '').replace(/\D/g, '');
        const phone2 = (contact2.phone || '').replace(/\D/g, '');
        const riding1 = (contact1.riding || '').toLowerCase().trim();
        const riding2 = (contact2.riding || '').toLowerCase().trim();
        const province1 = (contact1.province || '').toLowerCase().trim();
        const province2 = (contact2.province || '').toLowerCase().trim();
        
        // Match if:
        // 1. Both have same email, OR
        // 2. Both have same phone (and valid), OR
        // 3. Both have same riding+province, OR
        // 4. One has email/phone/riding+province and the other doesn't (to fill missing data)
        // BUT don't match if they have conflicting identifiers (different emails/phones)
        const hasConflictingEmail = email1 && email2 && email1 !== email2;
        const hasConflictingPhone = phone1 && phone2 && phone1.length >= 10 && phone2.length >= 10 && phone1 !== phone2;
        const hasConflictingRiding = riding1 && riding2 && province1 && province2 && 
                                     (riding1 !== riding2 || province1 !== province2);
        
        if (hasConflictingEmail || hasConflictingPhone || hasConflictingRiding) {
          return false; // Don't match if identifiers conflict
        }
        
        return (
          (email1 && email2 && email1 === email2) ||
          (phone1 && phone2 && phone1 === phone2 && phone1.length >= 10) ||
          (riding1 && riding2 && riding1 === riding2 && province1 && province2 && province1 === province2) ||
          // Match if names are same and one has identifier that other is missing
          (name1 === name2 && (
            (email1 && !email2) || (!email1 && email2) ||
            (phone1 && phone1.length >= 10 && !phone2) || (!phone1 && phone2 && phone2.length >= 10) ||
            (riding1 && province1 && !riding2) || (!riding1 && riding2 && province2)
          ))
        );
      } else {
        // For standard structure: match by (firstName + lastName) AND (email OR phone OR missing data)
        const firstName1 = (contact1.firstName || '').toLowerCase().trim();
        const firstName2 = (contact2.firstName || '').toLowerCase().trim();
        const lastName1 = (contact1.lastName || '').toLowerCase().trim();
        const lastName2 = (contact2.lastName || '').toLowerCase().trim();
        
        if (!firstName1 || !firstName2 || firstName1 !== firstName2) {
          return false;
        }
        if (!lastName1 || !lastName2 || lastName1 !== lastName2) {
          return false;
        }
        
        // Must have at least one matching identifier OR one missing that the other can fill
        const email1 = (contact1.email || '').toLowerCase().trim();
        const email2 = (contact2.email || '').toLowerCase().trim();
        const phone1 = (contact1.phone || '').replace(/\D/g, '');
        const phone2 = (contact2.phone || '').replace(/\D/g, '');
        
        // Match if:
        // 1. Both have same email, OR
        // 2. Both have same phone (and valid), OR
        // 3. One has email/phone and the other doesn't (to fill missing data)
        // BUT don't match if they have conflicting identifiers (different emails/phones)
        const hasConflictingEmail = email1 && email2 && email1 !== email2;
        const hasConflictingPhone = phone1 && phone2 && phone1.length >= 10 && phone2.length >= 10 && phone1 !== phone2;
        
        if (hasConflictingEmail || hasConflictingPhone) {
          return false; // Don't match if identifiers conflict
        }
        
        return (
          (email1 && email2 && email1 === email2) ||
          (phone1 && phone2 && phone1 === phone2 && phone1.length >= 10) ||
          // Match if names are same and one has identifier that other is missing
          (firstName1 === firstName2 && lastName1 === lastName2 && (
            (email1 && !email2) || (!email1 && email2) ||
            (phone1 && phone1.length >= 10 && !phone2) || (!phone1 && phone2 && phone2.length >= 10)
          ))
        );
      }
    };
    
    // Helper function to merge two contacts (fill missing fields from source into target)
    // Treats empty strings as missing data
    const isEmpty = (value) => !value || (typeof value === 'string' && value.trim() === '');
    
    const mergeContact = (target, source, isSpecial) => {
      let merged = false;
      
      if (isSpecial) {
        // Special structure fields
        if (isEmpty(target.name) && !isEmpty(source.name)) {
          target.name = source.name;
          merged = true;
        }
        if (isEmpty(target.riding) && !isEmpty(source.riding)) {
          target.riding = source.riding;
          merged = true;
        }
        if (isEmpty(target.province) && !isEmpty(source.province)) {
          target.province = source.province;
          merged = true;
        }
        if (isEmpty(target.email) && !isEmpty(source.email)) {
          target.email = source.email;
          merged = true;
        }
        if (isEmpty(target.role) && !isEmpty(source.role)) {
          target.role = source.role;
          merged = true;
        }
        if (isEmpty(target.phone) && !isEmpty(source.phone)) {
          target.phone = source.phone;
          merged = true;
        }
        if (isEmpty(target.pollNumber) && !isEmpty(source.pollNumber)) {
          target.pollNumber = source.pollNumber;
          merged = true;
        }
        // Merge categories
        const targetCats = Array.isArray(target.categories) ? [...target.categories] : [];
        const sourceCats = Array.isArray(source.categories) ? [...source.categories] : [];
        const mergedCats = [...new Set([...targetCats, ...sourceCats])];
        if (mergedCats.length > targetCats.length) {
          target.categories = mergedCats;
          merged = true;
        }
      } else {
        // Standard structure fields
        if (isEmpty(target.firstName) && !isEmpty(source.firstName)) {
          target.firstName = source.firstName;
          merged = true;
        }
        if (isEmpty(target.lastName) && !isEmpty(source.lastName)) {
          target.lastName = source.lastName;
          merged = true;
        }
        if (isEmpty(target.email) && !isEmpty(source.email)) {
          target.email = source.email;
          merged = true;
        }
        if (isEmpty(target.phone) && !isEmpty(source.phone)) {
          target.phone = source.phone;
          merged = true;
        }
        if (isEmpty(target.address) && !isEmpty(source.address)) {
          target.address = cleanAddressPrefix(source.address);
          merged = true;
        }
        if (isEmpty(target.city) && !isEmpty(source.city)) {
          target.city = source.city;
          merged = true;
        }
        if (isEmpty(target.province) && !isEmpty(source.province)) {
          target.province = source.province;
          merged = true;
        }
        if (isEmpty(target.postalCode) && !isEmpty(source.postalCode)) {
          target.postalCode = source.postalCode;
          merged = true;
        }
        if (isEmpty(target.pollNumber) && !isEmpty(source.pollNumber)) {
          target.pollNumber = source.pollNumber;
          merged = true;
        }
        // Merge categories
        const targetCats = Array.isArray(target.categories) ? [...target.categories] : [];
        const sourceCats = Array.isArray(source.categories) ? [...source.categories] : [];
        const mergedCats = [...new Set([...targetCats, ...sourceCats])];
        if (mergedCats.length > targetCats.length) {
          target.categories = mergedCats;
          merged = true;
        }
      }
      
      return merged;
    };
    
    // USER REQUIREMENT: Skip EXACT duplicates only - if record exists exactly, don't import
    // If same name but different data, DO import
    // Also merge matching contacts with missing information
    const uniqueContacts = [];
    const skippedDuplicates = []; // Only contacts that are EXACT duplicates
    const mergedContacts = []; // Contacts that were merged with existing ones
    const seenInBatch = new Set();
    
    for (const contact of contacts) {
      // First check if this is an exact duplicate within the batch
      let isDuplicateInBatch = false;
      for (const existingInBatch of uniqueContacts) {
        if (isExactDuplicate(contact, existingInBatch, isSpecial)) {
          isDuplicateInBatch = true;
          skippedDuplicates.push({ 
            contact: isSpecial ? contact.name : `${contact.firstName} ${contact.lastName}`, 
            reason: 'Exact duplicate in import file' 
          });
          break;
        }
      }
      
      if (isDuplicateInBatch) {
        continue;
      }
      
      // Check against existing contacts - skip if exact duplicate, merge if matching
      let isExactDupe = false;
      let matchedExisting = null;
      
      for (const existingContact of existingContacts) {
        if (isExactDuplicate(contact, existingContact, isSpecial)) {
          isExactDupe = true;
          skippedDuplicates.push({ 
            contact: isSpecial ? contact.name : `${contact.firstName} ${contact.lastName}`, 
            reason: 'Exact duplicate already exists in database' 
          });
          break;
        }
        
        // Check if this is a matching contact (same person, different/missing data)
        if (!matchedExisting && isMatchingContact(contact, existingContact, isSpecial)) {
          matchedExisting = existingContact;
        }
      }
      
      if (isExactDupe) {
        continue;
      }
      
      // If we found a matching existing contact, merge the new data into it
      if (matchedExisting) {
        const wasMerged = mergeContact(matchedExisting, contact, isSpecial);
        if (wasMerged) {
          mergedContacts.push({
            contact: isSpecial ? contact.name : `${contact.firstName} ${contact.lastName}`,
            reason: 'Merged with existing contact - filled missing information'
          });
        }
        continue; // Don't add as new contact, we merged it
      }
      
      // Check if this matches a contact already in the batch (for merging within batch)
      let matchedInBatch = null;
      for (const existingInBatch of uniqueContacts) {
        if (isMatchingContact(contact, existingInBatch, isSpecial)) {
          matchedInBatch = existingInBatch;
          break;
        }
      }
      
      if (matchedInBatch) {
        // Merge within batch
        const wasMerged = mergeContact(matchedInBatch, contact, isSpecial);
        if (wasMerged) {
          mergedContacts.push({
            contact: isSpecial ? contact.name : `${contact.firstName} ${contact.lastName}`,
            reason: 'Merged with contact in import file - filled missing information'
          });
        }
        continue; // Don't add as new contact, we merged it
      }
      
      // Not an exact duplicate and no match found - add to import list
      uniqueContacts.push(contact);
    }
    
    if (uniqueContacts.length === 0 && mergedContacts.length === 0) {
      return res.status(400).json({ 
        error: 'All contacts are exact duplicates - nothing to import', 
        errors: errors.concat(skippedDuplicates.map(d => ({ row: 'N/A', message: `${d.contact}: ${d.reason}` })))
      });
    }
    
    // Update existing contacts (some may have been merged)
    // Add new unique contacts to existing contacts
    const allContacts = existingContacts.concat(uniqueContacts);
    await updateAccountContacts(accountId, allContacts);
    
    // Track upload operation
    const uploadHistoryPath = path.join(__dirname, 'data', 'shared-data', accountId, 'upload-history.json');
    let uploadHistory = [];
    try {
      const uploadHistoryData = await fsPromises.readFile(uploadHistoryPath, 'utf8');
      uploadHistory = JSON.parse(uploadHistoryData);
    } catch (error) {
      uploadHistory = [];
    }
    
    const uploadOperation = {
      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
      timestamp: new Date().toISOString(),
      contactIds: uniqueContacts.map(c => c.id),
      contactCount: uniqueContacts.length
    };
    
    uploadHistory.unshift(uploadOperation);
    uploadHistory = uploadHistory.slice(0, 5);
    await fsPromises.writeFile(uploadHistoryPath, JSON.stringify(uploadHistory, null, 2), 'utf8');
    
    // Log audit event
    await logAuditEvent(req.user.id, 'SMART_IMPORT_CONTACTS', {
      contactCount: uniqueContacts.length,
      errorCount: errors.length,
      duplicateCount: skippedDuplicates.length,
      uploadOperationId: uploadOperation.id
    }, req);
    
    // Calculate totals for verification
    const totalProcessed = uniqueContacts.length + skippedDuplicates.length;
    const totalAttempted = contacts.length;
    
    res.json({
      success: true,
      contacts: allContacts,
      imported: uniqueContacts.length,
      updated: mergedContacts.length, // Contacts that were merged with existing ones
      skipped: skippedDuplicates.length,
      totalAttempted: totalAttempted,
      totalProcessed: totalProcessed,
      errors: errors.length,
      errorDetails: errors,
      skippedDetails: skippedDuplicates,
      mergedDetails: mergedContacts,
      bulkCategoryApplied: bulkCategory && bulkCategory.trim() ? bulkCategory.trim() : null
    });
  } catch (error) {
    console.error('Smart import finalize error:', error);
    res.status(400).json({ error: error.message || 'Failed to import contacts' });
  }
});

// Payment methods - billing via Paddle (no in-app saved methods)
app.get('/api/payments/methods', auth, async (req, res) => {
  try {
    const paymentMethods = {
      card: {
        name: 'Credit/Debit Card',
        types: ['Visa', 'Mastercard', 'American Express', 'Discover'],
        description: 'Pay via Paddle checkout',
        icon: 'credit-card',
        enabled: true
      }
    };
    res.json({
      success: true,
      availableMethods: paymentMethods,
      savedMethods: [],
      currency: 'CAD',
      processingInfo: {
        securityFeatures: ['SSL Encryption', 'PCI DSS Compliant', 'Paddle'],
        acceptedCards: ['Visa', 'Mastercard', 'American Express', 'Discover'],
        countries: ['Canada', 'United States']
      }
    });
  } catch (error) {
    console.error('Payment methods API error:', error);
    res.status(500).json({ success: false, error: 'Failed to retrieve payment methods' });
  }
});

// Add efficient address lookup endpoint
app.get('/api/places/lookup', auth, async (req, res) => {
  try {
    const { houseNumber, postalCode } = req.query;
    
    if (!postalCode) {
      return res.status(400).json({ error: 'Postal code is required' });
    }

    const locationiqToken = process.env.LOCATIONIQ_AUTOCOMPLETE_TOKEN || process.env.locationIqToken;
    
    // Search for addresses in the postal code area
    const searchQuery = `${postalCode}, Canada`;
    const url = `https://api.locationiq.com/v1/autocomplete?key=${locationiqToken}&q=${encodeURIComponent(searchQuery)}&countrycodes=ca&format=json&limit=20`;
    
    try {
      const response = await fetch(url);
      
      if (response.ok) {
        const data = await response.json();

        if (Array.isArray(data) && data.length > 0) {
          // Filter results to only include addresses in the exact postal code
          const postalCodeClean = postalCode.replace(/\s/g, '');
          const matchingAddresses = data.filter(item => {
            const itemPostalCode = item.address?.postcode?.replace(/\s/g, '');
            return itemPostalCode === postalCodeClean;
          });

          // Map to frontend format
          const predictions = matchingAddresses.map(item => {
            const address = item.address || {};
            
            // Use house number from query if provided, otherwise from address
            let displayHouseNumber = houseNumber || address.house_number || '';
            
            // Build main text
            let mainText = '';
            if (displayHouseNumber && address.road) {
              mainText = `${displayHouseNumber} ${address.road}`;
            } else if (displayHouseNumber && address.name) {
              mainText = `${displayHouseNumber} ${address.name}`;
            } else if (address.road) {
              mainText = address.road;
            } else if (address.name) {
              mainText = address.name;
            } else {
              mainText = item.display_name.split(',')[0] || '';
            }
            
            // Build secondary text
            let secondaryText = '';
            if (address.city && address.state) {
              secondaryText = `${address.city}, ${address.state}`;
              if (address.postcode) {
                secondaryText += `, ${address.postcode}`;
              }
            } else if (address.city) {
              secondaryText = address.city;
              if (address.postcode) {
                secondaryText += `, ${address.postcode}`;
              }
            } else if (address.postcode) {
              secondaryText = address.postcode;
            } else {
              secondaryText = item.display_name;
            }
            
            return {
              description: item.display_name,
              place_id: item.place_id || item.osm_id,
              structured_formatting: {
                main_text: mainText,
                secondary_text: secondaryText
              },
              address: {
                ...address,
                road: address.road || address.name || '',
                house_number: displayHouseNumber || ''
              },
              lat: item.lat,
              lon: item.lon
            };
          });

          return res.json({ predictions });
        }
      } else {
        console.error('LocationIQ API error:', response.status, response.statusText);
      }
    } catch (locationiqError) {
      console.error('LocationIQ API failed:', locationiqError.message);
    }

    return res.json({ predictions: [] });
    
  } catch (error) {
    console.error('Efficient address lookup error:', error);
    res.status(500).json({ error: 'Failed to lookup addresses' });
  }
});

// Category Management Routes
app.get('/api/categories', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const contacts = await getAccountContacts(accountId);
    
    // Extract unique categories from contacts
    const categories = [...new Set(contacts
      .map(c => c.category)
      .filter(Boolean)
      .sort()
    )];
    
    res.json(categories);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Campaign Reports API Routes
app.get('/api/campaigns/email/stats', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    // Check multiple possible data sources for email messages
    let emailMessages = [];
    
    // First, try the standard emailMessages field
    if (user.emailMessages && user.emailMessages.sent) {
      emailMessages = user.emailMessages.sent;

    }
    // If not found, check if messages are stored in the general messages array
    else if (user.messages) {
      emailMessages = user.messages.filter(msg => msg.type === 'email');

    }
    
    // Calculate stats from sent emails - count total recipients, not campaigns
    let totalSent = 0;
    let delivered = 0;
    let opened = 0;
    let bounced = 0;
    
    emailMessages.forEach(msg => {
      const recipients = Array.isArray(msg.to) ? msg.to : [msg.to];
      const recipientCount = recipients.length;
      
      totalSent += recipientCount;
      
      if (msg.status === 'delivered' || msg.status === 'sent') {
        delivered += recipientCount;
      }
      
      if (msg.opens && msg.opens.length > 0) {
        opened += msg.opens.length; // Count unique opens
      }
      
      if (msg.status === 'bounced') {
        bounced += recipientCount;
      }
    });

    res.json({
      totalSent,
      delivered,
      opened,
      bounced
    });
  } catch (error) {
    console.error('Email stats error:', error);
    res.status(400).json({ error: error.message });
  }
});

app.get('/api/campaigns/sms/stats', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    // Check multiple possible data sources for SMS messages
    let smsMessages = [];
    
    // First, try the standard smsMessages field
    if (user.smsMessages && user.smsMessages.sent) {
      smsMessages = user.smsMessages.sent;
    }
    // If not found, check if messages are stored in the general messages array
    else if (user.messages) {
      smsMessages = user.messages.filter(msg => msg.type === 'sms' || msg.type === 'outbound');
    }
    
    // Calculate stats from sent SMS - count total recipients, not campaigns
    let totalSent = 0;
    let delivered = 0;
    let failed = 0;
    let pending = 0;
    
    smsMessages.forEach(msg => {
      const recipients = Array.isArray(msg.to) ? msg.to : [msg.to];
      const recipientCount = recipients.length;
      
      totalSent += recipientCount;
      
      if (msg.status === 'delivered' || msg.status === 'sent') {
        delivered += recipientCount;
      }
      
      if (msg.status === 'failed') {
        failed += recipientCount;
      }
      
      if (msg.status === 'pending' || msg.status === 'queued') {
        pending += recipientCount;
      }
    });
    
    res.json({
      totalSent,
      delivered,
      failed,
      pending
    });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.get('/api/campaigns/email/recent', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    // Check multiple possible data sources for email messages
    let emailMessages = [];
    
    // First, try the standard emailMessages field
    if (user.emailMessages && user.emailMessages.sent) {
      emailMessages = user.emailMessages.sent;
    }
    // If not found, check if messages are stored in the general messages array
    else if (user.messages) {
      emailMessages = user.messages.filter(msg => msg.type === 'email');
    }
    
    // Get recent email campaigns (last 10)
    const recentCampaigns = emailMessages
      .sort((a, b) => new Date(b.timestamp || b.dateSent || 0) - new Date(a.timestamp || a.dateSent || 0))
      .slice(0, 10)
      .map(campaign => ({
        ...campaign,
        recipientCount: Array.isArray(campaign.to) ? campaign.to.length : 1,
        timestamp: campaign.timestamp || campaign.dateSent || new Date().toISOString()
      }));
    
    res.json(recentCampaigns);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.get('/api/campaigns/sms/recent', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    
    // Check multiple possible data sources for SMS messages
    let smsMessages = [];
    
    // First, try the standard smsMessages field
    if (user.smsMessages && user.smsMessages.sent) {
      smsMessages = user.smsMessages.sent;
    }
    // If not found, check if messages are stored in the general messages array
    else if (user.messages) {
      smsMessages = user.messages.filter(msg => msg.type === 'sms' || msg.type === 'outbound');
    }
    
    // Get recent SMS campaigns (last 10)
    const recentCampaigns = smsMessages
      .sort((a, b) => new Date(b.dateSent || b.timestamp || 0) - new Date(a.dateSent || a.timestamp || 0))
      .slice(0, 10)
      .map(campaign => ({
        ...campaign,
        recipientCount: Array.isArray(campaign.to) ? campaign.to.length : 1,
        dateSent: campaign.dateSent || campaign.timestamp || new Date().toISOString()
      }));
    
    res.json(recentCampaigns);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get response analytics for campaigns
app.get('/api/analytics/responses/:campaignId', auth, async (req, res) => {
  try {
    const { campaignId } = req.params;
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    
    const analytics = {
      campaignId: campaignId,
      smsResponses: [],
      emailResponses: [],
      voiceResponses: [],
      totalResponses: 0,
      responseTypes: {
        sms: { replies: 0, opt_outs: 0, clicks: 0 },
        email: { opens: 0, clicks: 0, replies: 0, bounces: 0 },
        voice: { digits: 0, completed: 0, failed: 0 }
      }
    };
    
    // Get SMS responses
    const smsResponsesPath = path.join(sharedDataPath, 'sms-responses.json');
    if (fs.existsSync(smsResponsesPath)) {
      const smsResponses = JSON.parse(fs.readFileSync(smsResponsesPath, 'utf8'));
      analytics.smsResponses = smsResponses.filter(response => response.campaignId === campaignId);
      
      // Count response types
      analytics.smsResponses.forEach(response => {
        if (response.responseType === 'reply') analytics.responseTypes.sms.replies++;
        else if (response.responseType === 'opt_out') analytics.responseTypes.sms.opt_outs++;
        else if (response.responseType === 'click') analytics.responseTypes.sms.clicks++;
      });
    }
    
    // Get email responses
    const emailResponsesPath = path.join(sharedDataPath, 'email-responses.json');
    if (fs.existsSync(emailResponsesPath)) {
      const emailResponses = JSON.parse(fs.readFileSync(emailResponsesPath, 'utf8'));
      analytics.emailResponses = emailResponses.filter(response => response.campaignId === campaignId);
      
      // Count response types
      analytics.emailResponses.forEach(response => {
        if (response.responseType === 'open') analytics.responseTypes.email.opens++;
        else if (response.responseType === 'click') analytics.responseTypes.email.clicks++;
        else if (response.responseType === 'reply') analytics.responseTypes.email.replies++;
        else if (response.responseType === 'bounce') analytics.responseTypes.email.bounces++;
      });
    }
    
    // Get voice responses
    const voiceResponsesPath = path.join(sharedDataPath, 'voice-responses.json');
    if (fs.existsSync(voiceResponsesPath)) {
      const voiceResponses = JSON.parse(fs.readFileSync(voiceResponsesPath, 'utf8'));
      analytics.voiceResponses = voiceResponses.filter(response => response.campaignId === campaignId);
      
      // Count response types
      analytics.voiceResponses.forEach(response => {
        if (response.digits) analytics.responseTypes.voice.digits++;
        if (response.status === 'completed') analytics.responseTypes.voice.completed++;
        else if (response.status === 'failed') analytics.responseTypes.voice.failed++;
      });
    }
    
    // Calculate total responses
    analytics.totalResponses = analytics.smsResponses.length + analytics.emailResponses.length + analytics.voiceResponses.length;
    
    res.json(analytics);
  } catch (error) {
    console.error('Response analytics error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get comprehensive analytics for dashboard
app.get('/api/analytics/dashboard', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const analytics = {
      campaigns: [],
      totalCampaigns: 0,
      totalMessages: 0,
      totalContacts: 0,
      totalTemplates: 0,
      teamMembers: [],
      recentActivity: []
    };
    
    if (user.userType !== 'app_owner' && user.accountId) {
      // Get shared data
      const contacts = await getAccountContacts(user.accountId);
      const templates = await getAccountTemplates(user.accountId);
      const campaigns = await getAccountCampaigns(user.accountId);
      
      analytics.totalContacts = contacts.length;
      analytics.totalTemplates = templates.length;
      
      // Get campaigns from shared-data folder
      const sharedDataPath = path.join(SHARED_DATA_DIR, user.accountId.toString());
      
      // Read email campaigns
      const emailCampaignsPath = path.join(sharedDataPath, 'email-campaigns.json');
      if (fs.existsSync(emailCampaignsPath)) {
        const emailCampaigns = JSON.parse(fs.readFileSync(emailCampaignsPath, 'utf8'));
        emailCampaigns.forEach(campaign => {
          // Calculate opens count for analytics dashboard (convert array to count)
          let opensCount = null;
          if (campaign.opens && Array.isArray(campaign.opens) && campaign.opens.length > 0) {
            const identityKeys = campaign.opens.map(open => open.email || open.recipient).filter(Boolean);
            opensCount = identityKeys.length > 0 ? new Set(identityKeys).size : campaign.opens.length;
          }
          
          analytics.campaigns.push({
            ...campaign,
            type: 'email',
            opens: opensCount, // Convert opens array to count for consistency
            createdBy: campaign.createdBy || user.accountId,
            createdByName: campaign.createdByName || 'Account Holder'
          });
        });
      }
      
      // Read SMS campaigns
      const smsCampaignsPath = path.join(sharedDataPath, 'sms-campaigns.json');
      if (fs.existsSync(smsCampaignsPath)) {
        const smsCampaigns = JSON.parse(fs.readFileSync(smsCampaignsPath, 'utf8'));
        smsCampaigns.forEach(campaign => {
          analytics.campaigns.push({
            ...campaign,
            type: 'sms',
            createdBy: campaign.createdBy || user.accountId,
            createdByName: campaign.createdByName || 'Account Holder'
          });
        });
      }
      
      // Fallback: Read SMS messages if no campaigns found
      if (analytics.campaigns.filter(c => c.type === 'sms').length === 0) {
        const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
        if (fs.existsSync(smsMessagesPath)) {
          const smsMessages = JSON.parse(fs.readFileSync(smsMessagesPath, 'utf8'));
          // Filter for outbound messages only and group by timestamp/body for campaigns
          const outboundMessages = smsMessages.filter(msg => msg.type === 'outbound');
          
          // Group messages by similar timestamp and body to form campaigns
          const messageGroups = {};
          outboundMessages.forEach(msg => {
            const key = `${msg.body}-${new Date(msg.timestamp).toDateString()}`;
            if (!messageGroups[key]) {
              messageGroups[key] = {
                id: msg.id,
                body: msg.body,
                timestamp: msg.timestamp,
                messages: [],
                recipientCount: 0
              };
            }
            messageGroups[key].messages.push(msg);
            messageGroups[key].recipientCount += msg.to ? msg.to.length : 1;
          });
          
          // Convert grouped messages to campaigns
          Object.values(messageGroups).forEach(campaign => {
            analytics.campaigns.push({
              id: campaign.id,
              type: 'sms',
              body: campaign.body,
              subject: campaign.body, // Use body as subject for SMS
              timestamp: campaign.timestamp,
              recipientCount: campaign.recipientCount,
              totalAttempted: campaign.recipientCount,
              createdBy: user.accountId,
              createdByName: 'Account Holder',
              status: 'sent'
            });
          });
        }
      }
      
      // Read voice campaigns
      const voiceCampaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
      if (fs.existsSync(voiceCampaignsPath)) {
        const voiceCampaigns = JSON.parse(fs.readFileSync(voiceCampaignsPath, 'utf8'));
        
        // Read voice calls to get actual analytics data
        const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');
        let voiceCalls = [];
        if (fs.existsSync(voiceCallsPath)) {
          try {
            voiceCalls = JSON.parse(fs.readFileSync(voiceCallsPath, 'utf8'));
          } catch (error) {
            console.error('Error reading voice calls for analytics:', error);
          }
        }
        
        voiceCampaigns.forEach(campaign => {
          // Calculate analytics from actual call data
          const campaignCalls = voiceCalls.filter(call => call.campaignId === campaign.id);
          const deliveredCalls = campaignCalls.filter(call => call.status === 'completed').length;
          const failedCalls = campaignCalls.filter(call => call.status === 'failed').length;
          const busyCalls = campaignCalls.filter(call => call.status === 'busy').length;
          const noAnswerCalls = campaignCalls.filter(call => call.status === 'no-answer').length;
          const totalAttempted = campaignCalls.length;
          
          analytics.campaigns.push({
            ...campaign,
            type: 'voice',
            createdBy: campaign.createdBy || user.accountId,
            createdByName: campaign.createdByName || 'Account Holder',
            recipientCount: campaign.contactIds?.length || campaign.recipientCount || 0,
            totalAttempted: totalAttempted || campaign.recipientCount || 0,
            deliveredCount: deliveredCalls,
            bouncedCount: failedCalls,
            failedCount: failedCalls,
            busyCount: busyCalls,
            noAnswerCount: noAnswerCalls,
            timestamp: campaign.timestamp || campaign.startedAt || campaign.createdAt
          });
        });
      }
      
      // Read voice messages
      const voiceMessagesPath = path.join(sharedDataPath, 'voice-messages.json');
      if (fs.existsSync(voiceMessagesPath)) {
        const voiceMessages = JSON.parse(fs.readFileSync(voiceMessagesPath, 'utf8'));
        voiceMessages.forEach(message => {
          analytics.campaigns.push({
            ...message,
            type: 'voice',
            createdBy: message.createdBy || user.accountId,
            createdByName: message.createdByName || 'Account Holder',
            recipientCount: message.contactIds?.length || 0,
            timestamp: message.timestamp || message.startedAt || message.createdAt
          });
        });
      }
      
      if (user.userType === 'account_holder') {
        // Account holders see all team member campaigns
        const teamMembers = await getTeamMembers(user.accountId);
        analytics.teamMembers = teamMembers;
      }
    } else {
      // For app owners, use their own data from shared-data folder
      const sharedDataPath = path.join(SHARED_DATA_DIR, user.id.toString());
      
      // Read email campaigns
      const emailCampaignsPath = path.join(sharedDataPath, 'email-campaigns.json');
      if (fs.existsSync(emailCampaignsPath)) {
        const emailCampaigns = JSON.parse(fs.readFileSync(emailCampaignsPath, 'utf8'));
        emailCampaigns.forEach(campaign => {
          // Calculate opens count for analytics dashboard (convert array to count)
          let opensCount = null;
          if (campaign.opens && Array.isArray(campaign.opens) && campaign.opens.length > 0) {
            const identityKeys = campaign.opens.map(open => open.email || open.recipient).filter(Boolean);
            opensCount = identityKeys.length > 0 ? new Set(identityKeys).size : campaign.opens.length;
          }
          
          analytics.campaigns.push({
            ...campaign,
            type: 'email',
            opens: opensCount, // Convert opens array to count for consistency
            createdBy: user.id,
            createdByName: 'You'
          });
        });
      }
      
      // Read SMS campaigns
      const smsCampaignsPath = path.join(sharedDataPath, 'sms-campaigns.json');
      if (fs.existsSync(smsCampaignsPath)) {
        const smsCampaigns = JSON.parse(fs.readFileSync(smsCampaignsPath, 'utf8'));
        smsCampaigns.forEach(campaign => {
          analytics.campaigns.push({
            ...campaign,
            type: 'sms',
            createdBy: user.id,
            createdByName: 'You'
          });
        });
      }
      
      // Fallback: Read SMS messages if no campaigns found
      if (analytics.campaigns.filter(c => c.type === 'sms').length === 0) {
        const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
        if (fs.existsSync(smsMessagesPath)) {
          const smsMessages = JSON.parse(fs.readFileSync(smsMessagesPath, 'utf8'));
          // Filter for outbound messages only and group by timestamp/body for campaigns
          const outboundMessages = smsMessages.filter(msg => msg.type === 'outbound');
          
          // Group messages by similar timestamp and body to form campaigns
          const messageGroups = {};
          outboundMessages.forEach(msg => {
            const key = `${msg.body}-${new Date(msg.timestamp).toDateString()}`;
            if (!messageGroups[key]) {
              messageGroups[key] = {
                id: msg.id,
                body: msg.body,
                timestamp: msg.timestamp,
                messages: [],
                recipientCount: 0
              };
            }
            messageGroups[key].messages.push(msg);
            messageGroups[key].recipientCount += msg.to ? msg.to.length : 1;
          });
          
          // Convert grouped messages to campaigns
          Object.values(messageGroups).forEach(campaign => {
            analytics.campaigns.push({
              id: campaign.id,
              type: 'sms',
              body: campaign.body,
              subject: campaign.body, // Use body as subject for SMS
              timestamp: campaign.timestamp,
              recipientCount: campaign.recipientCount,
              totalAttempted: campaign.recipientCount,
              createdBy: user.id,
              createdByName: 'You',
              status: 'sent'
            });
          });
        }
      }
      
      // Read voice campaigns
      const voiceCampaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
      if (fs.existsSync(voiceCampaignsPath)) {
        const voiceCampaigns = JSON.parse(fs.readFileSync(voiceCampaignsPath, 'utf8'));
        
        // Read voice calls to get actual analytics data
        const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');
        let voiceCalls = [];
        if (fs.existsSync(voiceCallsPath)) {
          try {
            voiceCalls = JSON.parse(fs.readFileSync(voiceCallsPath, 'utf8'));
          } catch (error) {
            console.error('Error reading voice calls for analytics:', error);
          }
        }
        
        voiceCampaigns.forEach(campaign => {
          // Calculate analytics from actual call data
          const campaignCalls = voiceCalls.filter(call => call.campaignId === campaign.id);
          const deliveredCalls = campaignCalls.filter(call => call.status === 'completed').length;
          const failedCalls = campaignCalls.filter(call => call.status === 'failed').length;
          const busyCalls = campaignCalls.filter(call => call.status === 'busy').length;
          const noAnswerCalls = campaignCalls.filter(call => call.status === 'no-answer').length;
          const totalAttempted = campaignCalls.length;
          
          analytics.campaigns.push({
            ...campaign,
            type: 'voice',
            createdBy: user.id,
            createdByName: 'You',
            recipientCount: campaign.contactIds?.length || campaign.recipientCount || 0,
            totalAttempted: totalAttempted || campaign.recipientCount || 0,
            deliveredCount: deliveredCalls,
            bouncedCount: failedCalls,
            failedCount: failedCalls,
            busyCount: busyCalls,
            noAnswerCount: noAnswerCalls,
            timestamp: campaign.timestamp || campaign.startedAt || campaign.createdAt
          });
        });
      }
      
      // Read voice messages
      const voiceMessagesPath = path.join(sharedDataPath, 'voice-messages.json');
      if (fs.existsSync(voiceMessagesPath)) {
        const voiceMessages = JSON.parse(fs.readFileSync(voiceMessagesPath, 'utf8'));
        voiceMessages.forEach(message => {
          analytics.campaigns.push({
            ...message,
            type: 'voice',
            createdBy: user.id,
            createdByName: 'You',
            recipientCount: message.contactIds?.length || 0,
            timestamp: message.timestamp || message.startedAt || message.createdAt
          });
        });
      }
      
      // Get contacts and templates from shared-data
      const contacts = await getAccountContacts(user.id);
      const templates = await getAccountTemplates(user.id);
      analytics.totalContacts = contacts.length;
      analytics.totalTemplates = templates.length;
      
      // Get phone numbers from shared-data for app owners
      const appOwnerSharedDataPath = path.join(SHARED_DATA_DIR, user.id.toString());
      const appOwnerPhoneNumbersPath = path.join(appOwnerSharedDataPath, 'phoneNumbers.json');
      if (fs.existsSync(appOwnerPhoneNumbersPath)) {
        const phoneNumbers = JSON.parse(fs.readFileSync(appOwnerPhoneNumbersPath, 'utf8'));
        // Note: This is just for loading data, not modifying the response
      }
    }
    
    // Sort campaigns by timestamp
    analytics.campaigns.sort((a, b) => new Date(b.timestamp || b.dateSent) - new Date(a.timestamp || a.dateSent));
    analytics.totalCampaigns = analytics.campaigns.length;
    analytics.totalMessages = analytics.campaigns.reduce((sum, campaign) => sum + (campaign.recipientCount || 0), 0);
    
    res.json(analytics);
  } catch (error) {
    console.error('Dashboard analytics error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get All Campaigns API
app.get('/api/campaigns/all', auth, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const allCampaigns = [];
    const seenIds = new Set(); // Track seen campaign IDs to prevent duplicates

    // Get email campaigns from appropriate location
    let emailMessages = [];
    
    if (user.userType !== 'app_owner' && user.accountId) {
      // For team members and account holders, get campaigns from individual data structure
      const individualDataPath = path.join(__dirname, 'data', 'individual-data', user.id.toString());
      const messagesPath = path.join(individualDataPath, 'messages.json');
      
      if (fs.existsSync(messagesPath)) {
        const data = fs.readFileSync(messagesPath, 'utf8');
        const individualMessages = JSON.parse(data);
        // Messages are stored as flat array with type field
        if (Array.isArray(individualMessages)) {
          emailMessages = individualMessages.filter(msg => msg.type === 'email' && msg.recipientCount);
        }

      }
      
      // For account holders, also get campaigns from all team members
      if (user.userType === 'account_holder') {
        const teamMembers = await getTeamMembers(user.accountId);
        for (const member of teamMembers) {
          if (member.id !== user.id) { // Don't duplicate own campaigns
            const memberDataPath = path.join(__dirname, 'data', 'individual-data', member.id.toString());
            const memberMessagesPath = path.join(memberDataPath, 'messages.json');
            
            if (fs.existsSync(memberMessagesPath)) {
              const memberData = fs.readFileSync(memberMessagesPath, 'utf8');
              const memberMessages = JSON.parse(memberData);
              let memberEmailMessages = [];
              if (Array.isArray(memberMessages)) {
                memberEmailMessages = memberMessages.filter(msg => msg.type === 'email' && msg.recipientCount);
              }
              emailMessages = emailMessages.concat(memberEmailMessages);

            }
          }
        }
      }
    } else {
      // For app owners, use their own user file
      if (user.emailMessages && user.emailMessages.sent) {
        emailMessages = user.emailMessages.sent;

      } else if (user.messages) {
        emailMessages = user.messages.filter(msg => msg.type === 'email');

      }
    }
    
    emailMessages.forEach(campaign => {
      if (!campaign.id || seenIds.has(campaign.id)) {

        return;
      }
      
      seenIds.add(campaign.id);
      const recipients = Array.isArray(campaign.to) ? campaign.to : [campaign.to];
      
      allCampaigns.push({
        id: campaign.id,
        type: 'email',
        subject: campaign.subject || 'No Subject',
        body: campaign.body || '',
        recipientCount: campaign.totalAttempted || recipients.length, // Use totalAttempted if available
        totalAttempted: campaign.totalAttempted || recipients.length, // Include for analytics
        timestamp: campaign.timestamp,
        status: campaign.status || 'sent'
      });
      
      });
    
    // Get SMS campaigns from appropriate location
    let smsMessages = [];
    
    if (user.userType !== 'app_owner' && user.accountId) {
      // For team members and account holders, get campaigns from individual data structure
      const individualDataPath = path.join(__dirname, 'data', 'individual-data', user.id.toString());
      const messagesPath = path.join(individualDataPath, 'messages.json');
      
      if (fs.existsSync(messagesPath)) {
        const data = fs.readFileSync(messagesPath, 'utf8');
        const individualMessages = JSON.parse(data);
        // Messages are stored as flat array with type field
        if (Array.isArray(individualMessages)) {
          smsMessages = individualMessages.filter(msg => (msg.type === 'sms' || msg.type === 'outbound') && msg.recipientCount);
        }

      }
      
      // For account holders, also get campaigns from all team members
      if (user.userType === 'account_holder') {
        const teamMembers = await getTeamMembers(user.accountId);
        for (const member of teamMembers) {
          if (member.id !== user.id) { // Don't duplicate own campaigns
            const memberDataPath = path.join(__dirname, 'data', 'individual-data', member.id.toString());
            const memberMessagesPath = path.join(memberDataPath, 'messages.json');
            
            if (fs.existsSync(memberMessagesPath)) {
              const memberData = fs.readFileSync(memberMessagesPath, 'utf8');
              const memberMessages = JSON.parse(memberData);
              let memberSmsMessages = [];
              if (Array.isArray(memberMessages)) {
                memberSmsMessages = memberMessages.filter(msg => (msg.type === 'sms' || msg.type === 'outbound') && msg.recipientCount);
              }
              smsMessages = smsMessages.concat(memberSmsMessages);

            }
          }
        }
      }
    } else {
      // For app owners, use their own user file
      if (user.smsMessages && user.smsMessages.sent) {
        smsMessages = user.smsMessages.sent;

      } else if (user.messages) {
        smsMessages = user.messages.filter(msg => msg.type === 'sms' || msg.type === 'outbound');

      }
    }
    
    smsMessages.forEach(campaign => {
      if (!campaign.id || seenIds.has(campaign.id)) {

        return;
      }
      
      seenIds.add(campaign.id);
      const recipients = Array.isArray(campaign.to) ? campaign.to : [campaign.to];
      
      allCampaigns.push({
        id: campaign.id,
        type: 'sms',
        body: campaign.body || '',
        recipientCount: recipients.length,
        dateSent: campaign.dateSent || campaign.timestamp,
        status: campaign.status || 'sent'
      });

    });
    
    // Get voice campaigns from user files (still stored there, not migrated to individual data yet)
    let voiceCampaigns = [];
    
    if (user.userType !== 'app_owner' && user.accountId) {
      // For team members and account holders, get voice campaigns from all team members
      const teamMembers = await getTeamMembers(user.accountId);
      
      if (user.userType === 'account_holder') {
        // Account holders see all team member voice campaigns
        for (const member of teamMembers) {
          const memberUser = await findUserById(member.id);
          if (memberUser?.voiceCampaigns) {
            voiceCampaigns = voiceCampaigns.concat(memberUser.voiceCampaigns);
          }
        }
      } else {
        // Team members only see their own voice campaigns
        if (user.voiceCampaigns) {
          voiceCampaigns = user.voiceCampaigns;
        }
      }
    } else {
      // App owners use their own voice campaigns
      if (user.voiceCampaigns) {
        voiceCampaigns = user.voiceCampaigns;
      }
    }
    
    voiceCampaigns.forEach(campaign => {
      if (!campaign.id || seenIds.has(campaign.id)) {

        return;
      }
      
      seenIds.add(campaign.id);
      const recipientCount = campaign.contactIds?.length || 0;
      
      allCampaigns.push({
        id: campaign.id,
        type: 'voice',
        subject: campaign.name || 'Voice Campaign',
        body: campaign.message || campaign.name || 'Voice Campaign',
        recipientCount: recipientCount,
        timestamp: campaign.timestamp || campaign.startedAt || campaign.createdAt,
        status: campaign.status || 'sent'
      });

    });
    
    // Sort by date (most recent first)
    allCampaigns.sort((a, b) => new Date(b.timestamp || b.dateSent) - new Date(a.timestamp || a.dateSent));

    res.json(allCampaigns);
  } catch (error) {
    console.error('Get all campaigns error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get Individual Campaign Details API
app.get('/api/campaigns/:campaignId', auth, async (req, res) => {
  try {
    const { campaignId } = req.params;
    const user = await findUserById(req.user.id);

    // Search in email campaigns - handle both old and new data structures
    let emailMessages = [];

    // First try to read from shared-data folder - check both email-campaigns.json and email-messages.json
    const emailAccountId = user.accountId || user.id;
    const emailSharedDataPath = path.join(SHARED_DATA_DIR, emailAccountId.toString());
    const emailCampaignsPath = path.join(emailSharedDataPath, 'email-campaigns.json');
    const emailMessagesPath = path.join(emailSharedDataPath, 'email-messages.json');

    // Try email-campaigns.json first (preferred location for campaign data)
    if (fs.existsSync(emailCampaignsPath)) {
      try {
        const emailCampaignsData = JSON.parse(fs.readFileSync(emailCampaignsPath, 'utf8'));
        emailMessages = emailCampaignsData;

        // Don't filter email campaigns for team members - they should see all account campaigns
        // Team members can access all campaigns in their account
      } catch (error) {
        console.error('Error reading email campaigns from shared-data:', error);
      }
    }

    // Also check email-messages.json for any campaigns that might be there
    if (fs.existsSync(emailMessagesPath)) {
      try {
        const emailMessagesData = JSON.parse(fs.readFileSync(emailMessagesPath, 'utf8'));
        const emailCampaignsFromMessages = emailMessagesData.filter(msg => msg.type === 'email');

        // Don't filter email messages for team members - they should see all account campaigns
        let filteredMessages = emailCampaignsFromMessages;

        emailMessages = emailMessages.concat(filteredMessages);
      } catch (error) {
        console.error('Error reading email messages from shared-data:', error);
      }
    }

    // Fallback to old user file structure if shared-data doesn't exist
    if (emailMessages.length === 0) {
      if (user.userType === 'app_owner') {
        // App owners: use their own user file
        if (user.emailMessages && user.emailMessages.sent) {
          emailMessages = user.emailMessages.sent;
        } else if (user.messages) {
          emailMessages = user.messages.filter(msg => msg.type === 'email');
        }
      } else if (user.accountId) {
        // Team members and account holders: search in individual data for all team members
        const teamMembers = await getTeamMembers(user.accountId);

        for (const member of teamMembers) {
          const individualDataPath = path.join(__dirname, 'data', 'individual-data', member.id.toString());
          const messagesPath = path.join(individualDataPath, 'messages.json');

          if (fs.existsSync(messagesPath)) {
            const data = fs.readFileSync(messagesPath, 'utf8');
            const individualMessages = JSON.parse(data);

            if (Array.isArray(individualMessages)) {
              const memberEmailMessages = individualMessages.filter(msg => msg.type === 'email');
              emailMessages = emailMessages.concat(memberEmailMessages);
            }
          }
        }

        // Also check old user file structure as fallback
        if (user.emailMessages && user.emailMessages.sent) {
          emailMessages = emailMessages.concat(user.emailMessages.sent);
        } else if (user.messages) {
          emailMessages = emailMessages.concat(user.messages.filter(msg => msg.type === 'email'));
        }
      }
    }
    
    let emailCampaign = emailMessages.find(campaign => campaign.id === campaignId);
    if (emailCampaign) {
      const recipients = Array.isArray(emailCampaign.to) ? emailCampaign.to : [emailCampaign.to];
      
      // Calculate delivered and failed counts based on the actual data structure
      let deliveredCount = null;
      let bouncedCount = null;
      let opensCount = null;
      let invalidCount = 0;
      
      // Count invalid emails if they exist
      if (emailCampaign.invalidEmails && emailCampaign.invalidEmails.length > 0) {
        invalidCount = emailCampaign.invalidEmails.length;
      }
      
      if (emailCampaign.status === 'failed') {
        // If the entire campaign failed, all attempted recipients failed
        deliveredCount = 0;
        bouncedCount = emailCampaign.totalAttempted || recipients.length;
        opensCount = 0; // No opens if delivery failed
      } else if (emailCampaign.status === 'partial') {
        // If partial failure, use the stored failed counts plus invalid emails
        deliveredCount = emailCampaign.successfulSends || 0;
        bouncedCount = (emailCampaign.failedSends || 0) + invalidCount; // Include invalid emails in bounced count
        // Only show opens if we have delivery data
        const opens = emailCampaign.opens || [];
        if (opens.length > 0) {
          const identityKeys = opens.map(open => open.email || open.recipient).filter(Boolean);
          opensCount = identityKeys.length > 0 ? new Set(identityKeys).size : opens.length;
        } else {
          opensCount = 0;
        }
      } else if (emailCampaign.successfulSends !== undefined) {
        // If we have specific success/failure data, use it plus invalid emails
        deliveredCount = emailCampaign.successfulSends;
        bouncedCount = (emailCampaign.failedSends || 0) + invalidCount; // Include invalid emails in bounced count
        // Only show opens if we have delivery data
        const opens = emailCampaign.opens || [];
        if (opens.length > 0) {
          const identityKeys = opens.map(open => open.email || open.recipient).filter(Boolean);
          opensCount = identityKeys.length > 0 ? new Set(identityKeys).size : opens.length;
        } else {
          opensCount = 0;
        }
      } else {
        // For older campaigns without specific data, show N/A for all tracking data
        deliveredCount = null;
        bouncedCount = null;
        opensCount = null; // Show N/A for opens too since we don't have delivery confirmation
      }

      const campaign = {
        id: emailCampaign.id,
        type: 'email',
        subject: emailCampaign.subject || 'No Subject',
        body: emailCampaign.body || '',
        recipientCount: recipients.length, // Keep for backward compatibility
        totalAttempted: emailCampaign.totalAttempted || recipients.length, // Total emails attempted
        timestamp: emailCampaign.timestamp,
        status: emailCampaign.status || 'sent',
        opens: opensCount, // Use consistent opens count
        deliveredCount: deliveredCount,
        bouncedCount: bouncedCount,
        invalidEmails: emailCampaign.invalidEmails || [] // Include invalid emails info
      };
      return res.json(campaign);
    }
    
    // Search in SMS campaigns - handle both old and new data structures
    let smsMessages = [];

    // First try to read from shared-data folder - check both sms-campaigns.json and sms-messages.json
    const smsAccountId = user.accountId || user.id;
    const smsSharedDataPath = path.join(SHARED_DATA_DIR, smsAccountId.toString());
    const smsCampaignsPath = path.join(smsSharedDataPath, 'sms-campaigns.json');
    const smsMessagesPath = path.join(smsSharedDataPath, 'sms-messages.json');

    // Try sms-campaigns.json first (preferred location for campaign data)
    if (fs.existsSync(smsCampaignsPath)) {
      try {
        const smsCampaignsData = JSON.parse(fs.readFileSync(smsCampaignsPath, 'utf8'));
        smsMessages = smsCampaignsData;

        // Filter for team members if not account holder or app owner
        if (user.userType !== 'account_holder' && user.userType !== 'app_owner') {
          smsMessages = smsMessages.filter(msg => msg.userId === user.id);
        }
      } catch (error) {
        console.error('Error reading SMS campaigns from shared-data:', error);
      }
    }

    // Also check sms-messages.json for any campaigns that might be there
    if (fs.existsSync(smsMessagesPath)) {
      try {
        const smsMessagesData = JSON.parse(fs.readFileSync(smsMessagesPath, 'utf8'));
        const smsCampaignsFromMessages = smsMessagesData.filter(msg => msg.type === 'sms' || msg.type === 'outbound');

        // Filter for team members if not account holder or app owner
        let filteredMessages = smsCampaignsFromMessages;
        if (user.userType !== 'account_holder' && user.userType !== 'app_owner') {
          filteredMessages = smsCampaignsFromMessages.filter(msg => msg.userId === user.id);
        }

        smsMessages = smsMessages.concat(filteredMessages);
      } catch (error) {
        console.error('Error reading SMS messages from shared-data:', error);
      }
    }

    // Fallback to old user file structure if shared-data doesn't exist
    if (smsMessages.length === 0) {
      if (user.userType === 'app_owner') {
        // App owners: use their own user file
        if (user.smsMessages && user.smsMessages.sent) {
          smsMessages = user.smsMessages.sent;
        } else if (user.messages) {
          smsMessages = user.messages.filter(msg => msg.type === 'sms' || msg.type === 'outbound');
        }
      } else if (user.accountId) {
        // Team members and account holders: search in individual data for all team members
        const teamMembers = await getTeamMembers(user.accountId);

        for (const member of teamMembers) {
          const individualDataPath = path.join(__dirname, 'data', 'individual-data', member.id.toString());
          const messagesPath = path.join(individualDataPath, 'messages.json');

          if (fs.existsSync(messagesPath)) {
            const data = fs.readFileSync(messagesPath, 'utf8');
            const individualMessages = JSON.parse(data);

            if (Array.isArray(individualMessages)) {
              const memberSmsMessages = individualMessages.filter(msg => msg.type === 'sms' || msg.type === 'outbound');
              smsMessages = smsMessages.concat(memberSmsMessages);
            }
          }
        }

        // Also check old user file structure as fallback
        if (user.smsMessages && user.smsMessages.sent) {
          smsMessages = smsMessages.concat(user.smsMessages.sent);
        } else if (user.messages) {
          smsMessages = smsMessages.concat(user.messages.filter(msg => msg.type === 'sms' || msg.type === 'outbound'));
        }
      }
    }
    
    let smsCampaign = smsMessages.find(campaign => campaign.id === campaignId);
    if (smsCampaign) {
      const recipients = Array.isArray(smsCampaign.to) ? smsCampaign.to : [smsCampaign.to];
      
      // Calculate more accurate statistics
      const deliveredCount = smsCampaign.status === 'delivered' || smsCampaign.status === 'sent' ? recipients.length : 0;
      const failedCount = smsCampaign.status === 'failed' ? recipients.length : 0;

      const campaign = {
        id: smsCampaign.id,
        type: 'sms',
        body: smsCampaign.body || '',
        recipientCount: recipients.length,
        dateSent: smsCampaign.dateSent || smsCampaign.timestamp,
        status: smsCampaign.status || 'sent',
        deliveredCount: deliveredCount,
        bouncedCount: failedCount // Use consistent naming for failed/bounced
      };
      return res.json(campaign);
    }
    
    // Search in voice campaigns - handle both old and new data structures
    let voiceCampaigns = [];

    // First try to read from shared-data folder
    const voiceAccountId = user.accountId || user.id;
    const voiceSharedDataPath = path.join(SHARED_DATA_DIR, voiceAccountId.toString());
    const voiceCampaignsPath = path.join(voiceSharedDataPath, 'voice-campaigns.json');

    if (fs.existsSync(voiceCampaignsPath)) {
      try {
        const voiceCampaignsData = JSON.parse(fs.readFileSync(voiceCampaignsPath, 'utf8'));
        voiceCampaigns = voiceCampaignsData;

        // Don't filter voice campaigns for team members - they should see all account campaigns
        // Team members can access all campaigns in their account
      } catch (error) {
        console.error('Error reading voice campaigns from shared-data:', error);
      }
    }

    // Fallback to old user file structure if shared-data doesn't exist
    if (voiceCampaigns.length === 0) {
      if (user.userType === 'app_owner') {
        // App owners: use their own user file
        if (user.voiceCampaigns) {
          voiceCampaigns = user.voiceCampaigns;
        }
      } else if (user.accountId) {
        // Team members and account holders: search in voice campaigns from all team members
        const teamMembers = await getTeamMembers(user.accountId);

        for (const member of teamMembers) {
          const memberUser = await findUserById(member.id);
          if (memberUser?.voiceCampaigns) {
            voiceCampaigns = voiceCampaigns.concat(memberUser.voiceCampaigns);
          }
        }

        // Also check own voice campaigns as fallback
        if (user.voiceCampaigns) {
          voiceCampaigns = voiceCampaigns.concat(user.voiceCampaigns);
        }
      }
    }
    
    let voiceCampaign = voiceCampaigns.find(campaign => campaign.id === campaignId);
    if (voiceCampaign) {
      const recipientCount = voiceCampaign.contactIds?.length || 0;

      const campaign = {
        id: voiceCampaign.id,
        type: 'voice',
        subject: voiceCampaign.name || 'Voice Campaign',
        body: voiceCampaign.message || voiceCampaign.name || 'Voice Campaign',
        recipientCount: recipientCount,
        totalAttempted: voiceCampaign.totalAttempted || recipientCount,
        timestamp: voiceCampaign.timestamp || voiceCampaign.startedAt || voiceCampaign.createdAt,
        status: voiceCampaign.status || 'sent',
        voice: voiceCampaign.voice,
        language: voiceCampaign.language,
        name: voiceCampaign.name,
        // Analytics fields for dashboard
        deliveredCount: voiceCampaign.deliveredCount !== undefined ? voiceCampaign.deliveredCount : (voiceCampaign.completedCalls || 0),
        bouncedCount: voiceCampaign.bouncedCount !== undefined ? voiceCampaign.bouncedCount : (voiceCampaign.failedCalls || 0),
        failedCount: voiceCampaign.failedCount !== undefined ? voiceCampaign.failedCount : (voiceCampaign.failedCalls || 0),
        completedCalls: voiceCampaign.completedCalls || 0,
        totalCalls: voiceCampaign.totalCalls || recipientCount
      };
      return res.json(campaign);
    }

    res.status(404).json({ error: 'Campaign not found' });
  } catch (error) {
    console.error('Get campaign details error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Campaign Search API (keeping for backward compatibility)
app.get('/api/campaigns/search', auth, async (req, res) => {
  try {
    const { query } = req.query;
    const user = await findUserById(req.user.id);
    
    if (!query) {
      return res.status(400).json({ error: 'Query parameter is required' });
    }

    const searchTerm = query.toLowerCase().trim();
    const results = [];
    
    // Search email campaigns
    let emailMessages = [];
    if (user.emailMessages && user.emailMessages.sent) {
      emailMessages = user.emailMessages.sent;
    } else if (user.messages) {
      emailMessages = user.messages.filter(msg => msg.type === 'email');
    }
    
    emailMessages.forEach(campaign => {
      const subject = campaign.subject || '';
      const body = campaign.body || '';
      
      if (subject.toLowerCase().includes(searchTerm) || body.toLowerCase().includes(searchTerm)) {
        const recipients = Array.isArray(campaign.to) ? campaign.to : [campaign.to];
        results.push({
          id: campaign.id,
          type: 'email',
          subject: campaign.subject,
          body: campaign.body,
          recipientCount: recipients.length,
          timestamp: campaign.timestamp,
          status: campaign.status || 'sent',
          opens: campaign.opens || [],
          deliveredCount: campaign.status === 'delivered' || campaign.status === 'sent' ? recipients.length : 0,
          bouncedCount: campaign.status === 'bounced' ? recipients.length : 0
        });
      }
    });
    
    // Search SMS campaigns
    let smsMessages = [];
    if (user.smsMessages && user.smsMessages.sent) {
      smsMessages = user.smsMessages.sent;
    } else if (user.messages) {
      smsMessages = user.messages.filter(msg => msg.type === 'sms' || msg.type === 'outbound');
    }
    
    smsMessages.forEach(campaign => {
      const body = campaign.body || '';
      
      if (body.toLowerCase().includes(searchTerm)) {
        const recipients = Array.isArray(campaign.to) ? campaign.to : [campaign.to];
        results.push({
          id: campaign.id,
          type: 'sms',
          body: campaign.body,
          recipientCount: recipients.length,
          dateSent: campaign.dateSent || campaign.timestamp,
          status: campaign.status || 'sent',
          deliveredCount: campaign.status === 'delivered' || campaign.status === 'sent' ? recipients.length : 0,
          failedCount: campaign.status === 'failed' ? recipients.length : 0
        });
      }
    });
    
    // Sort by date (most recent first)
    results.sort((a, b) => new Date(b.timestamp || b.dateSent) - new Date(a.timestamp || a.dateSent));

    res.json(results);
  } catch (error) {
    console.error('Campaign search error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Contact Search for Campaign Status
app.get('/api/contacts/search-campaign-status', auth, async (req, res) => {
  try {
    const { query } = req.query;
    const user = await findUserById(req.user.id);
    
    if (!query) {
      return res.status(400).json({ error: 'Query parameter is required' });
    }

    // Get contacts from shared-data structure
    const contacts = await getAccountContacts(user.accountId || user.id);

    // Get email messages from shared-data structure
    let emailMessages = [];
    if (user.userType !== 'app_owner' && user.accountId) {
      const sharedDataPath = path.join(SHARED_DATA_DIR, user.accountId.toString());
      const emailMessagesPath = path.join(sharedDataPath, 'email-messages.json');
      if (fs.existsSync(emailMessagesPath)) {
        emailMessages = JSON.parse(fs.readFileSync(emailMessagesPath, 'utf8'));

      }
    } else {
      const sharedDataPath = path.join(SHARED_DATA_DIR, user.id.toString());
      const emailMessagesPath = path.join(sharedDataPath, 'email-messages.json');
      if (fs.existsSync(emailMessagesPath)) {
        emailMessages = JSON.parse(fs.readFileSync(emailMessagesPath, 'utf8'));

      }
    }
    
    // Get SMS messages from shared-data structure
    let smsMessages = [];
    if (user.userType !== 'app_owner' && user.accountId) {
      const sharedDataPath = path.join(SHARED_DATA_DIR, user.accountId.toString());
      const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
      if (fs.existsSync(smsMessagesPath)) {
        smsMessages = JSON.parse(fs.readFileSync(smsMessagesPath, 'utf8'));

      }
    } else {
      const sharedDataPath = path.join(SHARED_DATA_DIR, user.id.toString());
      const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
      if (fs.existsSync(smsMessagesPath)) {
        smsMessages = JSON.parse(fs.readFileSync(smsMessagesPath, 'utf8'));

      }
    }
    
    // Search for contacts matching the query
    const matchingContacts = contacts.filter(contact => {
      const searchTerm = query.toLowerCase().trim();
      
      // More specific matching - prioritize exact matches
      const exactFirstNameMatch = contact.firstName && contact.firstName.toLowerCase() === searchTerm;
      const exactLastNameMatch = contact.lastName && contact.lastName.toLowerCase() === searchTerm;
      const exactEmailMatch = contact.email && contact.email.toLowerCase() === searchTerm;
      
      // SUPER STRICT matching - only exact matches or complete word matches
      const firstNameMatch = contact.firstName && (
        contact.firstName.toLowerCase() === searchTerm ||
        contact.firstName.toLowerCase().split(' ').some(word => word === searchTerm)
      );
      const lastNameMatch = contact.lastName && (
        contact.lastName.toLowerCase() === searchTerm ||
        contact.lastName.toLowerCase().split(' ').some(word => word === searchTerm)
      );
      
      // For email, only match if it's an exact match
      const emailMatch = contact.email && contact.email.toLowerCase() === searchTerm;
      
      // For phone, only match if it's an exact match
      const phoneMatch = contact.phone && contact.phone.replace(/\D/g, '') === searchTerm.replace(/\D/g, '');
      
      // Only exact matches or complete word matches
      const exactMatch = exactFirstNameMatch || exactLastNameMatch || exactEmailMatch;
      const wordMatch = firstNameMatch || lastNameMatch || emailMatch || phoneMatch;
      
      const matches = exactMatch || wordMatch;
      
      if (matches) {
        }
      
      return matches;
    });
    
    // Sort results to show exact matches first, then limit to 20 results
    const sortedContacts = matchingContacts.sort((a, b) => {
      const aExact = (a.firstName && a.firstName.toLowerCase() === query.toLowerCase()) ||
                     (a.lastName && a.lastName.toLowerCase() === query.toLowerCase()) ||
                     (a.email && a.email.toLowerCase() === query.toLowerCase());
      const bExact = (b.firstName && b.firstName.toLowerCase() === query.toLowerCase()) ||
                     (b.lastName && b.lastName.toLowerCase() === query.toLowerCase()) ||
                     (b.email && b.email.toLowerCase() === query.toLowerCase());
      
      if (aExact && !bExact) return -1;
      if (!aExact && bExact) return 1;
      return 0;
    });
    
    // Deduplicate contacts based on name and email combination
    const uniqueContacts = [];
    const seenContacts = new Set();
    
    for (const contact of sortedContacts) {
      const contactKey = `${contact.firstName} ${contact.lastName} ${contact.email || ''}`.toLowerCase();
      if (!seenContacts.has(contactKey)) {
        seenContacts.add(contactKey);
        uniqueContacts.push(contact);
      }
    }
    
    const limitedContacts = uniqueContacts.slice(0, 20); // Limit to 20 results

    const results = limitedContacts.map(contact => {
      // Find email campaigns for this contact
      const emailCampaigns = emailMessages.filter(campaign => {
        const recipients = Array.isArray(campaign.to) ? campaign.to : [campaign.to];
        return recipients.includes(contact.email);
      });
      
      // Find SMS campaigns for this contact
      const smsCampaigns = smsMessages.filter(campaign => {
        const recipients = Array.isArray(campaign.to) ? campaign.to : [campaign.to];
        const cleanContactPhone = contact.phone ? contact.phone.replace(/^\+?1?/, '').replace(/\D/g, '') : '';
        return recipients.some(recipient => {
          const cleanRecipientPhone = recipient.replace(/^\+?1?/, '').replace(/\D/g, '');
          return cleanRecipientPhone === cleanContactPhone;
        });
      });

      return {
        contactId: contact.id,
        contactName: `${contact.firstName} ${contact.lastName}`,
        contactInfo: contact.email || contact.phone || 'No contact info',
        emailCampaigns,
        smsCampaigns
      };
    });

    res.json(results);
  } catch (error) {
    console.error('Contact search error:', error);
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/categories', auth, async (req, res) => {
  try {
    const { name } = req.body;
    
    if (!name || !name.trim()) {
      throw new Error('Category name is required');
    }
    
    const categoryName = name.trim();
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const contacts = await getAccountContacts(accountId);
    
    // Check if category already exists
    const existingCategories = [...new Set(contacts
      .map(c => c.category)
      .filter(Boolean)
    )];
    
    if (existingCategories.includes(categoryName)) {
      throw new Error('Category already exists');
    }
    
    // Return the new category name (no need to save anything since categories are derived from contacts)
    res.json({ 
      success: true, 
      category: categoryName,
      message: 'Category added successfully' 
    });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Admin endpoint to manually trigger database migration
// app.post('/api/admin/migrate-database', adminAuth, async (req, res) => {
//   try {
//     //     await migrateAllUsers();
//     res.json({ 
//       success: true, 
//       message: 'Database migration completed successfully' 
//     });
//   } catch (error) {
//     console.error('Manual migration failed:', error);
//     res.status(500).json({ error: error.message });
//   }
// });

// Admin endpoint to get all contacts from all users
app.get('/api/admin/contacts', adminAuth, async (req, res) => {
  try {
    const userIds = await getAllUserIds();
    let allContacts = [];
    
    for (const userId of userIds) {
      const user = await findUserById(userId);
      if (user) {
        // Get contacts from shared-data
        const accountId = user.accountId || user.id;
        try {
          const userContacts = await getAccountContacts(accountId);
          // Add userId to each contact for admin reference
          const contactsWithUserInfo = userContacts.map(contact => ({
            ...contact,
            userId: user.id,
            userEmail: user.email,
            accountId: accountId
          }));
          allContacts = allContacts.concat(contactsWithUserInfo);
        } catch (error) {
          console.error(`Error loading contacts for user ${userId}:`, error);
        }
      }
    }
    
    res.json(allContacts);
  } catch (error) {
    console.error('Error fetching admin contacts:', error);
    res.status(500).json({ error: error.message });
  }
});

// Admin endpoint to sync unsubscribe preferences from log to contacts
app.post('/api/admin/sync-unsubscribes', adminAuth, async (req, res) => {
  try {
    const { accountId } = req.body;
    
    if (!accountId) {
      return res.status(400).json({ error: 'Account ID is required' });
    }
    
    // Get unsubscribe log
    const logPath = path.join(__dirname, 'data', 'shared-data', accountId.toString(), 'unsubscribe-log.json');
    const log = await safeReadJsonFile(logPath, []);
    
    // Get contacts
    const contacts = await getAccountContacts(accountId);
    
    let updatedCount = 0;
    const updates = [];
    
    // Group unsubscribes by contact ID and channel
    const unsubscribesByContact = {};
    log.forEach(entry => {
      if (!unsubscribesByContact[entry.contactId]) {
        unsubscribesByContact[entry.contactId] = {};
      }
      // Keep the most recent unsubscribe for each channel
      if (!unsubscribesByContact[entry.contactId][entry.channel] || 
          new Date(entry.timestamp) > new Date(unsubscribesByContact[entry.contactId][entry.channel].timestamp)) {
        unsubscribesByContact[entry.contactId][entry.channel] = entry;
      }
    });
    
    // Update contacts with unsubscribe preferences
    for (let i = 0; i < contacts.length; i++) {
      const contact = contacts[i];
      const unsubscribes = unsubscribesByContact[contact.id];
      
      if (!unsubscribes) continue;
      
      let contactUpdated = false;
      ensureCommunicationPreferences(contact);
      
      for (const [channel, entry] of Object.entries(unsubscribes)) {
        const currentPref = contact.communicationPreferences[channel];
        
        // Only update if not already unsubscribed or if log entry is more recent
        if (!currentPref || currentPref.subscribed !== false || 
            (currentPref.unsubscribedAt && new Date(entry.timestamp) > new Date(currentPref.unsubscribedAt))) {
          
          contact.communicationPreferences[channel] = {
            subscribed: false,
            unsubscribedAt: entry.timestamp,
            unsubscribeReason: entry.reason || null,
            unsubscribeMethod: entry.method || 'link'
          };
          
          contactUpdated = true;
          updates.push({
            contactId: contact.id,
            contactName: `${contact.firstName} ${contact.lastName}`,
            channel: channel,
            unsubscribedAt: entry.timestamp
          });
        }
      }
      
      if (contactUpdated) {
        updatedCount++;
      }
    }
    
    // Save updated contacts
    if (updatedCount > 0) {
      await updateAccountContacts(accountId, contacts);
    }
    
    res.json({
      success: true,
      message: `Synced unsubscribe preferences for ${updatedCount} contacts`,
      updatedCount,
      updates
    });
    
  } catch (error) {
    console.error('Error syncing unsubscribes:', error);
    res.status(500).json({ error: error.message });
  }
});

// Add HTML content generation endpoint for body elements
app.post('/api/templates/generate-html', auth, async (req, res) => {
    try {
        const { prompt, type = 'custom', style = 'professional' } = req.body;
        
        if (!prompt || prompt.trim() === '') {
            return res.status(400).json({ error: 'Prompt is required' });
        }

        // Validate user authentication
        if (!req.user || !req.user.id) {
            return res.status(401).json({
                error: 'User not found',
                message: 'User authentication failed. Please log in again.'
            });
        }

        const systemPrompt = `You are a professional HTML content generator for email templates. 
Generate clean, well-formatted HTML content that works well in email clients.
Use inline CSS styles for consistent rendering across email clients.
Focus on creating engaging, readable content with proper structure.
IMPORTANT: 
- Do not include any img tags or image references in your HTML output.
- Do not include <!DOCTYPE html>, <html>, <head>, or <body> tags.
- Generate only the content that goes inside an email template body.
- Use text content, styled divs, buttons, and CSS styling for visual appeal instead.`;

        const styleInstructions = {
            professional: 'Use a formal, business-like tone with clean typography and subtle styling.',
            casual: 'Use a friendly, conversational tone with relaxed styling and approachable language.',
            modern: 'Use contemporary design elements, bold typography, and clean spacing.',
            elegant: 'Use sophisticated language, refined styling, and graceful formatting.',
            bold: 'Use strong, impactful language with prominent styling and high contrast.'
        };

        const typeInstructions = {
            welcome: 'Create a welcoming introduction section with a friendly greeting and overview. Use styled text and buttons.',
            announcement: 'Create an announcement section with clear, important information. Use highlighted text and call-to-action buttons.',
            newsletter: 'Create newsletter content with engaging articles and updates. Use styled sections and buttons.',
            promotional: 'Create promotional content with compelling offers and calls-to-action. Use styled buttons and highlighted text.',
            testimonial: 'Create a testimonial section with customer feedback and quotes. Use styled quote blocks and text.',
            custom: 'Create custom content based on the user\'s specific requirements. Use styled text, buttons, and divs.'
        };

        const formatInstructions = `Generate HTML content for: "${prompt}"

Content Type: ${typeInstructions[type]}
Style: ${styleInstructions[style]}

Requirements:
- Generate ONLY the content that goes inside an email template body
- DO NOT include <!DOCTYPE html>, <html>, <head>, or <body> tags
- Use proper HTML structure with semantic tags (div, p, h1, h2, etc.)
- Include inline CSS styles for email compatibility
- Use responsive design principles
- Ensure content is engaging and readable
- Include appropriate spacing and typography
- Make sure all HTML tags are properly closed
- Use web-safe fonts (Arial, Helvetica, sans-serif)
- Keep styles inline for email client compatibility
- DO NOT include any image references or img tags
- Focus on text content, buttons, and styled divs
- Use background colors, borders, and typography for visual appeal
- Create engaging content without relying on external images

Generate ONLY the HTML content that will be inserted into an email template (no wrapper tags).`;

        let completion;
        try {
            completion = await openai.chat.completions.create({
                model: "gpt-4",
                messages: [
                    {
                        "role": "system",
                        "content": systemPrompt
                    },
                    {
                        "role": "user",
                        "content": formatInstructions
                    }
                ],
                temperature: 0.7,
                max_tokens: 800
            });
        } catch (gpt4Error) {

            try {
                completion = await openai.chat.completions.create({
                    model: "gpt-3.5-turbo",
                    messages: [
                        {
                            "role": "system",
                            "content": systemPrompt
                        },
                        {
                            "role": "user",
                            "content": formatInstructions
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 800
                });
            } catch (fallbackError) {
                console.error('Both GPT models failed:', fallbackError.message);
                throw fallbackError;
            }
        }

        // Check if we have a valid response
        if (!completion?.choices?.[0]?.message?.content) {
            throw new Error('No content received from OpenAI API');
        }
        
        let generatedHtml = completion.choices[0].message.content.trim();
        
        // Remove any img tags that might have been generated
        generatedHtml = generatedHtml.replace(/<img[^>]*>/gi, '');
        
        // Remove HTML document structure if present
        generatedHtml = generatedHtml.replace(/<!DOCTYPE[^>]*>/gi, '');
        generatedHtml = generatedHtml.replace(/<html[^>]*>.*?<\/html>/gis, (match) => {
            // Extract content between <body> tags, or if no body tags, return the content
            const bodyMatch = match.match(/<body[^>]*>(.*?)<\/body>/gis);
            if (bodyMatch) {
                return bodyMatch[1].trim();
            }
            // If no body tags, remove html tags and return content
            return match.replace(/<html[^>]*>|<\/html>/gi, '').trim();
        });
        
        // Remove head tags and their content
        generatedHtml = generatedHtml.replace(/<head[^>]*>.*?<\/head>/gis, '');
        
        // Remove body tags but keep their content
        generatedHtml = generatedHtml.replace(/<body[^>]*>|<\/body>/gi, '');
        
        // If no HTML tags, wrap in a simple div
        if (!generatedHtml.includes('<') || !generatedHtml.includes('>')) {
            generatedHtml = `<div class="email-content">
                <p>${generatedHtml}</p>
            </div>`;
        }

        res.json({
            success: true,
            html: generatedHtml,
            prompt: prompt
        });
    } catch (error) {
        console.error('HTML generation failed:', error.message);
        
        res.status(400).json({ 
            error: 'Failed to generate HTML content',
            message: error.error?.message || error.message || 'An error occurred while generating HTML content'
        });
    }
});

// Simple HTML generation test
app.post('/api/test/html-generation', auth, async (req, res) => {
    try {
        const completion = await openai.chat.completions.create({
            model: "gpt-3.5-turbo",
            messages: [
                {
                    "role": "system",
                    "content": "Generate simple HTML content for email templates. Use inline CSS. Return only HTML content, no explanations."
                },
                {
                    "role": "user",
                    "content": "Create a simple welcome message with a button"
                }
            ],
            temperature: 0.7,
            max_tokens: 200
        });
        
        const html = completion.choices[0].message.content.trim();
        
        res.json({
            success: true,
            message: 'HTML generation test successful',
            html: html
        });
        
    } catch (error) {
        console.error('HTML test failed:', error.message);
        res.status(500).json({
            error: 'HTML generation test failed',
            message: error.message
        });
    }
});

// Comprehensive test endpoint to verify OpenAI services
app.post('/api/test/openai-services', auth, async (req, res) => {
    const results = {
        textGeneration: { working: false, error: null },
        imageGeneration: { working: false, error: null },
        models: { available: [], error: null }
    };
    
    try {
        // Test 1: List available models
        try {
            const models = await openai.models.list();
            results.models.available = models.data.map(m => m.id).filter(id => 
                id.includes('gpt') || id.includes('dall-e')
            );
            results.models.working = true;
        } catch (error) {
            results.models.error = error.message;
        }
        
        // Test 2: Text generation (GPT)
        try {
            const textResponse = await openai.chat.completions.create({
                model: "gpt-3.5-turbo",
                messages: [{ role: "user", content: "Say 'Hello World'" }],
                max_tokens: 10
            });
            results.textGeneration.working = true;
            results.textGeneration.response = textResponse.choices[0].message.content;
        } catch (error) {
            results.textGeneration.error = error.message;
        }
        
        // Test 3: Image generation (DALL-E)
        try {
            const imageResponse = await openai.images.generate({
                model: "dall-e-2",
                prompt: "a simple red circle",
                size: "256x256",
                n: 1,
            });
            results.imageGeneration.working = true;
            results.imageGeneration.url = imageResponse.data[0].url;
        } catch (error) {
            results.imageGeneration.error = error.message;
        }
        
        res.json({
            success: true,
            message: 'OpenAI services test completed',
            results: results,
            summary: {
                textWorking: results.textGeneration.working,
                imageWorking: results.imageGeneration.working,
                modelsAvailable: results.models.available.length
            }
        });
        
    } catch (error) {
        console.error('OpenAI services test failed:', error);
        res.status(500).json({
            error: 'OpenAI services test failed',
            message: error.message,
            results: results
        });
    }
});

// Add AI image generation endpoint
app.post('/api/templates/generate-image', auth, async (req, res) => {
    try {
        // First check OpenAI configuration
        if (!openai) {
            return res.status(500).json({
                error: 'OpenAI not initialized',
                message: 'The OpenAI client is not properly initialized.'
            });
        }

        if (!process.env.OPENAI_API_KEY) {
            return res.status(500).json({
                error: 'OpenAI API key missing',
                message: 'The OpenAI API key is not configured.'
            });
        }

        // Try a quick API test
        try {
            await openai.models.list();
        } catch (apiError) {
            return res.status(500).json({
                error: 'OpenAI API test failed',
                message: 'Could not connect to OpenAI API',
                details: apiError.message
            });
        }

        const { prompt, style = 'realistic', size = '1024x1024' } = req.body;
        let { aspectRatio } = req.body;
        
        if (!prompt) {
            return res.status(400).json({ error: 'Image prompt is required' });
        }
        
        // Validate prompt length (OpenAI has limits)
        if (prompt.length > 1000) {
            return res.status(400).json({ error: 'Image prompt is too long. Maximum 1000 characters allowed.' });
        }
        
        // Validate prompt content
        if (prompt.length < 3) {
            return res.status(400).json({ error: 'Image prompt is too short. Please provide a more detailed description.' });
        }
        
        // Check for potentially problematic content
        const problematicPatterns = [
            /nude|naked|sexual|porn|explicit/i,
            /violence|blood|gore|weapon/i,
            /hate|racist|discriminat/i
        ];
        
        for (const pattern of problematicPatterns) {
            if (pattern.test(prompt)) {
                return res.status(400).json({ 
                    error: 'Inappropriate content detected', 
                    message: 'Please provide a more appropriate image description.' 
                });
            }
        }
        
        // Get user info for account-based rate limiting
        const user = await findUserById(req.user.id);
        if (!user) {
            return res.status(401).json({
                error: 'User not found',
                message: 'User authentication failed. Please log in again.'
            });
        }
        
        // Check daily image generation limit per account
        const accountId = getEffectiveAccountId(user);
        let allImages = await getAccountImages(accountId);
        
        // For app owners, also include global images as fallback
        if (user.userType === 'app_owner') {
            const globalImagesPath = path.join(__dirname, 'data', 'images.json');
            const globalImages = await safeReadJsonFile(globalImagesPath, []);
            // Filter to only show app owner's images + system defaults
            const filteredGlobalImages = globalImages.filter(img => 
                img.userId === req.user.id || (img.userId === 'system' && img.isDefault === true)
            );
            allImages = [...allImages, ...filteredGlobalImages];
        }
        
        // Check all AI-generated images for this account in the last 24 hours
        const accountRecentImages = allImages.filter(img => 
            img.source === 'ai' &&
            new Date(img.createdAt) > new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
        );
        
                if (accountRecentImages.length >= 25) {
                    return res.status(429).json({ 
                        error: 'Daily limit reached', 
                        message: 'You have reached your daily maximum of 25 AI image generations. Please try again tomorrow.',
                        limitReached: true,
                        currentCount: accountRecentImages.length,
                        maxLimit: 25
                    });
                }
        
        // Validate user object
        if (!req.user || !req.user.id) {
            throw new Error('User authentication failed');
        }

        // Determine the appropriate size based on aspect ratio
        let imageSize = size;
        if (aspectRatio) {
            // Convert aspectRatio to number and validate
            const aspectRatioNum = parseFloat(aspectRatio);
            if (isNaN(aspectRatioNum) || aspectRatioNum <= 0 || aspectRatioNum > 10) {
                return res.status(400).json({ error: 'Invalid aspect ratio. Must be a positive number between 0.1 and 10.' });
            }
            // Use the converted number
            aspectRatio = aspectRatioNum;
            
            if (aspectRatio >= 3) {
                // Wide images (header, banner)
                imageSize = '1792x1024';
            } else if (aspectRatio <= 0.5) {
                // Tall images
                imageSize = '1024x1792';
            } else {
                // Square-ish images
                imageSize = '1024x1024';
            }
        }
        
        // Validate size parameter
        const validSizes = ['256x256', '512x512', '1024x1024', '1792x1024', '1024x1792'];
        if (!validSizes.includes(imageSize)) {
            return res.status(400).json({ error: 'Invalid size parameter' });
        }
        
        // Validate style parameter
        const validStyles = ['realistic', 'artistic', 'minimalist', 'vintage', 'modern'];
        if (!validStyles.includes(style)) {
            return res.status(400).json({ error: 'Invalid style parameter' });
        }

        // Enhance the prompt based on style
        let enhancedPrompt = prompt;
        switch (style) {
            case 'realistic':
                enhancedPrompt = `${prompt}, high quality, photorealistic, professional photography`;
                break;
            case 'artistic':
                enhancedPrompt = `${prompt}, artistic style, creative, vibrant colors`;
                break;
            case 'minimalist':
                enhancedPrompt = `${prompt}, minimalist design, clean, simple, modern`;
                break;
            case 'vintage':
                enhancedPrompt = `${prompt}, vintage style, retro, classic design`;
                break;
            case 'modern':
                enhancedPrompt = `${prompt}, modern design, contemporary, sleek`;
                break;
        }

        // Generate image using OpenAI DALL-E

        // Validate OpenAI API key
        if (!process.env.OPENAI_API_KEY) {
            throw new Error('OpenAI API key not configured');
        }
        
        // Ensure the uploads directory exists
        const uploadsDir = path.join(__dirname, 'public', 'uploads', 'templates');
        try {
            await fsPromises.access(uploadsDir);
        } catch (error) {
            await fsPromises.mkdir(uploadsDir, { recursive: true });
        }
        
        // Ensure the data directory exists
        const dataDir = path.join(__dirname, 'data');
        try {
            await fsPromises.access(dataDir);
        } catch (error) {
            await fsPromises.mkdir(dataDir, { recursive: true });
        }
        
        // Log OpenAI configuration

        let imageResponse;
        try {
        imageResponse = await openai.images.generate({
                model: "dall-e-3",
                prompt: enhancedPrompt,
                size: imageSize,
                quality: "standard",
                n: 1,
            });

            if (!imageResponse?.data?.[0]?.url) {
                throw new Error('Invalid response structure from OpenAI API');
            }
        } catch (openaiError) {
            console.error('Image generation failed:', openaiError.message);
            
            // Check for specific billing/account errors
            if (openaiError.error?.message?.includes('account is not active') ||
                openaiError.error?.message?.includes('billing details') ||
                openaiError.message?.includes('account is not active') ||
                openaiError.message?.includes('billing details')) {
                return res.status(402).json({
                    error: 'OpenAI Image Generation Service Unavailable',
                    message: 'The OpenAI image generation service requires additional billing setup. Text generation (AI calling) works fine, but image generation needs separate billing configuration.',
                    details: 'This is a known issue where DALL-E image generation has different billing requirements than GPT text generation. Please check your OpenAI account billing settings for image generation services.',
                    solution: 'Contact your administrator to enable image generation billing in your OpenAI account, or use the text-based HTML generation instead.'
                });
            }

            // Check if it's a model-specific error and try DALL-E 2 as fallback
            if (openaiError.error?.code === 'model_not_found' || 
                openaiError.error?.message?.includes('dall-e-3') ||
                openaiError.message?.includes('dall-e-3')) {

                try {
                    imageResponse = await openai.images.generate({
                        model: "dall-e-2",
                        prompt: enhancedPrompt,
                        size: imageSize === '1792x1024' ? '1024x1024' : imageSize,
                        n: 1,
                    });
                } catch (fallbackError) {
                    console.error('DALL-E 2 fallback failed:', fallbackError.message);
                    return res.status(500).json({
                        error: 'Image Generation Failed',
                        message: 'Both DALL-E models failed. Please contact your administrator to enable image generation billing.',
                        details: fallbackError.error?.message || fallbackError.message
                    });
                }
            } else {
                return res.status(500).json({
                    error: 'Image Generation Failed',
                    message: 'OpenAI image generation requires billing setup. Use HTML generation or upload your own images.',
                    details: openaiError.error?.message || openaiError.message
                });
            }
        }

        const imageUrl = imageResponse.data[0].url;

        // Download the AI-generated image and save it locally
        const response = await fetch(imageUrl, { 
            timeout: 30000 // 30 second timeout
        });
        if (!response.ok) {
            throw new Error(`Failed to download AI image: ${response.status} ${response.statusText}`);
        }

        // Convert response to buffer (compatible with node-fetch v2)
        let imageBuffer;
        try {
            const arrayBuffer = await response.arrayBuffer();
            imageBuffer = Buffer.from(arrayBuffer);
            
            // Validate that we got a non-empty buffer
            if (!imageBuffer || imageBuffer.length === 0) {
                throw new Error('Downloaded image is empty');
            }
            
            // Validate image size (max 10MB)
            const maxSize = 10 * 1024 * 1024; // 10MB
            if (imageBuffer.length > maxSize) {
                throw new Error(`Image too large: ${(imageBuffer.length / 1024 / 1024).toFixed(2)}MB. Maximum allowed: 10MB`);
            }
        } catch (fetchError) {
            throw new Error(`Failed to process downloaded image: ${fetchError.message}`);
        }
        const contentType = response.headers.get('content-type');
        if (!contentType || (!contentType.includes('image/png') && !contentType.includes('image/jpeg') && !contentType.includes('image/jpg'))) {
            throw new Error(`Invalid content type: ${contentType}. Expected image/png or image/jpeg`);
        }
        const fileExtension = contentType.includes('png') ? '.png' : '.jpg';
        
        // Generate a unique filename
        const timestamp = Date.now();
        const imageId = `ai-generated-${timestamp}`;
        const newFilename = `${imageId}${fileExtension}`;
        
        // Validate filename
        if (!newFilename || newFilename.length > 255) {
            throw new Error('Generated filename is invalid or too long');
        }
        
        // Save the image to the templates directory
        const imagePath = path.join(__dirname, 'public', 'uploads', 'templates', newFilename);
        
        // Validate image path
        if (!imagePath || imagePath.length > 4096) {
            throw new Error('Generated image path is invalid or too long');
        }
        
        try {
            await fsPromises.writeFile(imagePath, imageBuffer);
        } catch (writeError) {
            throw new Error(`Failed to save image to disk: ${writeError.message}`);
        }
        
        // Create the URL for the image
        const localImageUrl = `${BASE_URL}/uploads/templates/${newFilename}`;
        
        // Save the image file (but don't automatically add to library)
        try {
            await fsPromises.writeFile(imagePath, imageBuffer);

            res.json({
                success: true,
                imageUrl: localImageUrl,
                imageId: imageId,
                prompt: enhancedPrompt
            });
        } catch (writeError) {
            console.error('Failed to save image:', writeError);
            throw new Error(`Failed to save image: ${writeError.message}`);
        }

    } catch (error) {
        console.error('AI image generation error:', error);
        
        // If it's already a handled error response, don't modify it
        if (error.status === 402) {
            return res.status(402).json(error.response);
        }
        
        // Log detailed error information
        console.error('Error details:', {
            message: error.message,
            code: error.code,
            status: error.status,
            type: error.type,
            response: error.response?.data,
            openaiError: error.error
        });

        // Send appropriate error response
        res.status(500).json({ 
            error: 'Failed to generate image',
            message: error.message,
            details: error.error?.message || error.message
        });
    }
});

// ============================================================================
// TWO-STAGE AI IMAGE GENERATION (with Image Prompt Assistant)
// ============================================================================
// This endpoint uses a two-stage process:
// 1. An "Image Prompt Assistant" (GPT) that takes structured input and builds an optimized prompt
// 2. DALL-E generates the image using that prompt
//
// IMPORTANT: Text is NEVER baked into AI images. All text should be overlaid via HTML.
// ============================================================================

app.post('/api/templates/:templateId/generate-slot-image', auth, async (req, res) => {
    try {
        // Check OpenAI configuration
        if (!openai) {
            return res.status(500).json({
                error: 'OpenAI not initialized',
                message: 'The OpenAI client is not properly initialized.'
            });
        }

        if (!process.env.OPENAI_API_KEY) {
            return res.status(500).json({
                error: 'OpenAI API key missing',
                message: 'The OpenAI API key is not configured.'
            });
        }

        // Validate the request body
        const validation = validateImageGenerationRequest(req.body);
        if (!validation.valid) {
            return res.status(400).json({ 
                error: 'Invalid request',
                message: validation.error 
            });
        }

        const imageRequest = validation.request;
        const { slot } = imageRequest;

        console.log(`[SlotImageGen] Generating image for slot: ${slot}, template: ${req.params.templateId}`);

        // Get user info for rate limiting
        const user = await findUserById(req.user.id);
        if (!user) {
            return res.status(401).json({
                error: 'User not found',
                message: 'User authentication failed. Please log in again.'
            });
        }

        // Check daily image generation limit per account
        const accountId = getEffectiveAccountId(user);
        let allImages = await getAccountImages(accountId);
        
        // For app owners, also include global images
        if (user.userType === 'app_owner') {
            const globalImagesPath = path.join(__dirname, 'data', 'images.json');
            const globalImages = await safeReadJsonFile(globalImagesPath, []);
            const filteredGlobalImages = globalImages.filter(img => 
                img.userId === req.user.id || (img.userId === 'system' && img.isDefault === true)
            );
            allImages = [...allImages, ...filteredGlobalImages];
        }

        // Check AI-generated images in the last 24 hours
        const accountRecentImages = allImages.filter(img => 
            img.source === 'ai' &&
            new Date(img.createdAt) > new Date(Date.now() - 24 * 60 * 60 * 1000)
        );

        if (accountRecentImages.length >= 25) {
            return res.status(429).json({ 
                error: 'Daily limit reached', 
                message: 'You have reached your daily maximum of 25 AI image generations. Please try again tomorrow.',
                limitReached: true,
                currentCount: accountRecentImages.length,
                maxLimit: 25
            });
        }

        // Generate the image using two-stage process
        const result = await generateTemplateImage(imageRequest, openai, { quality: 'standard' });

        // Download and save the image locally
        const imageUrl = result.imageUrl;
        const response = await fetch(imageUrl, { timeout: 30000 });
        
        if (!response.ok) {
            throw new Error(`Failed to download AI image: ${response.status} ${response.statusText}`);
        }

        const arrayBuffer = await response.arrayBuffer();
        const imageBuffer = Buffer.from(arrayBuffer);

        if (!imageBuffer || imageBuffer.length === 0) {
            throw new Error('Downloaded image is empty');
        }

        // Validate image size (max 10MB)
        const maxSize = 10 * 1024 * 1024;
        if (imageBuffer.length > maxSize) {
            throw new Error(`Image too large: ${(imageBuffer.length / 1024 / 1024).toFixed(2)}MB. Maximum: 10MB`);
        }

        // Determine file extension
        const contentType = response.headers.get('content-type');
        const fileExtension = contentType?.includes('png') ? '.png' : '.jpg';

        // Ensure uploads directory exists
        const uploadsDir = path.join(__dirname, 'public', 'uploads', 'templates');
        try {
            await fsPromises.access(uploadsDir);
        } catch {
            await fsPromises.mkdir(uploadsDir, { recursive: true });
        }

        // Generate unique filename
        const timestamp = Date.now();
        const imageId = `ai-slot-${slot}-${timestamp}`;
        const newFilename = `${imageId}${fileExtension}`;
        const imagePath = path.join(uploadsDir, newFilename);

        // Save the image
        await fsPromises.writeFile(imagePath, imageBuffer);

        // Create the URL
        const BASE_URL = process.env.BASE_URL || `https://${req.get('host')}`;
        const localImageUrl = `${BASE_URL}/uploads/templates/${newFilename}`;

        console.log(`[SlotImageGen] Image saved: ${localImageUrl}`);

        // Return the result
        res.json({
            success: true,
            imageUrl: localImageUrl,
            imageId: imageId,
            slot: slot,
            recommendedSize: SLOT_DEFAULT_SIZES[slot],
            requiresTextOverlay: result.metadata.requiresTextOverlay,
            notes: result.metadata.notes,
            metadata: {
                promptUsed: result.metadata.promptUsed,
                generatedAt: new Date().toISOString()
            }
        });

    } catch (error) {
        console.error('[SlotImageGen] Error:', error);

        // Handle billing errors
        if (error.message?.includes('billing') || error.error?.message?.includes('billing')) {
            return res.status(402).json({
                error: 'OpenAI Billing Required',
                message: 'Image generation requires OpenAI billing setup. Please contact your administrator.',
                details: error.message
            });
        }

        res.status(500).json({
            error: 'Failed to generate image',
            message: error.message,
            details: error.error?.message || error.message
        });
    }
});

// Twilio Notifications endpoint
app.get('/twilio-notifications', auth, async (req, res) => {
  try {
    res.render('ai-calling', { 
      title: 'AI Voice Calling - Notifications',
      user: req.user 
    });
  } catch (error) {
    console.error('Twilio notifications page error:', error);
    res.status(500).send('Server error');
  }
});

// API endpoint to get notifications data
app.get('/api/voice/notifications', auth, async (req, res) => {
  try {
    const { page = 1, limit = 25, search = '', startDate = '', endDate = '' } = req.query;
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    // Read voice calls from shared-data folder
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');

    let notifications = [];
    if (fs.existsSync(voiceCallsPath)) {
      try {
        const voiceCalls = JSON.parse(await fs.promises.readFile(voiceCallsPath, 'utf8'));
        notifications = voiceCalls;

        // Don't filter notifications for team members - they should see all account responses
        // Team members can access all responses in their account
      } catch (parseError) {
        console.error('Error parsing voice calls file:', parseError);
        notifications = [];
      }
    } else {
      // Fallback to empty array if no shared data
      notifications = [];
    }
    
    // Filter to show calls with meaningful interactions or completed calls
    const originalCount = notifications.length;
    notifications = notifications.filter(call => {
      // Include calls that have:
      // 1. A response from the contact (keypad input)
      // 2. A transcript with actual conversation
      // 3. Completed calls (even without response)
      // 4. Failed calls with error information
      return call.response || // Has recorded response
             (call.transcript && call.transcript.length > 1) || // Has conversation
             call.status === 'completed' || // Completed calls
             (call.status === 'failed' && call.error); // Failed calls with error info
    });

    // Add contact information and campaign details to notifications
    // Get contacts and campaigns from shared-data
    const contacts = await getAccountContacts(accountId);
    const campaigns = [];
    const campaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
    if (fs.existsSync(campaignsPath)) {
      try {
        campaigns.push(...JSON.parse(await fs.promises.readFile(campaignsPath, 'utf8')));
      } catch (parseError) {
        console.error('Error parsing campaigns for notifications:', parseError);
      }
    }
    
    notifications = notifications.map(call => {
      const contact = contacts.find(c => c.id === call.contactId);
      const campaign = campaigns.find(c => c.id === call.campaignId);
      
      return {
        ...call,
        contactName: call.contactName || (contact ? `${contact.firstName || ''} ${contact.lastName || ''}`.trim() : 'Unknown'),
        contactEmail: contact ? contact.email : '',
        contactCity: contact ? contact.city : '',
        contactPhone: call.originalPhone || call.to,
        campaignName: campaign ? campaign.name : 'Unknown Campaign',
        campaignMessage: call.message || (campaign ? campaign.message : 'Message not available')
      };
    });
    
    // Date filtering
    if (startDate || endDate) {
      notifications = notifications.filter(notification => {
        const callDate = new Date(notification.startedAt || notification.timestamp);
        const start = startDate ? new Date(startDate) : new Date('1900-01-01');
        const end = endDate ? new Date(endDate + 'T23:59:59.999Z') : new Date('2100-12-31');
        return callDate >= start && callDate <= end;
      });
    }
    
    // Search filtering
    if (search) {
      const searchLower = search.toLowerCase();
      notifications = notifications.filter(notification => 
        (notification.contactName || '').toLowerCase().includes(searchLower) ||
        (notification.contactCity || '').toLowerCase().includes(searchLower) ||
        (notification.contactPhone || '').toLowerCase().includes(searchLower) ||
        (notification.contactEmail || '').toLowerCase().includes(searchLower) ||
        (notification.campaignName || '').toLowerCase().includes(searchLower) ||
        (notification.response || '').toLowerCase().includes(searchLower)
      );
    }
    
    // Sort by most recent first
    notifications.sort((a, b) => new Date(b.startedAt) - new Date(a.startedAt));
    
    // Pagination
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + parseInt(limit);
    const paginatedNotifications = notifications.slice(startIndex, endIndex);
    
    const totalPages = Math.ceil(notifications.length / limit);
    
    res.json({
      notifications: paginatedNotifications,
      pagination: {
        currentPage: parseInt(page),
        totalPages,
        totalItems: notifications.length,
        itemsPerPage: parseInt(limit),
        startIndex: startIndex + 1,
        endIndex: Math.min(endIndex, notifications.length)
      }
    });
    
  } catch (error) {
    console.error('Get notifications error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Excel export endpoint for voice responses
app.get('/api/voice/notifications/export', auth, async (req, res) => {
  try {
    const { search = '', startDate = '', endDate = '' } = req.query;
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    // Read voice calls from shared-data folder
    const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
    const voiceCallsPath = path.join(sharedDataPath, 'voice-calls.json');

    let notifications = [];
    if (fs.existsSync(voiceCallsPath)) {
      try {
        const voiceCalls = JSON.parse(await fs.promises.readFile(voiceCallsPath, 'utf8'));
        notifications = voiceCalls;
      } catch (parseError) {
        console.error('Error parsing voice calls file:', parseError);
        notifications = [];
      }
    }

    // Filter to show calls with meaningful interactions or completed calls
    notifications = notifications.filter(call => {
      return call.response || 
             (call.transcript && call.transcript.length > 1) || 
             call.status === 'completed' || 
             (call.status === 'failed' && call.error);
    });

    // Get contacts and campaigns from shared-data
    const contacts = await getAccountContacts(accountId);
    const campaigns = [];
    const campaignsPath = path.join(sharedDataPath, 'voice-campaigns.json');
    if (fs.existsSync(campaignsPath)) {
      try {
        campaigns.push(...JSON.parse(await fs.promises.readFile(campaignsPath, 'utf8')));
      } catch (parseError) {
        console.error('Error parsing campaigns for export:', parseError);
      }
    }

    // Add contact and campaign information
    notifications = notifications.map(call => {
      const contact = contacts.find(c => c.id === call.contactId);
      const campaign = campaigns.find(c => c.id === call.campaignId);
      
      return {
        ...call,
        contactName: call.contactName || (contact ? `${contact.firstName || ''} ${contact.lastName || ''}`.trim() : 'Unknown'),
        contactEmail: contact ? contact.email : '',
        contactCity: contact ? contact.city : '',
        contactPhone: call.originalPhone || call.to,
        campaignName: campaign ? campaign.name : 'Unknown Campaign',
        campaignMessage: call.message || (campaign ? campaign.message : 'Message not available')
      };
    });

    // Apply date filtering
    if (startDate || endDate) {
      notifications = notifications.filter(notification => {
        const callDate = new Date(notification.startedAt || notification.timestamp);
        const start = startDate ? new Date(startDate) : new Date('1900-01-01');
        const end = endDate ? new Date(endDate + 'T23:59:59.999Z') : new Date('2100-12-31');
        return callDate >= start && callDate <= end;
      });
    }

    // Apply search filtering
    if (search) {
      const searchLower = search.toLowerCase();
      notifications = notifications.filter(notification => 
        (notification.contactName || '').toLowerCase().includes(searchLower) ||
        (notification.contactCity || '').toLowerCase().includes(searchLower) ||
        (notification.contactPhone || '').toLowerCase().includes(searchLower) ||
        (notification.contactEmail || '').toLowerCase().includes(searchLower) ||
        (notification.campaignName || '').toLowerCase().includes(searchLower) ||
        (notification.response || '').toLowerCase().includes(searchLower)
      );
    }

    // Sort by most recent first
    notifications.sort((a, b) => new Date(b.startedAt) - new Date(a.startedAt));

    // Create Excel data
    const excelData = notifications.map(notification => ({
      'Call Date': new Date(notification.startedAt || notification.timestamp).toLocaleString(),
      'Contact Name': notification.contactName || 'Unknown',
      'Email': notification.contactEmail || '',
      'Phone': notification.contactPhone || '',
      'City': notification.contactCity || '',
      'Campaign Name': notification.campaignName || 'Unknown',
      'Campaign Message': notification.campaignMessage || '',
      'Response': notification.response || 'No response',
      'Status': notification.status || 'Unknown',
      'Duration (seconds)': notification.duration || 0,
      'Call ID': notification.id || notification.callSid || '',
      'Notes': notification.notes || ''
    }));

    // Generate Excel file using simple CSV format (more compatible)
    const csvHeaders = Object.keys(excelData[0] || {}).join(',');
    const csvRows = excelData.map(row => 
      Object.values(row).map(value => 
        typeof value === 'string' && value.includes(',') ? `"${value.replace(/"/g, '""')}"` : value
      ).join(',')
    );
    
    const csvContent = [csvHeaders, ...csvRows].join('\n');
    
    // Set response headers for Excel download
    const filename = `voice_responses_${new Date().toISOString().split('T')[0]}.csv`;
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(csvContent);

  } catch (error) {
    console.error('Export notifications error:', error);
    res.status(400).json({ error: error.message });
  }
});

// Email open tracking pixel endpoint
app.get('/api/email/open/:msgId.png', async (req, res) => {
    try {
        const { msgId } = req.params;
        const userIdHint = req.query.u;
        const recipientEmail = req.query.r;

        console.log(`[EMAIL-OPEN-TRACKING] Tracking pixel hit - msgId: ${msgId}, user: ${userIdHint}, recipient: ${recipientEmail}`);

        let userFound = false;

        // Prefer direct lookup by userId if provided
        const searchUserIds = userIdHint ? [userIdHint] : await getAllUserIds();
        for (const userId of searchUserIds) {
            const user = await findUserById(userId);
            if (!user) {
                continue; // Skip if user not found
            }
            const accountId = user.accountId || user.id;
            
            // Try new shared-data structure first
            const emailCampaignsPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'email-campaigns.json');
            const emailMessagesPath = path.join(SHARED_DATA_DIR, accountId.toString(), 'email-messages.json');
            
            let emailMessages = [];
            
            // Try email-campaigns.json first
            if (fs.existsSync(emailCampaignsPath)) {
                try {
                    const content = fs.readFileSync(emailCampaignsPath, 'utf8');
                    if (content && content.trim()) {
                        emailMessages = JSON.parse(content);
                    }
                } catch (error) {
                    // JSON parse error - likely race condition during write
                    // Queue this open for later processing
                    const campaignKey = `${accountId}:${msgId}`;
                    const openEvent = {
                        timestamp: new Date().toISOString(),
                        ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress,
                        userAgent: req.headers['user-agent'] || '',
                        email: typeof recipientEmail === 'string' ? recipientEmail : undefined
                    };
                    if (!pendingEmailOpens.has(campaignKey)) {
                        pendingEmailOpens.set(campaignKey, []);
                    }
                    pendingEmailOpens.get(campaignKey).push(openEvent);
                    console.log(`[EMAIL-OPEN-TRACKING] JSON parse error, queued open for later retry`);
                    userFound = true;
                    break;
                }
            }
            
            // Try email-messages.json if no campaigns found
            if (emailMessages.length === 0 && fs.existsSync(emailMessagesPath)) {
                try {
                    const content = fs.readFileSync(emailMessagesPath, 'utf8');
                    if (content && content.trim()) {
                        emailMessages = JSON.parse(content);
                    }
                } catch (error) {
                    console.error('Error reading email messages for tracking:', error.message);
                }
            }
            
            // Fallback to old user structure
            if (emailMessages.length === 0 && user.emailMessages && user.emailMessages.sent) {
                emailMessages = user.emailMessages.sent;
            }
            
            // Find the message and update opens
            let msg = emailMessages.find(m => m.id === msgId);
            
            // If exact campaign not found, try to find a campaign sent around the same time
            // (within 30 seconds) to handle ID mismatch issues
            if (!msg && msgId) {
                const msgTimestamp = parseInt(msgId.split('-')[0]);
                if (!isNaN(msgTimestamp)) {
                    const nearbyCampaigns = emailMessages.filter(m => {
                        const campaignTimestamp = parseInt(m.id.split('-')[0]);
                        const timeDiff = Math.abs(campaignTimestamp - msgTimestamp);
                        return timeDiff < 30000; // Within 30 seconds
                    });
                    
                    if (nearbyCampaigns.length > 0) {
                        // Use the nearest campaign
                        msg = nearbyCampaigns[0];
                        console.log(`[EMAIL-OPEN-TRACKING] Campaign ${msgId} not found, using nearby campaign ${msg.id} (${Math.abs(parseInt(msg.id.split('-')[0]) - msgTimestamp)}ms difference)`);
                    }
                }
            }
            
            if (msg) {
                console.log(`[EMAIL-OPEN-TRACKING] Found campaign ${msg.id}, recording open for ${recipientEmail}`);
                if (!msg.opens) msg.opens = [];
                const openEvent = {
                    timestamp: new Date().toISOString(),
                    ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress,
                    userAgent: req.headers['user-agent'] || '',
                    email: typeof recipientEmail === 'string' ? recipientEmail : undefined
                };
                msg.opens.push(openEvent);
                
                console.log(`[EMAIL-OPEN-TRACKING] Campaign now has ${msg.opens.length} total opens`);
                
                // Save back to the appropriate location
                if (fs.existsSync(emailCampaignsPath)) {
                    await fsPromises.writeFile(emailCampaignsPath, JSON.stringify(emailMessages, null, 2));
                    console.log(`[EMAIL-OPEN-TRACKING] Saved opens to email-campaigns.json`);
                } else if (fs.existsSync(emailMessagesPath)) {
                    await fsPromises.writeFile(emailMessagesPath, JSON.stringify(emailMessages, null, 2));
                    console.log(`[EMAIL-OPEN-TRACKING] Saved opens to email-messages.json`);
                } else {
                    // Fallback to user file
                    await writeIndividualUserFile(userId, user);
                    console.log(`[EMAIL-OPEN-TRACKING] Saved opens to user file`);
                }
                
                // Track email response in dedicated responses file
                const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
                const emailResponsesPath = path.join(sharedDataPath, 'email-responses.json');
                let emailResponses = [];
                
                if (fs.existsSync(emailResponsesPath)) {
                    try {
                        const data = await fsPromises.readFile(emailResponsesPath, 'utf8');
                        if (data && data.trim()) {
                            emailResponses = JSON.parse(data);
                        }
                    } catch (parseError) {
                        console.error('Email tracking error parsing email-responses.json:', parseError.message);
                        // Start fresh if file is corrupted
                        emailResponses = [];
                    }
                }
                
                // Create response record
                const emailResponse = {
                    id: `email_response_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    campaignId: msgId,
                    contactId: null, // Will be linked to contact if we can determine it
                    userId: userId,
                    messageId: msgId,
                    recipientEmail: recipientEmail,
                    responseType: 'open',
                    timestamp: new Date().toISOString(),
                    ip: openEvent.ip,
                    userAgent: openEvent.userAgent,
                    status: 'tracked'
                };
                
                emailResponses.push(emailResponse);
                await fsPromises.writeFile(emailResponsesPath, JSON.stringify(emailResponses, null, 2), 'utf8');

                userFound = true;
                break;
            } else {
                // Campaign not found - add to pending queue
                const campaignKey = `${accountId}:${msgId}`;
                const openEvent = {
                    timestamp: new Date().toISOString(),
                    ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress,
                    userAgent: req.headers['user-agent'] || '',
                    email: typeof recipientEmail === 'string' ? recipientEmail : undefined
                };
                
                if (!pendingEmailOpens.has(campaignKey)) {
                    pendingEmailOpens.set(campaignKey, []);
                }
                pendingEmailOpens.get(campaignKey).push(openEvent);
                console.log(`[EMAIL-OPEN-TRACKING] Campaign ${msgId} not found, queued open for later (${pendingEmailOpens.get(campaignKey).length} pending)`);
                userFound = true; // Mark as handled
                break;
            }
        }
        
        // Always serve a 1x1 transparent PNG (even if tracking failed)
        const img = Buffer.from(
            'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=',
            'base64'
        );
        res.set('Content-Type', 'image/png');
        res.set('Cache-Control', 'no-cache, no-store, must-revalidate');
        res.send(img);
    } catch (error) {
        console.error('Email tracking error:', error);
        // ALWAYS return the pixel image, even if tracking failed
        const img = Buffer.from(
            'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=',
            'base64'
        );
        res.set('Content-Type', 'image/png');
        res.set('Cache-Control', 'no-cache, no-store, must-revalidate');
        res.send(img);
    }
});

// Restricted API endpoint for accessing user data
app.get('/api/admin/users/:userId', async (req, res) => {
    try {
        const { userId } = req.params;
        const apiKey = req.headers['x-api-key'] || req.query.apiKey;
        
        // Check for API key - must be set in environment variables
        const validApiKey = process.env.ADMIN_API_KEY;
        
        if (!validApiKey) {
            return res.status(500).json({ 
                error: 'Server configuration error: ADMIN_API_KEY not configured' 
            });
        }
        
        if (!apiKey || apiKey !== validApiKey) {
            return res.status(401).json({ 
                error: 'Unauthorized - Invalid or missing API key' 
            });
        }
        
        // Validate user ID format
        if (!userId || !/^\d+$/.test(userId)) {
            return res.status(400).json({ 
                error: 'Invalid user ID format' 
            });
        }
        
        // Use readIndividualUserData to handle both file and directory structures
        const userData = await readIndividualUserData(userId);
        
        if (!userData) {
            return res.status(404).json({ 
                error: 'User not found' 
            });
        }
        
        // Get shared data counts
        const accountId = userData.accountId || userData.id;
        const sharedDataPath = path.join(SHARED_DATA_DIR, accountId.toString());
        
        let contactsCount = 0;
        let phoneNumbersCount = 0;
        let smsMessagesCount = { sent: 0, received: 0 };
        let emailMessagesCount = { sent: 0, received: 0 };
        let invoicesCount = 0;
        
        // Get contacts count
        const contactsPath = path.join(sharedDataPath, 'contacts.json');
        if (fs.existsSync(contactsPath)) {
            const contacts = JSON.parse(fs.readFileSync(contactsPath, 'utf8'));
            contactsCount = contacts.length;
        }
        
        // Get phone numbers count
        const phoneNumbersPath = path.join(sharedDataPath, 'phoneNumbers.json');
        if (fs.existsSync(phoneNumbersPath)) {
            const phoneNumbers = JSON.parse(fs.readFileSync(phoneNumbersPath, 'utf8'));
            phoneNumbersCount = phoneNumbers.length;
        }
        
        // Get SMS messages count
        const smsMessagesPath = path.join(sharedDataPath, 'sms-messages.json');
        if (fs.existsSync(smsMessagesPath)) {
            const smsMessages = JSON.parse(fs.readFileSync(smsMessagesPath, 'utf8'));
            smsMessagesCount = {
                sent: smsMessages.sent ? smsMessages.sent.length : 0,
                received: smsMessages.received ? smsMessages.received.length : 0
            };
        }
        
        // Get email messages count
        const emailMessagesPath = path.join(sharedDataPath, 'email-messages.json');
        if (fs.existsSync(emailMessagesPath)) {
            const emailMessages = JSON.parse(fs.readFileSync(emailMessagesPath, 'utf8'));
            emailMessagesCount = {
                sent: emailMessages.sent ? emailMessages.sent.length : 0,
                received: emailMessages.received ? emailMessages.received.length : 0
            };
        }
        
        // Get invoices count
        const invoicesPath = path.join(sharedDataPath, 'invoices.json');
        if (fs.existsSync(invoicesPath)) {
            const invoices = JSON.parse(fs.readFileSync(invoicesPath, 'utf8'));
            invoicesCount = invoices.length;
        }
        
        // Remove sensitive information before sending
        const sanitizedUserData = {
            id: userData.id,
            email: userData.email,
            firstName: userData.firstName,
            lastName: userData.lastName,
            company: userData.company,
            createdAt: userData.createdAt,
            lastLogin: userData.lastLogin,
            isActive: userData.isActive,
            isPro: userData.isPro,
            tokens: userData.tokens,
            phoneNumbers: phoneNumbersCount,
            contacts: contactsCount,
            smsMessages: smsMessagesCount,
            emailMessages: emailMessagesCount,
            invoices: invoicesCount,
            recentActivity: userData.recentActivity
        };
        
        res.json({
            success: true,
            user: sanitizedUserData,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('Error accessing user data:', error);
        res.status(500).json({ 
            error: 'Internal server error' 
        });
    }
});

// Audit logging function - only track: delete all contacts, team add/remove, unsubscribe, failed bulk campaigns
const AUDIT_ACTIONS_ALLOWED = [
  'TEAM_MEMBER_ADDED', 'TEAM_MEMBER_REMOVED', 'DELETE_ALL_CONTACTS',
  'UNSUBSCRIBE', 'FAILED_BULK_EMAIL', 'FAILED_BULK_SMS', 'FAILED_BULK_AI'
];
const logAuditEvent = async (userId, action, details, req = null) => {
  try {
    if (!AUDIT_ACTIONS_ALLOWED.includes(action)) {
      return;
    }
    
    const timestamp = new Date().toISOString();
    
    // Get user info for better context (skip for system/unsubscribe events)
    let userEmail = details?.userEmail ?? userId;
    let userType = 'unknown';
    let accountId = details?.accountId ?? null;
    
    if (action !== 'UNSUBSCRIBE' && userId && String(userId).trim() && !String(userId).startsWith('unsubscribe')) {
    try {
      const userData = await readIndividualUserData(userId);
      // Always prefer email over username or ID
      userEmail = userData.email || userData.username || userData.personalInfo?.email || userId;
      userType = userData.userType || 'unknown';
      accountId = userData.accountId || null;
    } catch (error) {
      // If we can't load user data, try to get email from the details if it exists
      if (details?.userEmail) {
        userEmail = details.userEmail;
      }
    }
    }
    
    const auditLog = {
      timestamp,
      userId,
      action,
      details: {
        ...details,
        userEmail,
        userType,
        accountId
      }
    };
    
    // Create audit logs directory if it doesn't exist
    const auditDir = 'data/audit-logs';
    if (!fs.existsSync(auditDir)) {
      fs.mkdirSync(auditDir, { recursive: true });
    }
    
    // Append to audit log file
    const logFile = `${auditDir}/audit-${new Date().toISOString().split('T')[0]}.json`;
    let logs = [];
    
    if (fs.existsSync(logFile)) {
      try {
        logs = JSON.parse(fs.readFileSync(logFile, 'utf8'));
      } catch (e) {
        console.error('Error reading audit log:', e);
      }
    }
    
    logs.push(auditLog);
    fs.writeFileSync(logFile, JSON.stringify(logs, null, 2));

  } catch (error) {
    console.error('Error writing audit log:', error);
  }
};

// Soft delete functionality - updated for shared-data structure
const softDeleteContacts = async (userId, contactIds = null) => {
  const user = await findUserById(userId);
  
  // Get contacts from shared-data (use accountId if available, otherwise user ID for app owners)
  const accountId = user.accountId || user.id;
  const contacts = await getAccountContacts(accountId);
  
  const contactsToDelete = contactIds 
    ? contacts.filter(c => contactIds.includes(c.id))
    : contacts;
  
  // Move contacts to trash with deletion timestamp
  const deletedContacts = contactsToDelete.map(contact => ({
    ...contact,
    deletedAt: new Date().toISOString(),
    deletedBy: userId,
    originalId: contact.id
  }));
  
  // Get existing trash from shared-data
  const trashPath = path.join(__dirname, 'data', 'shared-data', accountId, 'trash.json');
  let trash = [];
  try {
    const trashData = await fsPromises.readFile(trashPath, 'utf8');
    trash = JSON.parse(trashData);
  } catch (error) {
    // File doesn't exist, start with empty trash
    trash = [];
  }
  
  trash.push(...deletedContacts);
  
  // Remove from main contacts array
  let remainingContacts;
  if (contactIds) {
    remainingContacts = contacts.filter(c => !contactIds.includes(c.id));
  } else {
    remainingContacts = [];
  }
  
  // Update shared contacts file
  const sharedContactsPath = path.join(__dirname, 'data', 'shared-data', accountId, 'contacts.json');
  await fsPromises.writeFile(sharedContactsPath, JSON.stringify(remainingContacts, null, 2), 'utf8');
  
  // Update shared trash file
  await fsPromises.writeFile(trashPath, JSON.stringify(trash, null, 2), 'utf8');
  
  return { deletedCount: deletedContacts.length, remainingCount: remainingContacts.length };
};

// Restore contacts from trash
const restoreContacts = async (userId, contactIds) => {
  const user = await findUserById(userId);
  
  // Get trash from shared-data
  const accountId = user.accountId || user.id;
  const trashPath = path.join(__dirname, 'data', 'shared-data', accountId, 'trash.json');
  
  let trash = [];
  try {
    const trashData = await fsPromises.readFile(trashPath, 'utf8');
    trash = JSON.parse(trashData);
  } catch (error) {
    throw new Error('No trash found');
  }
  
  const contactsToRestore = trash.filter(c => contactIds.includes(c.id));
  
  // Get current contacts from shared-data
  const contacts = await getAccountContacts(accountId);
  
  // Add restored contacts back to shared-data
  const restoredContacts = contactsToRestore.map(contact => ({
    ...contact,
    id: contact.originalId || contact.id, // Use original ID
    restoredAt: new Date().toISOString(),
    restoredBy: userId
  }));
  
  const updatedContacts = [...contacts, ...restoredContacts];
  
  // Update shared contacts file
  const sharedContactsPath = path.join(__dirname, 'data', 'shared-data', accountId, 'contacts.json');
  await fsPromises.writeFile(sharedContactsPath, JSON.stringify(updatedContacts, null, 2), 'utf8');
  
  // Remove from trash
  trash = trash.filter(c => !contactIds.includes(c.id));
  
  // Update shared trash file
  await fsPromises.writeFile(trashPath, JSON.stringify(trash, null, 2), 'utf8');
  
  return { restoredCount: contactsToRestore.length };
};

// Clean up old trash entries (older than 30 days)
const cleanupOldTrash = async (userId) => {
  const user = await findUserById(userId);
  
  // Get trash from shared-data
  const accountId = user.accountId || user.id;
  const trashPath = path.join(__dirname, 'data', 'shared-data', accountId, 'trash.json');
  
  let trash = [];
  try {
    const trashData = await fsPromises.readFile(trashPath, 'utf8');
    trash = JSON.parse(trashData);
  } catch (error) {
    // File doesn't exist, nothing to clean
    return { cleanedCount: 0 };
  }
  
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  
  const oldTrash = trash.filter(item => {
    const deletedAt = new Date(item.deletedAt);
    return deletedAt < thirtyDaysAgo;
  });
  
  trash = trash.filter(item => {
    const deletedAt = new Date(item.deletedAt);
    return deletedAt >= thirtyDaysAgo;
  });
  
  // Update shared trash file
  await fsPromises.writeFile(trashPath, JSON.stringify(trash, null, 2), 'utf8');
  
  return { cleanedCount: oldTrash.length };
};

// ============================================================================
// PHASE 3: ELECTION MODE API ROUTES
// ============================================================================

// Admin endpoint: Enable/disable election mode for an account
app.post('/api/admin/accounts/:accountId/election-mode', adminAuth, async (req, res) => {
  try {
    const { accountId } = req.params;
    const { enabled } = req.body;

    if (typeof enabled !== 'boolean') {
      return res.status(400).json({ error: 'enabled must be a boolean' });
    }

    // Update account in database if using PostgreSQL
    // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
    if (isPostgresReady()) {
      const { getAdapter } = require('./db');
      const adapter = getAdapter();
      if (adapter.updateAccount) {
        await adapter.updateAccount(accountId, { election_mode: enabled });
      }
    }

    // Also update JSON file for backward compatibility
    const accountPath = path.join(SHARED_DATA_DIR, accountId, 'account.json');
    let accountData = {};
    try {
      const accountFile = await fsPromises.readFile(accountPath, 'utf8');
      accountData = JSON.parse(accountFile);
    } catch (error) {
      // Account file doesn't exist, create it
    }

    accountData.id = accountId;
    accountData.electionMode = enabled;
    accountData.updatedAt = new Date().toISOString();

    await fsPromises.writeFile(accountPath, JSON.stringify(accountData, null, 2), 'utf8');

    // Log audit event
    await logAuditEvent(req.user.id, 'ELECTION_MODE_TOGGLED', {
      accountId,
      enabled,
      changedBy: req.user.email
    }, req);

    res.json({
      success: true,
      message: `Election mode ${enabled ? 'enabled' : 'disabled'} for account ${accountId}`,
      accountId,
      electionMode: enabled
    });
  } catch (error) {
    logger.error('Error toggling election mode', error);
    res.status(400).json({ error: error.message });
  }
});

// Get election mode status for account
app.get('/api/election/status', auth, requireActiveAccount, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    // Check account election mode
    let electionMode = false;
    // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
    if (isPostgresReady()) {
      const { getAdapter } = require('./db');
      const adapter = getAdapter();
      if (adapter.getAccount) {
        const account = await adapter.getAccount(accountId);
        electionMode = account?.election_mode || false;
      }
    }
    if (!electionMode) {
      // Check JSON file
      const accountPath = path.join(SHARED_DATA_DIR, accountId, 'account.json');
      try {
        const accountFile = await fsPromises.readFile(accountPath, 'utf8');
        const accountData = JSON.parse(accountFile);
        electionMode = accountData.electionMode || false;
      } catch (error) {
        // Account file doesn't exist, election mode is false
      }
    }

    res.json({
      electionMode,
      accountId
    });
  } catch (error) {
    logger.error('Error getting election status', error);
    res.status(400).json({ error: error.message });
  }
});

// Record voter interaction (append-only) - Phase 4: Enhanced
app.post('/api/election/interactions', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    // Validate input
    validation.validateInteraction({
      contactId: req.body.contactId,
      interactionType: req.body.interactionType,
      interactionMethod: req.body.interactionMethod,
      supportLikelihood: req.body.supportLikelihood
    });

    // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
    if (!isPostgresReady()) {
      // JSON backend: append to election-interactions.json
      const list = await getElectionInteractionsJson(accountId);
      const id = String(list.length > 0 ? Math.max(...list.map(i => parseInt(i.id, 10) || 0)) + 1 : 1);
      const interaction = {
        id,
        account_id: accountId,
        contact_id: req.body.contactId,
        user_id: user.id,
        interaction_type: req.body.interactionType,
        interaction_method: req.body.interactionMethod,
        support_likelihood: req.body.supportLikelihood,
        notes: req.body.notes || null,
        metadata: req.body.metadata || {},
        created_by: user.id,
        created_at: new Date().toISOString()
      };
      list.push(interaction);
      await saveElectionInteractionsJson(accountId, list);
      return res.json({ success: true, interaction });
    }

    const interaction = await voterInteractionsService.recordInteraction({
      accountId,
      contactId: req.body.contactId,
      userId: user.id,
      interactionType: req.body.interactionType,
      interactionMethod: req.body.interactionMethod,
      supportLikelihood: req.body.supportLikelihood,
      notes: req.body.notes,
      metadata: req.body.metadata || {}
    });

    res.json({ success: true, interaction });
  } catch (error) {
    logger.error('Error recording interaction', error);
    const statusCode = error.statusCode || 400;
    res.status(statusCode).json({ error: error.message, code: error.code });
  }
});

// Get all interactions with filters - Phase 4: Enhanced
app.get('/api/election/interactions', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const limit = req.query.limit ? parseInt(req.query.limit) : 100;
    const offset = req.query.offset ? parseInt(req.query.offset) : 0;
    // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
    if (!isPostgresReady()) {
      const list = await getElectionInteractionsJson(accountId);
      const contacts = await getAccountContacts(accountId);
      const contactMap = new Map((contacts || []).map(c => [String(c.id), c]));
      const userIds = [...new Set(list.map(i => i.created_by).filter(Boolean))];
      const userEmailMap = new Map();
      for (const uid of userIds) {
        try {
          const u = await findUserById(uid);
          if (u && u.email) userEmailMap.set(uid, u.email);
        } catch (_) { /* ignore */ }
      }
      let rows = list.map(row => {
        const c = contactMap.get(String(row.contact_id));
        const contact_name = c && (c.name || [c.firstName, c.lastName].filter(Boolean).join(' '));
        return {
          ...row,
          first_name: c && c.firstName,
          last_name: c && c.lastName,
          contact_name: contact_name || null,
          contact_email: c && c.email,
          contact_phone: c && c.phone,
          created_by_email: userEmailMap.get(row.created_by) || null
        };
      });
      if (req.query.contactId) rows = rows.filter(r => String(r.contact_id) === String(req.query.contactId));
      if (req.query.contactSearch) {
        const q = (req.query.contactSearch || '').toLowerCase();
        rows = rows.filter(r => {
          const name = (r.contact_name || [r.first_name, r.last_name].filter(Boolean).join(' ') || '').toLowerCase();
          const email = (r.contact_email || '').toLowerCase();
          const phone = (r.contact_phone || '').toLowerCase();
          return name.includes(q) || email.includes(q) || phone.includes(q);
        });
      }
      if (req.query.interactionType) rows = rows.filter(r => r.interaction_type === req.query.interactionType);
      if (req.query.interactionMethod) rows = rows.filter(r => r.interaction_method === req.query.interactionMethod);
      if (req.query.supportCategory) {
        const ranges = { strong: [80, 100], leaning: [60, 79], undecided: [40, 59], opposed: [0, 39] };
        const range = ranges[req.query.supportCategory];
        if (range) rows = rows.filter(r => r.support_likelihood != null && r.support_likelihood >= range[0] && r.support_likelihood <= range[1]);
      }
      if (req.query.startDate) rows = rows.filter(r => r.created_at >= req.query.startDate);
      if (req.query.endDate) rows = rows.filter(r => r.created_at <= req.query.endDate);
      rows.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
      const total = rows.length;
      const interactions = rows.slice(offset, offset + limit);
      return res.json({ interactions, total, limit, offset, hasMore: offset + interactions.length < total });
    }

    const filters = {
      contactId: req.query.contactId,
      contactSearch: req.query.contactSearch,
      interactionType: req.query.interactionType,
      interactionMethod: req.query.interactionMethod,
      supportCategory: req.query.supportCategory,
      startDate: req.query.startDate,
      endDate: req.query.endDate,
      limit,
      offset
    };

    const result = await voterInteractionsService.getAllInteractions(accountId, filters);
    res.json(result);
  } catch (error) {
    logger.error('Error getting interactions', error);
    res.status(400).json({ error: error.message });
  }
});

// Get interaction statistics - Phase 4 (must be before /:contactId so "statistics" is not matched as contactId)
app.get('/api/election/interactions/statistics', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
    if (!isPostgresReady()) {
      let list = await getElectionInteractionsJson(accountId);
      if (req.query.startDate) list = list.filter(i => i.created_at >= req.query.startDate);
      if (req.query.endDate) list = list.filter(i => i.created_at <= req.query.endDate);
      const contactIds = new Set(list.map(i => i.contact_id));
      const scores = list.map(i => i.support_likelihood).filter(n => n != null);
      const avg = scores.length ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length) : null;
      const byKey = new Map();
      for (const i of list) {
        const key = `${i.interaction_type || ''}:${i.interaction_method || ''}`;
        if (!byKey.has(key)) byKey.set(key, { interactionType: i.interaction_type, interactionMethod: i.interaction_method, count: 0, uniqueContacts: new Set() });
        const g = byKey.get(key);
        g.count++;
        g.uniqueContacts.add(i.contact_id);
      }
      const byType = [...byKey.values()].map(g => ({
        interactionType: g.interactionType,
        interactionMethod: g.interactionMethod,
        count: g.count,
        uniqueContacts: g.uniqueContacts.size
      }));
      return res.json({
        overall: { totalInteractions: list.length, uniqueContacts: contactIds.size, averageSupportScore: avg },
        byType
      });
    }

    const filters = {
      startDate: req.query.startDate,
      endDate: req.query.endDate
    };

    const statistics = await voterInteractionsService.getInteractionStatistics(accountId, filters);
    res.json(statistics);
  } catch (error) {
    logger.error('Error getting interaction statistics', error);
    res.status(400).json({ error: error.message });
  }
});

// Get contact interactions - Phase 4: Enhanced
app.get('/api/election/interactions/:contactId', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
  if (!isPostgresReady()) {
    return res.json({ interactions: [] });
  }
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const options = {
      interactionType: req.query.interactionType,
      interactionMethod: req.query.interactionMethod,
      startDate: req.query.startDate,
      endDate: req.query.endDate,
      limit: req.query.limit ? parseInt(req.query.limit) : null
    };

    const interactions = await voterInteractionsService.getContactInteractionHistory(
      accountId, 
      req.params.contactId,
      options
    );
    
    res.json({ interactions });
  } catch (error) {
    logger.error('Error getting interactions', error);
    res.status(400).json({ error: error.message });
  }
});

// Get contact support score - Phase 4
app.get('/api/election/contacts/:contactId/support-score', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
  if (!isPostgresReady()) {
    return res.json({ supportScore: null });
  }
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const supportScore = await voterInteractionsService.getContactSupportScore(
      accountId,
      req.params.contactId
    );

    res.json({ supportScore });
  } catch (error) {
    logger.error('Error getting support score', error);
    res.status(400).json({ error: error.message });
  }
});

// Get last contact info - Phase 4
app.get('/api/election/contacts/:contactId/last-contact', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
  if (!isPostgresReady()) {
    return res.json({ lastContact: null });
  }
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const lastContact = await voterInteractionsService.getLastContactInfo(
      accountId,
      req.params.contactId
    );

    res.json({ lastContact });
  } catch (error) {
    logger.error('Error getting last contact info', error);
    res.status(400).json({ error: error.message });
  }
});

// Get contacts by support score - Phase 4
app.get('/api/election/contacts/by-support-score', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
  if (!isPostgresReady()) {
    return res.json({ contacts: [] });
  }
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const filters = {
      minScore: req.query.minScore ? parseInt(req.query.minScore) : undefined,
      maxScore: req.query.maxScore ? parseInt(req.query.maxScore) : undefined,
      supportCategory: req.query.supportCategory,
      orderBy: req.query.orderBy || 'score',
      limit: req.query.limit ? parseInt(req.query.limit) : 100
    };

    const contacts = await voterInteractionsService.getContactsBySupportScore(accountId, filters);
    res.json({ contacts });
  } catch (error) {
    logger.error('Error getting contacts by support score', error);
    res.status(400).json({ error: error.message });
  }
});

// Mark a vote (immutable audit) - Phase 4: Enhanced scrutineering
app.post('/api/election/vote-marks', auth, requireActiveAccount, requireElectionMode, requireElectionPermission('mark_votes'), async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    // Validate input
    validation.validateVoteMark({
      contactId: req.body.contactId,
      pollNumber: req.body.pollNumber,
      riding: req.body.riding,
      province: req.body.province
    });

    const voteMark = await scrutineeringService.markVote({
      accountId,
      contactId: req.body.contactId,
      pollNumber: req.body.pollNumber,
      riding: req.body.riding,
      province: req.body.province,
      markedBy: user.id,
      verificationCode: req.body.verificationCode,
      notes: req.body.notes,
      metadata: req.body.metadata || {}
    });

    res.json({ success: true, voteMark });
  } catch (error) {
    logger.error('Error marking vote', error);
    const statusCode = error.statusCode || 400;
    res.status(statusCode).json({ error: error.message, code: error.code });
  }
});

// Get vote marks with filters and pagination - Phase 4
app.get('/api/election/vote-marks', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const filters = {
      pollNumber: req.query.pollNumber,
      riding: req.query.riding,
      province: req.query.province,
      markedBy: req.query.markedBy,
      startDate: req.query.startDate,
      endDate: req.query.endDate,
      contactSearch: req.query.contactSearch,
      limit: parseInt(req.query.limit || '100'),
      offset: parseInt(req.query.offset || '0')
    };

    const result = await scrutineeringService.getVoteMarks(accountId, filters);
    res.json(result);
  } catch (error) {
    logger.error('Error getting vote marks', error);
    res.status(400).json({ error: error.message });
  }
});

// Get vote marks for a specific poll - Phase 4
app.get('/api/election/vote-marks/poll/:pollNumber', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const voteMarks = await scrutineeringService.getVoteMarksByPoll(
      accountId,
      req.params.pollNumber,
      req.query.riding,
      req.query.province
    );

    res.json({ voteMarks });
  } catch (error) {
    logger.error('Error getting poll vote marks', error);
    res.status(400).json({ error: error.message });
  }
});

// Verify vote mark by verification code - Phase 4
app.get('/api/election/vote-marks/verify/:verificationCode', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const voteMark = await scrutineeringService.verifyVoteMark(accountId, req.params.verificationCode);

    if (!voteMark) {
      return res.status(404).json({ error: 'Vote mark not found' });
    }

    res.json({ voteMark });
  } catch (error) {
    logger.error('Error verifying vote mark', error);
    res.status(400).json({ error: error.message });
  }
});

// --- Scrutineering "Voted" (running tally only; does not update contact manager) ---

// Mark contact as voted (for running tally)
app.post('/api/election/scrutineering/voted', auth, requireActiveAccount, requireElectionMode, requireElectionPermission('mark_votes'), async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const contactId = req.body.contactId;
    if (!contactId) {
      return res.status(400).json({ error: 'contactId is required' });
    }
    const row = await scrutineeringService.setVoted(accountId, contactId, user.id);
    res.json({ success: true, voted: row });
  } catch (error) {
    logger.error('Error marking scrutineering voted', error);
    res.status(400).json({ error: error.message });
  }
});

// Unmark contact as voted
app.delete('/api/election/scrutineering/voted/:contactId', auth, requireActiveAccount, requireElectionMode, requireElectionPermission('mark_votes'), async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const contactId = req.params.contactId;
    await scrutineeringService.unsetVoted(accountId, contactId);
    res.json({ success: true });
  } catch (error) {
    logger.error('Error unmarking scrutineering voted', error);
    res.status(400).json({ error: error.message });
  }
});

// Get running tally and projected outcomes (support from interactions + contact categories)
app.get('/api/election/scrutineering/tally', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const getAccountContactsFn = () => getAccountContacts(accountId);
    const tally = await scrutineeringService.getTally(accountId, getAccountContactsFn);
    res.json(tally);
  } catch (error) {
    logger.error('Error getting scrutineering tally', error);
    res.status(400).json({ error: error.message });
  }
});

// Clear all voted data (manual reset before next election)
app.post('/api/election/scrutineering/clear-voted', auth, requireActiveAccount, requireElectionMode, requireElectionPermission('mark_votes'), async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const deleted = await scrutineeringService.clearAllVoted(accountId);
    res.json({ success: true, deleted });
  } catch (error) {
    logger.error('Error clearing scrutineering voted', error);
    res.status(400).json({ error: error.message });
  }
});

// Get contact's voted status and effective support (for verify-voter flow)
app.get('/api/election/scrutineering/contact/:contactId/status', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const contactId = req.params.contactId;
    const [isVoted, supportScore] = await Promise.all([
      scrutineeringService.isContactVoted(accountId, contactId),
      voterInteractionsService.getContactSupportScore(accountId, contactId)
    ]);
    let supportCategory = supportScore.supportCategory || 'unknown';
    if (supportCategory === 'unknown') {
      const contacts = await getAccountContacts(accountId);
      const contact = (contacts || []).find(c => c.id === contactId);
      if (contact && Array.isArray(contact.categories)) {
        const normalized = contact.categories.map(cat => {
          if (!cat || typeof cat !== 'string') return null;
          const lower = cat.toLowerCase().replace(/\s+/g, '_');
          const raw = cat.toLowerCase();
          if (['strong_oppose', 'strongoppose', 'opposed', 'oppose'].some(p => lower.includes(p))) return 'strong_oppose';
          if (['likely_oppose', 'likelyoppose', 'non_supporter', 'nonsupporter', 'non-supporter', 'liberal', 'ndp', 'green'].some(p => lower.includes(p) || raw.includes(p))) return 'likely_oppose';
          if (['strong_support', 'strongsupport'].some(p => lower.includes(p))) return 'strong_support';
          if (['likely_support', 'likelysupport', 'supporter', 'member', 'donor', 'volunteer', 'board', 'lapsed'].some(p => lower.includes(p) || raw.includes(p))) return 'likely_support';
          if (lower === 'undecided' || raw === 'undecided') return 'undecided';
          return null;
        }).find(Boolean);
        if (normalized) supportCategory = normalized;
      }
    }
    res.json({ isVoted, supportCategory, supportScore: supportScore || null });
  } catch (error) {
    logger.error('Error getting scrutineering contact status', error);
    res.status(400).json({ error: error.message });
  }
});

// Get poll turnout summary - Phase 4: Enhanced
app.get('/api/election/poll-turnout', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const filters = {
      riding: req.query.riding,
      province: req.query.province
    };

    const summary = await scrutineeringService.getTurnoutSummary(accountId, filters);
    res.json(summary);
  } catch (error) {
    logger.error('Error getting poll turnout', error);
    res.status(400).json({ error: error.message });
  }
});

// Get detailed poll turnout - Phase 4
app.get('/api/election/poll-turnout/:pollNumber', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const details = await scrutineeringService.getPollTurnoutDetails(
      accountId,
      req.params.pollNumber,
      req.query.riding,
      req.query.province
    );

    if (!details) {
      return res.status(404).json({ error: 'Poll turnout not found' });
    }

    res.json(details);
  } catch (error) {
    logger.error('Error getting poll turnout details', error);
    res.status(400).json({ error: error.message });
  }
});

// Save election list - Phase 4: Enhanced
app.post('/api/election/lists', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    // Validate input
    validation.validateList({
      name: req.body.name,
      filterConfig: req.body.filterConfig
    });

    // Sanitize filter config
    const sanitizedFilterConfig = validation.sanitizeFilterConfig(req.body.filterConfig || {});

    const list = await electionListsService.saveList({
      id: req.body.id || `list_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      accountId,
      userId: user.id,
      name: req.body.name,
      description: req.body.description,
      filterConfig: sanitizedFilterConfig,
      contactIds: req.body.contactIds || null, // Optional: for static lists
      isShared: req.body.isShared || false
    });

    res.json({ success: true, list });
  } catch (error) {
    logger.error('Error saving election list', error);
    const statusCode = error.statusCode || 400;
    res.status(statusCode).json({ error: error.message, code: error.code });
  }
});

// Get election lists - Phase 4: Enhanced
app.get('/api/election/lists', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    let lists = await electionListsService.getLists(accountId, user.id) || [];
    // Ensure contact_count reflects actual static list size (source of truth: _staticContactIds.length)
    lists = lists.map(list => {
      const cfg = list.filter_config || {};
      const staticIds = cfg._staticContactIds;
      if (Array.isArray(staticIds)) {
        return { ...list, contact_count: staticIds.length };
      }
      return list;
    });
    res.json({ lists });
  } catch (error) {
    logger.error('Error getting election lists', error);
    res.json({ lists: [] });
  }
});

// Get single contact by id (same data source as lists: PostgreSQL or JSON) - for Record note from Navigation
app.get('/api/election/contact/:contactId', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const contactId = req.params.contactId;
    if (!contactId) return res.status(400).json({ error: 'Contact ID required' });
    let contact = null;
    // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
    if (isPostgresReady()) {
      const result = await electionListsService.getContactsByFilters(
        accountId,
        { _staticContactIds: [contactId] },
        { limit: 1, offset: 0 }
      );
      contact = (result.contacts && result.contacts[0]) ? result.contacts[0] : null;
    }
    if (!contact) {
      const contacts = await getAccountContacts(accountId);
      contact = contacts.find(c => String(c.id) === String(contactId)) || null;
    }
    if (!contact) return res.status(404).json({ error: 'Contact not found' });
    const c = contact;
    const normalized = {
      id: c.id,
      firstName: c.firstName ?? c.first_name,
      lastName: c.lastName ?? c.last_name,
      name: c.name,
      email: c.email,
      phone: c.phone,
      address: c.address,
      city: c.city,
      province: c.province,
      postalCode: c.postalCode ?? c.postal_code,
      category: c.category,
      categories: c.categories
    };
    res.json(normalized);
  } catch (error) {
    logger.error('Error getting election contact', error);
    res.status(400).json({ error: error.message });
  }
});

// Get unique categories and cities for election lists filters - Phase 4
// IMPORTANT: This route must come BEFORE /api/election/lists/:listId to avoid route conflicts
app.get('/api/election/lists/filter-options', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;
    const contacts = await getAccountContacts(accountId);
    
    // Extract unique categories from contacts (handle both single category and categories array)
    const categoriesSet = new Set();
    contacts.forEach(contact => {
      if (Array.isArray(contact.categories)) {
        contact.categories.forEach(cat => {
          if (cat && cat.trim()) categoriesSet.add(cat.trim());
        });
      } else if (contact.category && contact.category.trim()) {
        categoriesSet.add(contact.category.trim());
      }
    });
    const categories = Array.from(categoriesSet).sort();
    
    // Extract unique cities from contacts
    const citiesSet = new Set();
    contacts.forEach(contact => {
      if (contact.city && contact.city.trim()) {
        citiesSet.add(contact.city.trim());
      }
    });
    const cities = Array.from(citiesSet).sort();

    // Extract unique provinces from contacts
    const provincesSet = new Set();
    contacts.forEach(contact => {
      if (contact.province && contact.province.trim()) {
        provincesSet.add(contact.province.trim());
      }
    });
    const provinces = Array.from(provincesSet).sort();
    
    res.json({ categories, cities, provinces });
  } catch (error) {
    logger.error('Error getting filter options', error);
    res.status(400).json({ error: error.message });
  }
});

// Get a specific election list - Phase 4
app.get('/api/election/lists/:listId', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    let list = await electionListsService.getList(req.params.listId, accountId);
    if (!list) {
      return res.status(404).json({ error: 'List not found' });
    }
    const cfg = list.filter_config || {};
    if (Array.isArray(cfg._staticContactIds)) {
      list = { ...list, contact_count: cfg._staticContactIds.length };
    }
    res.json({ list });
  } catch (error) {
    logger.error('Error getting election list', error);
    res.status(400).json({ error: error.message });
  }
});

// Get contacts matching a filter configuration - Phase 4
app.post('/api/election/lists/contacts', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const options = {
      limit: req.body.limit || req.query.limit ? parseInt(req.body.limit || req.query.limit) : 100,
      offset: req.body.offset || req.query.offset ? parseInt(req.body.offset || req.query.offset) : 0,
      orderBy: req.body.orderBy || req.query.orderBy || 'support_score'
    };

    // IMPORTANT: use Postgres only when ready; otherwise fallback to JSON to avoid hanging /api/user
    if (isPostgresReady()) {
      // Use PostgreSQL service
      const result = await electionListsService.getContactsByFilters(
        accountId,
        req.body.filterConfig || {},
        options
      );
      return res.json(result);
    }

    // JSON fallback - filter contacts from JSON file
    const contacts = await getAccountContacts(accountId);
    let filteredContacts = [...contacts];

    const filterConfig = req.body.filterConfig || {};
    
    // Handle static list with specific contact IDs (compare as strings to avoid type mismatch)
    if (filterConfig._staticContactIds && Array.isArray(filterConfig._staticContactIds) && filterConfig._staticContactIds.length > 0) {
      const staticIdSet = new Set(filterConfig._staticContactIds.map(id => String(id)));
      filteredContacts = filteredContacts.filter(c => staticIdSet.has(String(c.id)));
    } else {
      // Apply dynamic filters (match contact manager / db: name, address, city, province, postalCode, category)
      if (filterConfig.search && filterConfig.search.trim()) {
        const q = filterConfig.search.trim().toLowerCase();
        filteredContacts = filteredContacts.filter(c => {
          const name = [c.name, c.firstName, c.lastName].filter(Boolean).join(' ').toLowerCase();
          const email = (c.email || '').toLowerCase();
          const phone = (c.phone || '').toLowerCase();
          return name.includes(q) || email.includes(q) || phone.includes(q);
        });
      }
      if (filterConfig.address && filterConfig.address.trim()) {
        const addr = filterConfig.address.trim().toLowerCase();
        filteredContacts = filteredContacts.filter(c =>
          (c.address || '').toLowerCase().includes(addr)
        );
      }
      if (filterConfig.postalCode && filterConfig.postalCode.trim()) {
        const pc = filterConfig.postalCode.trim().toLowerCase().replace(/\s/g, '');
        filteredContacts = filteredContacts.filter(c => {
          const cpc = (c.postalCode || c.postal_code || '').toLowerCase().replace(/\s/g, '');
          return cpc.includes(pc) || pc.includes(cpc);
        });
      }
      if (filterConfig.pollNumber) {
        filteredContacts = filteredContacts.filter(c => c.pollNumber === filterConfig.pollNumber);
      }
      if (filterConfig.province) {
        filteredContacts = filteredContacts.filter(c =>
          c.province && c.province.trim().toLowerCase() === filterConfig.province.trim().toLowerCase()
        );
      }
      if (filterConfig.city) {
        filteredContacts = filteredContacts.filter(c => 
          c.city && c.city.toLowerCase() === filterConfig.city.toLowerCase()
        );
      }
      if (filterConfig.category) {
        filteredContacts = filteredContacts.filter(c => {
          if (Array.isArray(c.categories)) {
            return c.categories.includes(filterConfig.category);
          } else if (c.category) {
            return c.category === filterConfig.category;
          }
          return false;
        });
      }
      if (filterConfig.supportCategory) {
        // For JSON, we'd need to calculate support scores from interactions
        // For now, just return all contacts if support category is requested
      }
    }

    // Apply pagination
    const total = filteredContacts.length;
    const start = options.offset || 0;
    const end = start + (options.limit || 100);
    const paginatedContacts = filteredContacts.slice(start, end);

    if (filterConfig._staticContactIds && Array.isArray(filterConfig._staticContactIds)) {
      logger.info('[election/lists/contacts] static list: requestedIds=' + filterConfig._staticContactIds.length + ' matched=' + total + ' accountId=' + accountId);
    }
    res.json({
      contacts: paginatedContacts,
      total,
      limit: options.limit || 100,
      offset: options.offset || 0,
      hasMore: end < total
    });
  } catch (error) {
    logger.error('Error getting filtered contacts', error);
    res.status(400).json({ error: error.message });
  }
});

// Update election list - Phase 4
app.put('/api/election/lists/:listId', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    // Validate input
    validation.validateList({
      name: req.body.name,
      filterConfig: req.body.filterConfig || {}
    });

    // Get existing list to preserve filter config and contact IDs if not provided
    const existingList = await electionListsService.getList(req.params.listId, accountId);
    if (!existingList) {
      return res.status(404).json({ error: 'List not found' });
    }

    // Use existing filter config and contact IDs if not provided in update
    const filterConfig = req.body.filterConfig || existingList.filter_config || {};
    const contactIds = req.body.contactIds !== undefined ? req.body.contactIds : 
                      (existingList.filter_config && existingList.filter_config._staticContactIds) || null;

    const list = await electionListsService.saveList({
      id: req.params.listId,
      accountId,
      userId: user.id,
      name: req.body.name,
      description: req.body.description,
      filterConfig: filterConfig,
      contactIds: contactIds,
      isShared: req.body.isShared !== undefined ? req.body.isShared : existingList.is_shared
    });

    res.json({ success: true, list });
  } catch (error) {
    logger.error('Error updating election list', error);
    const statusCode = error.statusCode || 400;
    res.status(statusCode).json({ error: error.message, code: error.code });
  }
});

// Delete election list - Phase 4
app.delete('/api/election/lists/:listId', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    await electionListsService.deleteList(req.params.listId, accountId);
    res.json({ success: true });
  } catch (error) {
    logger.error('Error deleting election list', error);
    res.status(400).json({ error: error.message });
  }
});

// Refresh list contact count - Phase 4
app.post('/api/election/lists/:listId/refresh', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const list = await electionListsService.refreshListCount(req.params.listId, accountId);
    res.json({ success: true, list });
  } catch (error) {
    logger.error('Error refreshing list count', error);
    res.status(400).json({ error: error.message });
  }
});

// Create canvass assignment - Phase 4: Enhanced
app.post('/api/election/canvass/assignments', auth, requireActiveAccount, requireElectionMode, requireElectionPermission('manage_canvassing'), async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const assignment = await canvassingService.createAssignment({
      id: req.body.id || `assignment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      accountId,
      assignedTo: req.body.assignedTo,
      assignedBy: user.id,
      areaName: req.body.areaName,
      areaDescription: req.body.areaDescription,
      areaBoundaries: req.body.areaBoundaries,
      contactIds: req.body.contactIds || [],
      priority: req.body.priority || 0,
      dueDate: req.body.dueDate,
      notes: req.body.notes,
      metadata: req.body.metadata || {}
    });

    res.json({ success: true, assignment });
  } catch (error) {
    logger.error('Error creating canvass assignment', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user's canvass assignments - Phase 4
app.get('/api/election/canvass/assignments', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const filters = {
      status: req.query.status
    };

    // Check if user is admin/organizer (can see all assignments)
    const isAdmin = user.isAdmin || user.userType === 'app_owner';
    const hasManagePermission = (user.permissions || []).includes('manage_canvassing') || 
                                (user.permissions || []).includes('*');

    let assignments;
    if (isAdmin || hasManagePermission) {
      assignments = await canvassingService.getAllAssignments(accountId, filters);
    } else {
      assignments = await canvassingService.getUserAssignments(accountId, user.id, filters);
    }

    res.json({ assignments });
  } catch (error) {
    logger.error('Error getting canvass assignments', error);
    res.status(400).json({ error: error.message });
  }
});

// Get a specific assignment - Phase 4
app.get('/api/election/canvass/assignments/:assignmentId', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const assignment = await canvassingService.getAssignment(req.params.assignmentId, accountId);
    
    if (!assignment) {
      return res.status(404).json({ error: 'Assignment not found' });
    }

    // Check if user has access (assigned to them or is admin)
    const isAdmin = user.isAdmin || user.userType === 'app_owner';
    const hasManagePermission = (user.permissions || []).includes('manage_canvassing') || 
                                (user.permissions || []).includes('*');
    
    if (!isAdmin && !hasManagePermission && assignment.assigned_to !== user.id) {
      return res.status(403).json({ error: 'Access denied' });
    }

    res.json({ assignment });
  } catch (error) {
    logger.error('Error getting canvass assignment', error);
    res.status(400).json({ error: error.message });
  }
});

// Update assignment - Phase 4
app.put('/api/election/canvass/assignments/:assignmentId', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    // Check permissions
    const isAdmin = user.isAdmin || user.userType === 'app_owner';
    const hasManagePermission = (user.permissions || []).includes('manage_canvassing') || 
                                (user.permissions || []).includes('*');
    
    const assignment = await canvassingService.getAssignment(req.params.assignmentId, accountId);
    if (!assignment) {
      return res.status(404).json({ error: 'Assignment not found' });
    }

    if (!isAdmin && !hasManagePermission && assignment.assigned_to !== user.id) {
      return res.status(403).json({ error: 'Access denied' });
    }

    const updated = await canvassingService.updateAssignment(
      req.params.assignmentId,
      accountId,
      req.body
    );

    res.json({ success: true, assignment: updated });
  } catch (error) {
    logger.error('Error updating canvass assignment', error);
    res.status(400).json({ error: error.message });
  }
});

// Complete assignment - Phase 4
app.post('/api/election/canvass/assignments/:assignmentId/complete', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const assignment = await canvassingService.completeAssignment(
      req.params.assignmentId,
      accountId,
      user.id
    );

    res.json({ success: true, assignment });
  } catch (error) {
    logger.error('Error completing canvass assignment', error);
    res.status(400).json({ error: error.message });
  }
});

// Record canvass event - Phase 4: Enhanced
app.post('/api/election/canvass/events', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const event = await canvassingService.recordEvent({
      accountId,
      assignmentId: req.body.assignmentId,
      userId: user.id,
      contactId: req.body.contactId,
      eventType: req.body.eventType,
      eventData: req.body.eventData || {},
      location: req.body.location,
      notes: req.body.notes
    });

    res.json({ success: true, event });
  } catch (error) {
    logger.error('Error recording canvass event', error);
    res.status(400).json({ error: error.message });
  }
});

// Get events for an assignment - Phase 4
app.get('/api/election/canvass/assignments/:assignmentId/events', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const events = await canvassingService.getAssignmentEvents(req.params.assignmentId, accountId);
    res.json({ events });
  } catch (error) {
    logger.error('Error getting canvass events', error);
    res.status(400).json({ error: error.message });
  }
});

// Get canvassing completion statistics - Phase 4
app.get('/api/election/canvass/statistics', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const filters = {
      assignedTo: req.query.assignedTo
    };

    const statistics = await canvassingService.getCompletionStatistics(accountId, filters);
    res.json(statistics);
  } catch (error) {
    logger.error('Error getting canvassing statistics', error);
    res.status(400).json({ error: error.message });
  }
});

// Export vote marks to CSV
app.get('/api/election/export/vote-marks.csv', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const filters = {
      pollNumber: req.query.pollNumber,
      riding: req.query.riding,
      province: req.query.province,
      startDate: req.query.startDate,
      endDate: req.query.endDate
    };

    const csv = await exportService.exportVoteMarksToCSV(accountId, filters);

    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="vote-marks-${Date.now()}.csv"`);
    res.send(csv);
  } catch (error) {
    logger.error('Error exporting vote marks', error);
    res.status(400).json({ error: error.message });
  }
});

// Export interactions to CSV
app.get('/api/election/export/interactions.csv', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const filters = {
      contactId: req.query.contactId,
      interactionType: req.query.interactionType,
      startDate: req.query.startDate,
      endDate: req.query.endDate
    };

    const csv = await exportService.exportInteractionsToCSV(accountId, filters);

    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="interactions-${Date.now()}.csv"`);
    res.send(csv);
  } catch (error) {
    logger.error('Error exporting interactions', error);
    res.status(400).json({ error: error.message });
  }
});

// Export poll turnout to CSV
app.get('/api/election/export/poll-turnout.csv', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const filters = {
      riding: req.query.riding,
      province: req.query.province
    };

    const csv = await exportService.exportPollTurnoutToCSV(accountId, filters);

    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="poll-turnout-${Date.now()}.csv"`);
    res.send(csv);
  } catch (error) {
    logger.error('Error exporting poll turnout', error);
    res.status(400).json({ error: error.message });
  }
});

// Get admin dashboard data
app.get('/api/election/admin/dashboard', auth, requireActiveAccount, requireElectionMode, requireElectionPermission('view_dashboard'), async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    const filters = {
      startDate: req.query.startDate,
      endDate: req.query.endDate
    };

    const dashboardData = await adminDashboardService.getDashboardData(accountId, filters);
    res.json(dashboardData);
  } catch (error) {
    logger.error('Error getting dashboard data', error);
    res.status(400).json({ error: error.message });
  }
});

// Bulk record interactions
app.post('/api/election/bulk/interactions', auth, requireActiveAccount, requireElectionMode, async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    if (!Array.isArray(req.body.interactions)) {
      return res.status(400).json({ error: 'interactions must be an array' });
    }

    const results = await bulkOperationsService.bulkRecordInteractions(
      accountId,
      user.id,
      req.body.interactions
    );

    res.json({ success: true, results });
  } catch (error) {
    logger.error('Error bulk recording interactions', error);
    res.status(400).json({ error: error.message });
  }
});

// Bulk update poll turnout
app.post('/api/election/bulk/poll-turnout', auth, requireActiveAccount, requireElectionMode, requireElectionPermission('manage_turnout'), async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    if (!Array.isArray(req.body.turnoutData)) {
      return res.status(400).json({ error: 'turnoutData must be an array' });
    }

    const results = await bulkOperationsService.bulkUpdatePollTurnout(
      accountId,
      user.id,
      req.body.turnoutData
    );

    res.json({ success: true, results });
  } catch (error) {
    logger.error('Error bulk updating poll turnout', error);
    res.status(400).json({ error: error.message });
  }
});

// Bulk create canvass assignments
app.post('/api/election/bulk/assignments', auth, requireActiveAccount, requireElectionMode, requireElectionPermission('manage_canvassing'), async (req, res) => {
  try {
    const user = await findUserById(req.user.id);
    const accountId = user.accountId || user.id;

    if (!Array.isArray(req.body.assignments)) {
      return res.status(400).json({ error: 'assignments must be an array' });
    }

    const results = await bulkOperationsService.bulkCreateAssignments(
      accountId,
      user.id,
      req.body.assignments
    );

    res.json({ success: true, results });
  } catch (error) {
    logger.error('Error bulk creating assignments', error);
    res.status(400).json({ error: error.message });
  }
});

// ============================================================================
// END PHASE 3: ELECTION MODE API ROUTES
// ============================================================================

// Apply secure error handler (must be last middleware)
app.use(secureErrorHandler);

// Start the server after all routes are defined
app.listen(PORT, async () => {
  console.log(`[SERVER] Listening on port ${PORT}`);

  // Initialize system sender on startup
  try {
    await initializeSystemSender();
  } catch (error) {
    console.error('Failed to initialize system sender:', error);
  }

  // Phase 2: Initialize PostgreSQL after server is up so startup is never blocked by DB
  if (isPostgresEnabled()) {
    (async () => {
      try {
        initializePool();
        await runMigrations();
        setPgReady(true);
        logger.info('PostgreSQL backend initialized and migrations completed');
      } catch (error) {
        logger.error('PostgreSQL initialization failed', error);
        // Don't set pgReady - requests will use JSON and page won't hang
      }
    })();
  }
});

// Graceful shutdown - close SMTP connections properly
const gracefulShutdown = async (signal) => {
  console.log(`\n${signal} received. Closing SMTP connections and shutting down gracefully...`);
  
  try {
    // Close all cached user SMTP transporters
    for (const [accountId, transporter] of userTransporterCache.entries()) {
      try {
        if (transporter && typeof transporter.close === 'function') {
          await transporter.close();
          console.log(`[SMTP] Closed transporter for account ${accountId}`);
        }
      } catch (closeError) {
        console.error(`[SMTP] Error closing transporter for account ${accountId}:`, closeError.message);
      }
    }
    userTransporterCache.clear();
    
    // Close all global SMTP transporters
    for (const { name, transporter } of globalTransporters) {
      try {
        if (transporter && typeof transporter.close === 'function') {
          await transporter.close();
          console.log(`[SMTP] Closed global transporter: ${name}`);
        }
      } catch (closeError) {
        console.error(`[SMTP] Error closing global transporter ${name}:`, closeError.message);
      }
    }
    
    console.log('[SMTP] All SMTP connections closed successfully');
  } catch (error) {
    console.error('[SMTP] Error during graceful shutdown:', error.message);
  }
  
  process.exit(0);
};

// Handle shutdown signals
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('exit', () => {
  console.log('[SERVER] Process exiting...');
});

