<%- include('partials/nav') %>

<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 min-w-0" id="app">
    <div class="py-6 space-y-6 min-w-0">
        <!-- Contact Management -->
        <div class="bg-white shadow rounded-lg p-6 min-w-0">
            <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3 mb-6">
                <div class="flex items-center space-x-4">
                    <h2 class="text-xl font-semibold">Contact Management</h2>
                    <span class="text-sm text-gray-600 bg-gray-100 px-3 py-1 rounded-full">
                        {{ totalContactsCount }} contacts
                    </span>
                    <span v-if="categoryFilter" class="text-sm text-blue-600 bg-blue-100 px-3 py-1 rounded-full">
                        {{ filteredContacts.length }} in "{{ categoryFilter }}"
                    </span>
                    <span v-if="search" class="text-sm text-green-600 bg-green-100 px-3 py-1 rounded-full">
                        {{ filteredContacts.length }} results for "{{ search }}"
                    </span>
                </div>
                <div class="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
                    <div class="relative w-full sm:w-auto">
                        <label for="contactSearch" class="sr-only">Search contacts</label>
                        <input v-model="search" 
                               id="contactSearch"
                               type="text" 
                               class="border rounded-md px-3 py-2 pr-10 w-full sm:w-80 text-sm" 
                               placeholder="Search contacts..."
                               aria-label="Search contacts">
                        <button v-if="search" 
                                @click="search = ''" 
                                type="button"
                                aria-label="Clear search"
                                class="absolute right-3 top-1/2 -translate-y-1/2 text-red-500 hover:text-red-700 bg-white rounded-full p-1">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    <label for="categoryFilter" class="sr-only">Filter by category</label>
                    <select v-model="categoryFilter" 
                            id="categoryFilter"
                            class="border rounded-md px-3 py-2 text-sm w-full sm:w-auto"
                            aria-label="Filter contacts by category">
                        <option value="">All Categories</option>
                        <option v-for="category in uniqueCategories" 
                                :key="category" 
                                :value="category">
                            {{ category }}
                        </option>
                    </select>
                    <label for="unsubscribeFilter" class="sr-only">Filter by subscription status</label>
                    <select v-model="unsubscribeFilter" 
                            id="unsubscribeFilter"
                            class="border rounded-md px-3 py-2 text-sm w-full sm:w-auto"
                            aria-label="Filter contacts by subscription status">
                        <option value="">All Contacts</option>
                        <option value="subscribed_all">Subscribed to All</option>
                        <option value="unsubscribed_email">Unsubscribed from Email</option>
                        <option value="unsubscribed_sms">Unsubscribed from SMS</option>
                        <option value="unsubscribed_voice">Unsubscribed from Voice</option>
                        <option value="unsubscribed_any">Unsubscribed from Any</option>
                        <option value="unsubscribed_all">Unsubscribed from All</option>
                    </select>
                    <button @click="compactView = !compactView" 
                            type="button"
                            :aria-label="compactView ? 'Switch to normal view' : 'Switch to compact view'"
                            :class="{
                                'w-full sm:w-auto px-3 py-2 rounded-md text-sm font-medium': true,
                                'bg-indigo-600 text-white': compactView,
                                'bg-gray-200 text-gray-700 hover:bg-gray-300': !compactView
                            }">
                        {{ compactView ? 'Normal View' : 'Compact View' }}
                    </button>
                </div>
            </div>

            <!-- Add Contact Form -->
            <div class="mb-6">
                <div class="flex space-x-4 mb-4">
                    <button @click="showAddForm = !showAddForm" 
                            type="button"
                            :aria-label="showAddForm ? 'Hide add contact form' : 'Show add contact form'"
                            :aria-expanded="showAddForm"
                            class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">
                        {{ showAddForm ? 'Hide Form' : 'Add New Contact' }}
                    </button>
                    <button @click="showTrash = !showTrash" 
                            type="button"
                            :aria-label="showTrash ? 'Hide trash contacts' : 'View trash contacts'"
                            :aria-expanded="showTrash"
                            class="text-white px-4 py-2 rounded border"
                            style="display: inline-block !important; visibility: visible !important; background-color: #3b82f6 !important; border-color: #2563eb !important;">
                        {{ showTrash ? 'Hide Trash' : 'View Trash' }}
                        <span v-if="trashCount > 0" 
                              class="ml-2 text-white px-2 py-1 rounded-full text-xs"
                              :aria-label="`${trashCount} contacts in trash`"
                              style="background-color: #1d4ed8 !important;">
                            {{ trashCount }}
                        </span>
                    </button>
                    <button v-if="user && user.userType !== 'user'" 
                            @click="confirmDeleteAllContacts" 
                            type="button"
                            aria-label="Delete all contacts permanently"
                            class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">
                        Delete All Contacts
                    </button>
                    <button v-if="canUndoUpload" 
                            @click="showUndoConfirmation" 
                            type="button"
                            aria-label="Undo most recent contact upload"
                            style="background-color: #f59e0b; color: white; padding: 8px 16px; border-radius: 6px; border: none; margin-left: 8px; display: inline-flex; align-items: center; gap: 8px; font-weight: 500; transition: background-color 0.2s;"
                            onmouseover="this.style.backgroundColor='#d97706'"
                            onmouseout="this.style.backgroundColor='#f59e0b'">
                        <svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path>
                        </svg>
                        <span>Undo Upload</span>
                        <span style="background-color: #fbbf24; color: #92400e; padding: 2px 8px; border-radius: 9999px; font-size: 0.75rem; font-weight: 600;">
                            {{ mostRecentUpload.contactCount }}
                        </span>
                    </button>
                    <button @click="exportToExcel" 
                            type="button"
                            :disabled="exportingContacts"
                            :aria-label="getExportButtonLabel()"
                            class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        <span>{{ exportingContacts ? 'Exporting...' : 'Export to Excel' }}</span>
                        <span v-if="getExportCount() > 0" 
                              class="bg-blue-600 text-white px-2 py-1 rounded-full text-xs"
                              :aria-label="`${getExportCount()} contacts will be exported`">
                            {{ getExportCount() }}
                        </span>
                    </button>

                </div>
                
                <div v-if="showAddForm" class="mt-4" role="form" aria-label="Add new contact form">
                    <!-- Special EDA Structure Form -->
                    <div v-if="contactStructure === 'eda_special'" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                            <label for="newContactName" class="sr-only">Name (required)</label>
                            <input v-model="newContact.name" 
                                   id="newContactName"
                                   type="text"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="Name *"
                                   aria-label="Name (required)"
                                   required>
                        </div>
                        <div>
                            <label for="newContactRiding" class="sr-only">Riding</label>
                            <input v-model="newContact.riding" 
                                   id="newContactRiding"
                                   type="text"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="Riding (e.g., 48027 - Lakeland)"
                                   aria-label="Riding">
                        </div>
                        <div>
                            <label for="newContactProvince" class="sr-only">Province</label>
                            <input v-model="newContact.province" 
                                   id="newContactProvince"
                                   type="text"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="Province (e.g., Alberta)"
                                   aria-label="Province">
                        </div>
                        <div class="relative">
                            <label for="newContactEmail" class="sr-only">Email</label>
                            <input v-model="newContact.email" 
                                   id="newContactEmail"
                                   type="email"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="Email (e.g., john@example.com)"
                                   aria-label="Email address"
                                   @focus="showEmailDomains = true"
                                   @blur="hideEmailDomains(); formatEmail()">
                            
                            <!-- Quick Email Domain Buttons -->
                            <div v-if="showEmailDomains" 
                                 role="listbox" 
                                 aria-label="Popular email domains"
                                 class="absolute z-50 w-full bg-white border border-gray-300 rounded-md shadow-lg mt-1 p-2">
                                <div class="text-xs text-gray-600 mb-2 font-medium" role="presentation">Quick select:</div>
                                <div class="flex flex-wrap gap-2">
                                    <button v-for="domain in popularEmailDomains" 
                                            :key="domain"
                                            @click="selectEmailDomain(domain)"
                                            type="button"
                                            role="option"
                                            :aria-label="`Select ${domain} domain`"
                                            class="px-3 py-1.5 text-xs bg-indigo-50 hover:bg-indigo-100 text-indigo-700 border border-indigo-200 rounded transition-colors">
                                        {{ domain }}
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div>
                            <label for="newContactRole" class="sr-only">Role</label>
                            <input v-model="newContact.role" 
                                   id="newContactRole"
                                   type="text"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="Role (e.g., EDA President)"
                                   aria-label="Role">
                        </div>
                        <div class="relative">
                            <label for="newContactPhone" class="sr-only">Phone Number</label>
                            <input v-model="newContact.phone" 
                                   id="newContactPhone"
                                   type="tel"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="(___) ___-____"
                                   aria-label="Phone number"
                                   @input="handlePhoneInput()"
                                   @keydown="handlePhoneKeydown()"
                                   @blur="formatPhone()">
                        </div>
                        <div>
                            <label for="newContactCategories" class="block text-sm font-medium text-gray-700">Categories</label>
                            <div class="relative">
                                <div @click.stop="showCategoryDropdown = !showCategoryDropdown"
                                     class="border rounded-md px-3 py-2 w-full cursor-pointer bg-white min-h-[42px] flex items-center flex-wrap gap-1">
                                    <span v-if="newContact.categories.length === 0" class="text-gray-400 text-sm">
                                        Select categories...
                                    </span>
                                    <span v-for="cat in newContact.categories"
                                          :key="cat"
                                          class="inline-flex items-center px-2 py-0.5 text-xs font-medium bg-indigo-100 text-indigo-800 rounded">
                                        {{ cat }}
                                        <button @click.stop="removeCategory(cat, false)"
                                                type="button"
                                                class="ml-1 text-indigo-600 hover:text-indigo-800">
                                            ×
                                        </button>
                                    </span>
                                </div>
                                
                                <!-- Dropdown Panel -->
                                <div v-if="showCategoryDropdown"
                                     @click.stop
                                     class="absolute left-0 right-0 mt-1 bg-white border-2 border-indigo-500 rounded-md shadow-xl max-h-64 overflow-y-auto"
                                     style="z-index: 9999;">
                                    <div class="p-3">
                                        <div class="flex justify-between items-center mb-2 pb-2 border-b">
                                            <span class="text-sm font-medium text-gray-700">Select Categories</span>
                                            <button @click="showCategoryDropdown = false"
                                                    type="button"
                                                    class="text-gray-400 hover:text-gray-600">
                                                ✕
                                            </button>
                                        </div>
                                        
                                        <!-- Category Checkboxes -->
                                        <div class="space-y-1">
                                            <div v-for="category in uniqueCategories" 
                                                 :key="category"
                                                 class="flex items-center py-1.5 px-2 hover:bg-indigo-50 rounded cursor-pointer">
                                                <input type="checkbox"
                                                       :id="'new-cat-' + category"
                                                       :value="category"
                                                       v-model="newContact.categories"
                                                       class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 mr-2 cursor-pointer">
                                                <label :for="'new-cat-' + category" class="text-sm flex-1 cursor-pointer">
                                                    {{ category }}
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div>
                            <label for="newContactPollNumber" class="sr-only">Poll #</label>
                            <input v-model="newContact.pollNumber" 
                                   id="newContactPollNumber"
                                   type="text"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="Poll #"
                                   aria-label="Poll number">
                        </div>
                        <div class="md:col-span-3">
                            <label for="newContactNotesEDA" class="block text-sm font-medium text-gray-700 mb-1">Notes (volunteer notes)</label>
                            <textarea v-model="newContact.notes" 
                                      id="newContactNotesEDA"
                                      rows="3"
                                      class="border rounded-md px-3 py-2 w-full" 
                                      placeholder="Add notes about this contact..."
                                      aria-label="Notes"></textarea>
                        </div>
                    </div>
                    
                    <!-- Standard Structure Form -->
                    <div v-else class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                            <label for="newContactFirstName" class="sr-only">First Name (required)</label>
                            <input v-model="newContact.firstName" 
                                   id="newContactFirstName"
                                   type="text"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="First Name *"
                                   aria-label="First Name (required)"
                                   required
                                   @input="validateField('firstName', $event.target.value)">
                        </div>
                        <div>
                            <label for="newContactLastName" class="sr-only">Last Name (required)</label>
                            <input v-model="newContact.lastName" 
                                   id="newContactLastName"
                                   type="text"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="Last Name *"
                                   aria-label="Last Name (required)"
                                   required
                                   @input="validateField('lastName', $event.target.value)">
                        </div>
                        <div class="relative">
                            <label for="newContactEmail" class="sr-only">Email</label>
                            <input v-model="newContact.email" 
                                   id="newContactEmail"
                                   type="email"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="Email (e.g., john@example.com)"
                                   aria-label="Email address"
                                   @focus="showEmailDomains = true"
                                   @blur="hideEmailDomains(); validateField('email', $event.target.value); formatEmail()">
                            
                            <!-- Quick Email Domain Buttons -->
                            <div v-if="showEmailDomains" 
                                 role="listbox" 
                                 aria-label="Popular email domains"
                                 class="absolute z-50 w-full bg-white border border-gray-300 rounded-md shadow-lg mt-1 p-2">
                                <div class="text-xs text-gray-600 mb-2 font-medium" role="presentation">Quick select:</div>
                                <div class="flex flex-wrap gap-2">
                                    <button v-for="domain in popularEmailDomains" 
                                            :key="domain"
                                            @click="selectEmailDomain(domain)"
                                            type="button"
                                            role="option"
                                            :aria-label="`Select ${domain} domain`"
                                            class="px-3 py-1.5 text-xs bg-indigo-50 hover:bg-indigo-100 text-indigo-700 border border-indigo-200 rounded transition-colors">
                                        {{ domain }}
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="relative">
                            <label for="newContactPhone" class="sr-only">Phone Number</label>
                            <input v-model="newContact.phone" 
                                   id="newContactPhone"
                                   type="tel"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="(___) ___-____"
                                   aria-label="Phone number"
                                   @input="handlePhoneInput()"
                                   @keydown="handlePhoneKeydown()"
                                   @blur="validateField('phone', $event.target.value); formatPhone()">
                        </div>
                        <div>
                            <label for="newContactPostalCode" class="sr-only">Postal Code</label>
                            <input v-model="newContact.postalCode" 
                                   id="newContactPostalCode"
                                   type="text"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="Postal Code (e.g., A1A 1A1)"
                                   aria-label="Postal code"
                                   @input="formatPostalCodeInput()"
                                   @blur="validateField('postalCode', $event.target.value)">
                        </div>
                        <div class="relative">
                            <label for="newContactAddress" class="sr-only">Address</label>
                            <input v-model="newContact.address" 
                                   id="newContactAddress"
                                   type="text"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="Address (max 200 characters)"
                                   aria-label="Street address"
                                   maxlength="200"
                                   @input="handleAddressInput()"
                                   @focus="showAddressSuggestions = true"
                                   @blur="hideAddressSuggestions()">
                            
                            <!-- Address Suggestions Dropdown -->
                            <div v-if="showAddressSuggestions && addressSuggestions.length > 0" 
                                 role="listbox"
                                 aria-label="Address suggestions"
                                 class="absolute z-50 w-full bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-y-auto top-full left-0 mt-1">
                                <div v-for="suggestion in addressSuggestions" 
                                     :key="suggestion.place_id"
                                     @click="selectAddress(suggestion)"
                                     role="option"
                                     :aria-label="`Select address: ${suggestion.structured_formatting.main_text}, ${suggestion.structured_formatting.secondary_text}`"
                                     tabindex="0"
                                     @keydown.enter="selectAddress(suggestion)"
                                     @keydown.space="selectAddress(suggestion)"
                                     class="px-4 py-2 hover:bg-gray-100 cursor-pointer border-b border-gray-100 last:border-b-0">
                                    <div class="font-medium">{{ suggestion.structured_formatting.main_text }}</div>
                                    <div class="text-sm text-gray-600">{{ suggestion.structured_formatting.secondary_text }}</div>
                                </div>
                            </div>
                        </div>

                        <div>
                            <label for="newContactCity" class="sr-only">City</label>
                            <input v-model="newContact.city" 
                                   id="newContactCity"
                                   type="text"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="City"
                                   aria-label="City (auto-filled from postal code or enter manually)">
                        </div>
                        <select v-model="newContact.province" 
                                class="border rounded-md px-3 py-2">
                            <option value="">Select Province</option>
                            <option v-for="province in provinces" :key="province.code" :value="province.code">
                                {{ province.name }}
                            </option>
                        </select>
                        <div>
                            <label for="newContactCategories" class="block text-sm font-medium text-gray-700">Categories</label>
                            <div class="relative">
                                <div @click.stop="showCategoryDropdown = !showCategoryDropdown"
                                     class="border rounded-md px-3 py-2 w-full cursor-pointer bg-white min-h-[42px] flex items-center flex-wrap gap-1">
                                    <span v-if="newContact.categories.length === 0" class="text-gray-400 text-sm">
                                        Select categories...
                                    </span>
                                    <span v-for="cat in newContact.categories"
                                          :key="cat"
                                          class="inline-flex items-center px-2 py-0.5 text-xs font-medium bg-indigo-100 text-indigo-800 rounded">
                                        {{ cat }}
                                        <button @click.stop="removeCategory(cat, false)"
                                                type="button"
                                                class="ml-1 text-indigo-600 hover:text-indigo-800">
                                            ×
                                        </button>
                                    </span>
                                </div>
                                
                                <!-- Dropdown Panel -->
                                <div v-if="showCategoryDropdown"
                                     @click.stop
                                     class="absolute left-0 right-0 mt-1 bg-white border-2 border-indigo-500 rounded-md shadow-xl max-h-64 overflow-y-auto"
                                     style="z-index: 9999;">
                                    <div class="p-3">
                                        <div class="flex justify-between items-center mb-2 pb-2 border-b">
                                            <span class="text-sm font-medium text-gray-700">Select Categories</span>
                                            <button @click="showCategoryDropdown = false"
                                                    type="button"
                                                    class="text-gray-400 hover:text-gray-600">
                                                ✕
                                            </button>
                                        </div>
                                        
                                        <!-- Category Checkboxes -->
                                        <div class="space-y-1">
                                            <div v-for="category in uniqueCategories" 
                                                 :key="category"
                                                 class="flex items-center py-1.5 px-2 hover:bg-indigo-50 rounded cursor-pointer">
                                                <input type="checkbox"
                                                       :id="'new-cat-' + category"
                                                       :value="category"
                                                       v-model="newContact.categories"
                                                       class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 mr-2 cursor-pointer">
                                                <label :for="'new-cat-' + category" class="text-sm flex-1 cursor-pointer">
                                                    {{ category }}
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div>
                            <label for="newContactPollNumberStandard" class="sr-only">Poll #</label>
                            <input v-model="newContact.pollNumber" 
                                   id="newContactPollNumberStandard"
                                   type="text"
                                   class="border rounded-md px-3 py-2 w-full" 
                                   placeholder="Poll #"
                                   aria-label="Poll number">
                        </div>
                    </div>
                    
                    <!-- Postal Code Lookup Status -->
                    <div v-if="postalCodeStatus" class="mt-3 p-2 rounded-md text-sm" 
                         :class="postalCodeStatus.type === 'success' ? 'bg-green-50 text-green-700 border border-green-200' : 'bg-yellow-50 text-yellow-700 border border-yellow-200'">
                        {{ postalCodeStatus.message }}
                    </div>
                    
                    <!-- Validation Messages -->
                    <div v-if="validationErrors.length" class="mt-4 p-3 bg-red-50 border border-red-200 rounded-md">
                        <h4 class="text-sm font-medium text-red-800 mb-2">Please fix the following errors:</h4>
                        <ul class="text-sm text-red-700 space-y-1">
                            <li v-for="error in validationErrors" :key="error">{{ error }}</li>
                        </ul>
                    </div>
                    
                    <div class="mt-4 flex space-x-3">
                        <button @click="addContact" 
                                :disabled="validationErrors.length > 0"
                                class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed">
                            Add Contact
                        </button>
                        <button @click="clearNewContact" 
                                type="button"
                                class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600"
                                style="background-color: #6b7280 !important; color: white !important; padding: 8px 16px !important; border-radius: 6px !important; display: inline-block !important; border: none !important; cursor: pointer !important;"
                                onmouseover="this.style.backgroundColor='#4b5563'"
                                onmouseout="this.style.backgroundColor='#6b7280'">
                            Clear Form
                        </button>
                        <button @click="showAddForm = false" 
                                type="button"
                                class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>

            <!-- Edit Contact Form -->
            <div v-if="showEditForm" class="mt-4">
                <!-- Special EDA Structure Edit Form -->
                <div v-if="contactStructure === 'eda_special'" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <input v-model="editingContact.name" 
                           class="border rounded-md px-3 py-2" 
                           placeholder="Name *"
                           required>
                    <input v-model="editingContact.riding" 
                           class="border rounded-md px-3 py-2" 
                           placeholder="Riding (e.g., 48027 - Lakeland)">
                    <input v-model="editingContact.province" 
                           class="border rounded-md px-3 py-2" 
                           placeholder="Province (e.g., Alberta)">
                    <div class="relative">
                        <input v-model="editingContact.email" 
                               type="email"
                               class="border rounded-md px-3 py-2 w-full" 
                               placeholder="Email (e.g., john@example.com)"
                               @focus="showEditEmailDomains = true"
                               @blur="hideEmailDomains(true); formatEmail(true)">
                        
                        <!-- Quick Email Domain Buttons for Edit Form -->
                        <div v-if="showEditEmailDomains" class="absolute z-50 w-full bg-white border border-gray-300 rounded-md shadow-lg mt-1 p-2">
                            <div class="text-xs text-gray-600 mb-2 font-medium">Quick select:</div>
                            <div class="flex flex-wrap gap-2">
                                <button v-for="domain in popularEmailDomains" 
                                        :key="domain"
                                        @click="selectEmailDomain(domain, true)"
                                        type="button"
                                        class="px-3 py-1.5 text-xs bg-indigo-50 hover:bg-indigo-100 text-indigo-700 border border-indigo-200 rounded transition-colors">
                                    {{ domain }}
                                </button>
                            </div>
                        </div>
                    </div>
                    <input v-model="editingContact.role" 
                           class="border rounded-md px-3 py-2" 
                           placeholder="Role (e.g., EDA President)">
                    <div class="relative">
                        <input v-model="editingContact.phone" 
                               class="border rounded-md px-3 py-2" 
                               placeholder="(___) ___-____"
                               @input="handlePhoneInput(true)"
                               @keydown="handlePhoneKeydown(true)"
                               @blur="formatPhone(true)">
                    </div>
                    <div>
                        <label for="editContactCategories" class="block text-sm font-medium text-gray-700">Categories</label>
                        <div class="relative">
                            <div @click.stop="showEditCategoryDropdown = !showEditCategoryDropdown"
                                 class="border rounded-md px-3 py-2 w-full cursor-pointer bg-white min-h-[42px] flex items-center flex-wrap gap-1">
                                <span v-if="editingContact.categories.length === 0" class="text-gray-400 text-sm">
                                    Select categories...
                                </span>
                                <span v-for="cat in editingContact.categories"
                                      :key="cat"
                                      class="inline-flex items-center px-2 py-0.5 text-xs font-medium bg-indigo-100 text-indigo-800 rounded">
                                    {{ cat }}
                                    <button @click.stop="removeCategory(cat, true)"
                                            type="button"
                                            class="ml-1 text-indigo-600 hover:text-indigo-800">
                                        ×
                                    </button>
                                </span>
                            </div>
                            
                            <!-- Dropdown Panel -->
                            <div v-if="showEditCategoryDropdown"
                                 @click.stop
                                 class="absolute left-0 right-0 mt-1 bg-white border-2 border-indigo-500 rounded-md shadow-xl max-h-64 overflow-y-auto"
                                 style="z-index: 9999;">
                                <div class="p-3">
                                    <div class="flex justify-between items-center mb-2 pb-2 border-b">
                                        <span class="text-sm font-medium text-gray-700">Select Categories</span>
                                        <button @click="showEditCategoryDropdown = false"
                                                type="button"
                                                class="text-gray-400 hover:text-gray-600">
                                            ✕
                                        </button>
                                    </div>
                                    
                                    <!-- Category Checkboxes -->
                                    <div class="space-y-1">
                                        <div v-for="category in uniqueCategories" 
                                             :key="category"
                                             class="flex items-center py-1.5 px-2 hover:bg-indigo-50 rounded cursor-pointer">
                                            <input type="checkbox"
                                                   :id="'edit-cat-' + category"
                                                   :value="category"
                                                   v-model="editingContact.categories"
                                                   class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 mr-2 cursor-pointer">
                                            <label :for="'edit-cat-' + category" class="text-sm flex-1 cursor-pointer">
                                                {{ category }}
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div>
                        <label for="editContactPollNumberEDA" class="sr-only">Poll #</label>
                        <input v-model="editingContact.pollNumber" 
                               id="editContactPollNumberEDA"
                               class="border rounded-md px-3 py-2 w-full" 
                               placeholder="Poll #"
                               aria-label="Poll number">
                    </div>
                    <div class="md:col-span-3">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Notes (volunteer notes)</label>
                        <p class="text-sm text-gray-600 mb-1">{{ getNotesArray(editingContact).length }} note(s). View or add notes with timestamps in the table.</p>
                        <button type="button" @click="openNotesModal(editingContact)" class="text-indigo-600 hover:text-indigo-800 text-sm font-medium">View / add notes</button>
                    </div>
                    
                    <!-- Subscription Status for EDA -->
                    <div class="md:col-span-3 mt-2 p-4 bg-gray-50 border border-gray-200 rounded-lg">
                        <h4 class="text-sm font-medium text-gray-700 mb-3">Subscription Status</h4>
                        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                            <label class="flex items-center justify-between p-3 bg-white rounded border cursor-pointer hover:bg-gray-50">
                                <span class="text-sm font-medium text-gray-700">Email</span>
                                <div class="flex items-center">
                                    <span v-if="editingContact.emailSubscribed" class="text-xs text-green-600 mr-2">Subscribed</span>
                                    <span v-else class="text-xs text-red-600 mr-2">Unsubscribed</span>
                                    <input type="checkbox" v-model="editingContact.emailSubscribed" class="w-5 h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500">
                                </div>
                            </label>
                            <label class="flex items-center justify-between p-3 bg-white rounded border cursor-pointer hover:bg-gray-50">
                                <span class="text-sm font-medium text-gray-700">SMS</span>
                                <div class="flex items-center">
                                    <span v-if="editingContact.smsSubscribed" class="text-xs text-green-600 mr-2">Subscribed</span>
                                    <span v-else class="text-xs text-red-600 mr-2">Unsubscribed</span>
                                    <input type="checkbox" v-model="editingContact.smsSubscribed" class="w-5 h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500">
                                </div>
                            </label>
                            <label class="flex items-center justify-between p-3 bg-white rounded border cursor-pointer hover:bg-gray-50">
                                <span class="text-sm font-medium text-gray-700">Voice</span>
                                <div class="flex items-center">
                                    <span v-if="editingContact.voiceSubscribed" class="text-xs text-green-600 mr-2">Subscribed</span>
                                    <span v-else class="text-xs text-red-600 mr-2">Unsubscribed</span>
                                    <input type="checkbox" v-model="editingContact.voiceSubscribed" class="w-5 h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500">
                                </div>
                            </label>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">Uncheck to unsubscribe contact from that channel.</p>
                    </div>
                </div>
                
                <!-- Standard Structure Edit Form -->
                <div v-else class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <input v-model="editingContact.firstName" 
                           class="border rounded-md px-3 py-2" 
                           placeholder="First Name *"
                           @input="validateField('firstName', $event.target.value, true)">
                    <input v-model="editingContact.lastName" 
                           class="border rounded-md px-3 py-2" 
                           placeholder="Last Name *"
                           @input="validateField('lastName', $event.target.value, true)">
                    <div class="relative">
                        <input v-model="editingContact.email" 
                               type="email"
                               class="border rounded-md px-3 py-2 w-full" 
                               placeholder="Email (e.g., john@example.com)"
                               @focus="showEditEmailDomains = true"
                               @blur="hideEmailDomains(true); validateField('email', $event.target.value, true); formatEmail(true)">
                        
                        <!-- Quick Email Domain Buttons for Edit Form -->
                        <div v-if="showEditEmailDomains" class="absolute z-50 w-full bg-white border border-gray-300 rounded-md shadow-lg mt-1 p-2">
                            <div class="text-xs text-gray-600 mb-2 font-medium">Quick select:</div>
                                                            <div class="flex flex-wrap gap-2">
                                                                    <button v-for="domain in popularEmailDomains" 
                                        :key="domain"
                                        @click="selectEmailDomain(domain, true)"
                                        type="button"
                                        class="px-3 py-1.5 text-xs bg-indigo-50 hover:bg-indigo-100 text-indigo-700 border border-indigo-200 rounded transition-colors">
                                    {{ domain }}
                                </button>
                                </div>
                        </div>
                    </div>
                    <div class="relative">
                        <input v-model="editingContact.phone" 
                               class="border rounded-md px-3 py-2" 
                               placeholder="(___) ___-____"
                               @input="handlePhoneInput(true)"
                               @keydown="handlePhoneKeydown(true)"
                               @blur="validateField('phone', $event.target.value, true); formatPhone(true)">
                    </div>
                    <input v-model="editingContact.postalCode" 
                           class="border rounded-md px-3 py-2" 
                           placeholder="Postal Code (e.g., A1A 1A1)"
                           @input="formatPostalCodeInput(true)"
                           @blur="validateField('postalCode', $event.target.value, true)">
                    <div class="relative">
                        <input v-model="editingContact.address" 
                               class="border rounded-md px-3 py-2 w-full" 
                               placeholder="Address (max 200 characters)"
                               maxlength="200"
                               @input="handleAddressInput(true)"
                               @focus="showEditAddressSuggestions = true"
                               @blur="hideAddressSuggestions(true)">
                        
                        <!-- Edit Address Suggestions Dropdown -->
                        <div v-if="showEditAddressSuggestions && addressSuggestions.length > 0" 
                             class="absolute z-50 w-full bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-y-auto top-full left-0 mt-1">
                            <div v-for="suggestion in addressSuggestions" 
                                 :key="suggestion.place_id"
                                 @click="selectAddress(suggestion, true)"
                                 class="px-4 py-2 hover:bg-gray-100 cursor-pointer border-b border-gray-100 last:border-b-0">
                                <div class="font-medium">{{ suggestion.structured_formatting.main_text }}</div>
                                <div class="text-sm text-gray-600">{{ suggestion.structured_formatting.secondary_text }}</div>
                            </div>
                        </div>
                    </div>

                    <input v-model="editingContact.city" 
                           class="border rounded-md px-3 py-2" 
                           placeholder="City"
                           aria-label="City (auto-filled from postal code or enter manually)">
                    <select v-model="editingContact.province" 
                            class="border rounded-md px-3 py-2">
                        <option value="">Select Province</option>
                        <option v-for="province in provinces" :key="province.code" :value="province.code">
                            {{ province.name }}
                        </option>
                    </select>
                    <div>
                        <label for="editContactCategories" class="block text-sm font-medium text-gray-700">Categories</label>
                        <div class="relative">
                            <div @click.stop="showEditCategoryDropdown = !showEditCategoryDropdown"
                                 class="border rounded-md px-3 py-2 w-full cursor-pointer bg-white min-h-[42px] flex items-center flex-wrap gap-1">
                                <span v-if="editingContact.categories.length === 0" class="text-gray-400 text-sm">
                                    Select categories...
                                </span>
                                <span v-for="cat in editingContact.categories"
                                      :key="cat"
                                      class="inline-flex items-center px-2 py-0.5 text-xs font-medium bg-indigo-100 text-indigo-800 rounded">
                                    {{ cat }}
                                    <button @click.stop="removeCategory(cat, true)"
                                            type="button"
                                            class="ml-1 text-indigo-600 hover:text-indigo-800">
                                        ×
                                    </button>
                                </span>
                            </div>
                            
                            <!-- Dropdown Panel -->
                            <div v-if="showEditCategoryDropdown"
                                 @click.stop
                                 class="absolute left-0 right-0 mt-1 bg-white border-2 border-indigo-500 rounded-md shadow-xl max-h-64 overflow-y-auto"
                                 style="z-index: 9999;">
                                <div class="p-3">
                                    <div class="flex justify-between items-center mb-2 pb-2 border-b">
                                        <span class="text-sm font-medium text-gray-700">Select Categories</span>
                                        <button @click="showEditCategoryDropdown = false"
                                                type="button"
                                                class="text-gray-400 hover:text-gray-600">
                                            ✕
                                        </button>
                                    </div>
                                    
                                    <!-- Category Checkboxes -->
                                    <div class="space-y-1">
                                        <div v-for="category in uniqueCategories" 
                                             :key="category"
                                             class="flex items-center py-1.5 px-2 hover:bg-indigo-50 rounded cursor-pointer">
                                            <input type="checkbox"
                                                   :id="'edit-cat-' + category"
                                                   :value="category"
                                                   v-model="editingContact.categories"
                                                   class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 mr-2 cursor-pointer">
                                            <label :for="'edit-cat-' + category" class="text-sm flex-1 cursor-pointer">
                                                {{ category }}
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div>
                        <label for="editContactPollNumberStandard" class="sr-only">Poll #</label>
                        <input v-model="editingContact.pollNumber" 
                               id="editContactPollNumberStandard"
                               class="border rounded-md px-3 py-2 w-full" 
                               placeholder="Poll #"
                               aria-label="Poll number">
                    </div>
                    <div class="md:col-span-3">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Notes (volunteer notes)</label>
                        <p class="text-sm text-gray-600 mb-1">{{ getNotesArray(editingContact).length }} note(s). View or add notes with timestamps in the table.</p>
                        <button type="button" @click="openNotesModal(editingContact)" class="text-indigo-600 hover:text-indigo-800 text-sm font-medium">View / add notes</button>
                    </div>
                </div>
                
                <!-- Subscription Status Section -->
                <div class="mt-4 p-4 bg-gray-50 border border-gray-200 rounded-lg">
                    <h4 class="text-sm font-medium text-gray-700 mb-3">Subscription Status</h4>
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                        <!-- Email Subscription -->
                        <label class="flex items-center justify-between p-3 bg-white rounded border cursor-pointer hover:bg-gray-50">
                            <span class="text-sm font-medium text-gray-700">Email</span>
                            <div class="flex items-center">
                                <span v-if="editingContact.emailSubscribed" class="text-xs text-green-600 mr-2">Subscribed</span>
                                <span v-else class="text-xs text-red-600 mr-2">Unsubscribed</span>
                                <input type="checkbox" 
                                       v-model="editingContact.emailSubscribed"
                                       class="w-5 h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500">
                            </div>
                        </label>
                        <!-- SMS Subscription -->
                        <label class="flex items-center justify-between p-3 bg-white rounded border cursor-pointer hover:bg-gray-50">
                            <span class="text-sm font-medium text-gray-700">SMS</span>
                            <div class="flex items-center">
                                <span v-if="editingContact.smsSubscribed" class="text-xs text-green-600 mr-2">Subscribed</span>
                                <span v-else class="text-xs text-red-600 mr-2">Unsubscribed</span>
                                <input type="checkbox" 
                                       v-model="editingContact.smsSubscribed"
                                       class="w-5 h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500">
                            </div>
                        </label>
                        <!-- Voice Subscription -->
                        <label class="flex items-center justify-between p-3 bg-white rounded border cursor-pointer hover:bg-gray-50">
                            <span class="text-sm font-medium text-gray-700">Voice</span>
                            <div class="flex items-center">
                                <span v-if="editingContact.voiceSubscribed" class="text-xs text-green-600 mr-2">Subscribed</span>
                                <span v-else class="text-xs text-red-600 mr-2">Unsubscribed</span>
                                <input type="checkbox" 
                                       v-model="editingContact.voiceSubscribed"
                                       class="w-5 h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500">
                            </div>
                        </label>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">Uncheck to unsubscribe contact from that communication channel.</p>
                </div>
                
                <!-- Edit Postal Code Lookup Status -->
                <div v-if="editPostalCodeStatus" class="mt-3 p-2 rounded-md text-sm" 
                     :class="editPostalCodeStatus.type === 'success' ? 'bg-green-50 text-green-700 border border-green-200' : 'bg-yellow-50 text-yellow-700 border border-yellow-200'">
                    {{ editPostalCodeStatus.message }}
                </div>
                
                <!-- Edit Validation Messages -->
                <div v-if="editValidationErrors.length" class="mt-4 p-3 bg-red-50 border border-red-200 rounded-md">
                    <h4 class="text-sm font-medium text-red-800 mb-2">Please fix the following errors:</h4>
                    <ul class="text-sm text-red-700 space-y-1">
                        <li v-for="error in editValidationErrors" :key="error">{{ error }}</li>
                    </ul>
                </div>
                
                <div class="mt-4 flex space-x-3">
                    <button @click="updateContact" 
                            :disabled="editValidationErrors.length > 0"
                            class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed">
                        Save Changes
                    </button>
                    <button @click="clearEditContact" 
                            type="button"
                            class="bg-yellow-500 text-white px-4 py-2 rounded hover:bg-yellow-600"
                            style="background-color: #eab308 !important; color: white !important; padding: 8px 16px !important; border-radius: 6px !important; display: inline-block !important; border: none !important; cursor: pointer !important;"
                            onmouseover="this.style.backgroundColor='#ca8a04'"
                            onmouseout="this.style.backgroundColor='#eab308'">
                        Clear Form
                    </button>
                    <button @click="cancelEdit" 
                            type="button"
                            class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">
                        Cancel
                    </button>
                </div>
            </div>

            <!-- Contacts Table -->
            <div class="border border-gray-200 rounded-lg min-w-0">
                <div class="overflow-x-auto min-w-0">
                    <table id="contactsTable" 
                           class="min-w-full divide-y divide-gray-200" 
                           :style="compactView ? 'min-width: 800px; table-layout: auto;' : 'min-width: 1600px; table-layout: auto;'"
                           role="table"
                           aria-label="Contacts table with sortable columns"
                           tabindex="0">

                                        <thead class="bg-gray-50 sticky top-0 z-10">
                        <tr>
                            <th class="w-20 px-6 pr-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" role="columnheader">
                                <input type="checkbox" 
                                       v-model="selectAll" 
                                       @change="toggleSelectAll"
                                       aria-label="Select all contacts">
                            </th>
                            <th class="w-24 px-6 pr-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" role="columnheader">
                                Actions
                            </th>
                            <th v-for="header in displayTableHeaders"
                                :key="header.key"
                                role="columnheader"
                                :aria-label="header.label + ' column'"
                                :class="[
                                    (contactStructure === 'eda_special' && compactView) ? 'px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' : (contactStructure === 'eda_special' ? 'px-6 pr-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' : (compactView ? 'px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider' : 'px-6 pr-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider')),
                                    header.key === 'lastName' ? 'w-28' : '',
                                    header.key === 'firstName' ? 'w-28' : '',
                                    header.key === 'name' ? (compactView ? 'w-40' : 'w-40') : '',
                                    header.key === 'fullName' ? (compactView ? 'w-40' : 'w-48') : '',
                                    header.key === 'riding' ? 'w-32' : '',
                                    header.key === 'role' ? 'w-32' : '',
                                    header.key === 'email' ? 'w-40' : '',
                                    header.key === 'phone' ? 'w-32' : '',
                                    header.key === 'category' ? (compactView ? 'w-32' : 'w-24') : '',
                                    header.key === 'pollNumber' ? 'w-20' : '',
                                    header.key === 'communicationStatus' ? (compactView ? 'w-32' : 'w-40') : '',
                                    header.key === 'address' ? 'w-56' : '',
                                    header.key === 'city' ? (compactView ? 'w-24' : 'w-24') : '',
                                    header.key === 'province' ? 'w-20' : '',
                                    header.key === 'postalCode' ? 'w-24' : '',
                                    header.key === 'interactionNotes' ? 'w-64' : '',
                                    header.key === 'notes' ? 'w-48' : ''
                                ]">
                                {{ header.label }}
                            </th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200">
                        <tr v-for="contact in paginatedContacts" :key="contact.id" 
                            role="row"
                            :aria-label="contactStructure === 'eda_special' ? `Contact: ${contact.name}` : `Contact: ${contact.firstName} ${contact.lastName}`"
                            class="hover:bg-gray-50 transition-colors">
                            <td role="cell" 
                                :class="(contactStructure === 'eda_special' && compactView) ? 'px-3 py-2 whitespace-nowrap' : (contactStructure === 'eda_special' ? 'px-6 pr-6 py-4 whitespace-nowrap' : (compactView ? 'px-3 py-2 whitespace-nowrap' : 'px-6 pr-6 py-4 whitespace-nowrap'))">
                                <input type="checkbox" 
                                       v-model="selectedContacts" 
                                       :value="contact.id"
                                       :aria-label="contactStructure === 'eda_special' ? `Select ${contact.name}` : `Select ${contact.firstName} ${contact.lastName}`"
                                       class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                            </td>
                            <td role="cell" 
                                :class="(contactStructure === 'eda_special' && compactView) ? 'px-3 py-2 whitespace-nowrap' : (contactStructure === 'eda_special' ? 'px-6 pr-6 py-4 whitespace-nowrap' : (compactView ? 'px-3 py-2 whitespace-nowrap' : 'px-6 pr-6 py-4 whitespace-nowrap'))">
                                <div class="flex space-x-2">
                                    <button @click="editContact(contact)" 
                                            type="button"
                                            :aria-label="contactStructure === 'eda_special' ? `Edit ${contact.name}` : `Edit ${contact.firstName} ${contact.lastName}`"
                                            :class="(contactStructure === 'eda_special' && compactView) ? 'text-blue-600 hover:text-blue-900 text-xs font-medium' : (contactStructure === 'eda_special' ? 'text-blue-600 hover:text-blue-900 text-sm font-medium hover:underline' : (compactView ? 'text-blue-600 hover:text-blue-900 text-xs font-medium' : 'text-blue-600 hover:text-blue-900 text-sm font-medium hover:underline'))">
                                        Edit
                                    </button>
                                    <button @click="deleteContact(contact.id)" 
                                            type="button"
                                            :aria-label="contactStructure === 'eda_special' ? `Delete ${contact.name}` : `Delete ${contact.firstName} ${contact.lastName}`"
                                            :class="(contactStructure === 'eda_special' && compactView) ? 'text-red-600 hover:text-red-800 text-xs font-medium' : (contactStructure === 'eda_special' ? 'text-red-600 hover:text-red-800 text-sm font-medium hover:underline' : (compactView ? 'text-red-600 hover:text-red-800 text-xs font-medium' : 'text-red-600 hover:text-red-800 text-sm font-medium hover:underline'))">
                                        Delete
                                    </button>
                                </div>
                            </td>
                            <td v-for="header in displayTableHeaders" 
                                :key="`${contactStructure}-${header.key}-${contact.id}`"
                                role="cell"
                                :class="[
                                    (contactStructure === 'eda_special' && compactView) ? 'px-3 py-2 whitespace-nowrap' : (contactStructure === 'eda_special' ? 'px-6 pr-6 py-4 whitespace-nowrap' : (compactView ? 'px-3 py-2 whitespace-nowrap' : 'px-6 pr-6 py-4 whitespace-nowrap')),
                                    header.key === 'lastName' ? 'w-28' : '',
                                    header.key === 'firstName' ? 'w-28' : '',
                                    header.key === 'name' ? (compactView ? 'w-40' : 'w-40') : '',
                                    header.key === 'fullName' ? (compactView ? 'w-40' : 'w-48') : '',
                                    header.key === 'riding' ? 'w-32' : '',
                                    header.key === 'role' ? 'w-32' : '',
                                    header.key === 'email' ? 'w-40' : '',
                                    header.key === 'phone' ? 'w-32' : '',
                                    header.key === 'category' ? (compactView ? 'w-32' : 'w-24') : '',
                                    header.key === 'pollNumber' ? 'w-20' : '',
                                    header.key === 'communicationStatus' ? (compactView ? 'w-32' : 'w-40') : '',
                                    header.key === 'address' ? 'w-56' : '',
                                    header.key === 'city' ? (compactView ? 'w-24' : 'w-24') : '',
                                    header.key === 'province' ? 'w-20' : '',
                                    header.key === 'postalCode' ? 'w-24' : '',
                                    header.key === 'notes' ? 'w-48 max-w-xs' : ''
                                ]">
                                <!-- Special EDA structure fields -->
                                <span v-if="contactStructure === 'eda_special' && header.key === 'name'" class="font-medium truncate overflow-hidden whitespace-nowrap">
                                    {{ (contact.name || '').trim() }}
                                </span>
                                <span v-else-if="contactStructure === 'eda_special' && ['riding', 'province', 'role'].includes(header.key)" class="truncate overflow-hidden whitespace-nowrap">
                                    {{ (contact[header.key] || '').trim() }}
                                </span>
                                <!-- Compact view: fullName for standard structure -->
                                <span v-else-if="contactStructure !== 'eda_special' && compactView && header.key === 'fullName'" class="font-medium truncate overflow-hidden whitespace-nowrap">
                                    <template v-if="(contact.lastName || '').trim() && (contact.firstName || '').trim()">
                                        {{ (contact.lastName || '').trim() }}, {{ (contact.firstName || '').trim() }}
                                    </template>
                                    <template v-else-if="(contact.lastName || '').trim()">
                                        {{ (contact.lastName || '').trim() }}
                                    </template>
                                    <template v-else-if="(contact.firstName || '').trim()">
                                        {{ (contact.firstName || '').trim() }}
                                    </template>
                                    <template v-else>
                                        -
                                    </template>
                                </span>
                                <!-- Normal view: separate lastName and firstName -->
                                <span v-else-if="contactStructure !== 'eda_special' && !compactView && header.key === 'lastName'" class="font-medium truncate overflow-hidden whitespace-nowrap">
                                    {{ (contact.lastName || '').trim() }}
                                </span>
                                <span v-else-if="contactStructure !== 'eda_special' && !compactView && header.key === 'firstName'" class="font-medium truncate overflow-hidden whitespace-nowrap">
                                    {{ (contact.firstName || '').trim() }}
                                </span>
                                <!-- Common fields for both views -->
                                <span v-else-if="header.key === 'email'" class="text-blue-600 hover:underline cursor-pointer truncate overflow-hidden whitespace-nowrap">
                                    {{ (contact[header.key] || '').trim() }}
                                </span>
                                <span v-else-if="header.key === 'phone'" class="font-mono text-sm truncate overflow-hidden whitespace-nowrap">
                                    {{ (contact[header.key] || '').trim() }}
                                </span>
                                <span v-else-if="header.key === 'category'" class="flex flex-wrap gap-1">
                                    <span v-if="Array.isArray(contact.categories) && contact.categories.length > 0"
                                          v-for="cat in contact.categories"
                                          :key="cat"
                                          class="inline-flex px-2 py-1 text-xs font-medium bg-gray-100 text-gray-800 rounded-full">
                                        {{ cat }}
                                    </span>
                                    <span v-else-if="contact.category"
                                          class="inline-flex px-2 py-1 text-xs font-medium bg-gray-100 text-gray-800 rounded-full">
                                        {{ contact.category }}
                                    </span>
                                </span>
                                <span v-else-if="header.key === 'pollNumber'" class="truncate overflow-hidden whitespace-nowrap font-mono text-sm">
                                    {{ (contact.pollNumber || '').trim() || '-' }}
                                </span>
                                <span v-else-if="header.key === 'communicationStatus'" class="flex flex-wrap gap-1">
                                    <span v-if="contact.email" 
                                          :class="getSubscriptionStatus(contact, 'email').subscribed ? 'bg-green-100 text-green-800 border border-green-300' : 'bg-red-100 text-red-800 border border-red-300'"
                                          class="inline-flex px-2 py-1 text-xs font-medium rounded-full"
                                          :title="getSubscriptionStatus(contact, 'email').subscribed ? 'Subscribed to email' : 'Unsubscribed from email' + (getSubscriptionStatus(contact, 'email').unsubscribedAt ? ' on ' + new Date(getSubscriptionStatus(contact, 'email').unsubscribedAt).toLocaleDateString() : '')">
                                        <span v-if="getSubscriptionStatus(contact, 'email').subscribed">✓</span>
                                        <span v-else class="font-bold">✗</span>
                                        <span class="ml-1">Email</span>
                                    </span>
                                    <span v-if="contact.phone" 
                                          :class="getSubscriptionStatus(contact, 'sms').subscribed ? 'bg-green-100 text-green-800 border border-green-300' : 'bg-red-100 text-red-800 border border-red-300'"
                                          class="inline-flex px-2 py-1 text-xs font-medium rounded-full"
                                          :title="getSubscriptionStatus(contact, 'sms').subscribed ? 'Subscribed to SMS' : 'Unsubscribed from SMS' + (getSubscriptionStatus(contact, 'sms').unsubscribedAt ? ' on ' + new Date(getSubscriptionStatus(contact, 'sms').unsubscribedAt).toLocaleDateString() : '')">
                                        <span v-if="getSubscriptionStatus(contact, 'sms').subscribed">✓</span>
                                        <span v-else class="font-bold">✗</span>
                                        <span class="ml-1">SMS</span>
                                    </span>
                                    <span v-if="contact.phone" 
                                          :class="getSubscriptionStatus(contact, 'voice').subscribed ? 'bg-green-100 text-green-800 border border-green-300' : 'bg-red-100 text-red-800 border border-red-300'"
                                          class="inline-flex px-2 py-1 text-xs font-medium rounded-full"
                                          :title="getSubscriptionStatus(contact, 'voice').subscribed ? 'Subscribed to voice' : 'Unsubscribed from voice' + (getSubscriptionStatus(contact, 'voice').unsubscribedAt ? ' on ' + new Date(getSubscriptionStatus(contact, 'voice').unsubscribedAt).toLocaleDateString() : '')">
                                        <span v-if="getSubscriptionStatus(contact, 'voice').subscribed">✓</span>
                                        <span v-else class="font-bold">✗</span>
                                        <span class="ml-1">Voice</span>
                                    </span>
                                </span>
                                <span v-else-if="header.key === 'address'" class="block truncate overflow-hidden whitespace-nowrap text-xs" :title="(contact.address || '').trim() || 'No address'">
                                    {{ (contact.address || '').trim() || '-' }}
                                </span>
                                <span v-else-if="header.key === 'city'" class="truncate overflow-hidden whitespace-nowrap">
                                    {{ (contact.city || '').trim() || '-' }}
                                </span>
                                <span v-else-if="header.key === 'province'" class="truncate overflow-hidden whitespace-nowrap">
                                    {{ (contact.province || '').trim() || '-' }}
                                </span>
                                <span v-else-if="header.key === 'postalCode'" class="truncate overflow-hidden whitespace-nowrap font-mono text-sm">
                                    {{ (contact.postalCode || '').trim() || '-' }}
                                </span>
                                <span v-else-if="header.key === 'notes'" 
                                      class="text-xs text-gray-600 cursor-pointer hover:text-indigo-600 hover:underline whitespace-nowrap"
                                      @click="openNotesModal(contact)"
                                      role="button"
                                      tabindex="0"
                                      @keydown.enter.prevent="openNotesModal(contact)"
                                      @keydown.space.prevent="openNotesModal(contact)"
                                      :title="getNotesArray(contact).length ? 'Click to view notes or add another' : 'Add note'">
                                    <template v-if="getNotesArray(contact).length">
                                        {{ getNotesArray(contact).length }} note(s) · {{ formatNotesTimestamp(contact) }} …
                                    </template>
                                    <template v-else><span class="text-indigo-600 font-medium">Add note</span></template>
                                </span>
                                <span v-else-if="header.key === 'interactionNotes' && isElectionAccount" class="text-xs text-gray-600 max-w-xs">
                                    <div v-if="contact.latestInteraction" class="space-y-1">
                                        <div class="font-medium text-gray-900">
                                            {{ formatSupportLevel(contact.latestInteraction.support_likelihood) }}
                                        </div>
                                        <div class="text-gray-500 truncate" :title="contact.latestInteraction.notes">
                                            {{ contact.latestInteraction.notes || 'No notes' }}
                                        </div>
                                        <div class="text-gray-400 text-xs">
                                            {{ formatDate(contact.latestInteraction.created_at) }}
                                        </div>
                                    </div>
                                    <span v-else class="text-gray-400">No interactions</span>
                                </span>
                                <span v-else class="truncate overflow-hidden whitespace-nowrap">
                                    {{ (contact[header.key] || '').trim() }}
                                </span>
                            </td>
                        </tr>
                    </tbody>
                </table>
                
                <!-- Add pagination controls -->
                <div v-if="showPagination" class="border-t border-gray-200">
                    <div class="px-6 py-4 flex justify-between items-center">
                    <div class="flex items-center space-x-4">
                        <div class="text-sm text-gray-700">
                            Showing {{ ((currentPage - 1) * contactsPerPage) + 1 }} to 
                            {{ Math.min(currentPage * contactsPerPage, filteredContacts.length) }} of 
                            {{ filteredContacts.length }} contacts
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm text-gray-600">Show:</span>
                            <select v-model="contactsPerPage" 
                                    @change="currentPage = 1"
                                    class="border rounded px-3 py-1 text-sm w-24">
                                <option value="25">25</option>
                                <option value="50">50</option>
                                <option value="100">100</option>
                                <option value="250">250</option>
                            </select>
                            <span class="text-sm text-gray-600">per page</span>
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <button @click="currentPage = Math.max(1, currentPage - 1)"
                                :disabled="currentPage === 1"
                                class="px-3 py-1 border rounded text-sm
                                       hover:bg-gray-50 disabled:opacity-50">
                            Previous
                        </button>
                        
                        <div class="flex space-x-1">
                            <!-- First page -->
                            <button v-if="currentPage > 3"
                                    @click="currentPage = 1"
                                    class="px-3 py-1 border rounded text-sm hover:bg-gray-50">
                                1
                            </button>
                            
                            <!-- Ellipsis after first page -->
                            <span v-if="currentPage > 4" class="px-2 py-1 text-gray-500">...</span>
                            
                            <!-- Pages around current page -->
                            <button v-for="page in visiblePages" 
                                    :key="page"
                                    @click="currentPage = page"
                                    :class="{
                                        'px-3 py-1 border rounded text-sm': true,
                                        'bg-indigo-600 text-white': currentPage === page,
                                        'hover:bg-gray-50': currentPage !== page
                                    }">
                                {{ page }}
                            </button>
                            
                            <!-- Ellipsis before last page -->
                            <span v-if="currentPage < totalPages - 3" class="px-2 py-1 text-gray-500">...</span>
                            
                            <!-- Last page -->
                            <button v-if="currentPage < totalPages - 2"
                                    @click="currentPage = totalPages"
                                    class="px-3 py-1 border rounded text-sm hover:bg-gray-50">
                                {{ totalPages }}
                            </button>
                        </div>

                        <button @click="currentPage = Math.min(totalPages, currentPage + 1)"
                                :disabled="currentPage === totalPages"
                                class="px-3 py-1 border rounded text-sm
                                       hover:bg-gray-50 disabled:opacity-50">
                            Next
                        </button>
                    </div>
                </div>
                </div>
                </div>
            </div>

            <!-- Bulk Actions -->
            <div v-if="selectedContacts.length" class="mt-4 p-4 bg-gray-50 rounded-lg">
                <div class="flex items-center space-x-4">
                    <span class="text-sm text-gray-600">
                        {{ selectedContacts.length }} contacts selected
                    </span>
                    <button @click="deleteSelectedContacts" 
                            class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">
                        Delete Selected
                    </button>
                    <button v-if="selectedContacts.length === 1" 
                            @click="editSelectedContact" 
                            class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
                        Edit Selected
                    </button>
                </div>
            </div>

            <!-- Notes view modal (full note with scroll) -->
            <div v-if="showNotesModal && notesModalContact" 
                 class="fixed inset-0 z-50 overflow-y-auto bg-gray-600 bg-opacity-50" 
                 aria-modal="true" 
                 role="dialog"
                 aria-labelledby="notes-modal-title"
                 @click.self="closeNotesModal"
                 @keydown.esc="closeNotesModal">
                <div class="flex min-h-full items-center justify-center p-4">
                    <div class="relative bg-white rounded-lg shadow-xl max-w-lg w-full max-h-[80vh] flex flex-col" @click.stop>
                        <div class="flex items-center justify-between px-4 py-3 border-b border-gray-200 flex-shrink-0">
                            <h3 id="notes-modal-title" class="text-lg font-semibold text-gray-900">Note</h3>
                            <button type="button" @click="closeNotesModal" class="text-gray-400 hover:text-gray-600 text-2xl leading-none">&times;</button>
                        </div>
                        <div class="px-4 py-2 text-sm text-gray-500 border-b border-gray-100 flex-shrink-0">
                            {{ contactStructure === 'eda_special' ? (notesModalContact.name || '—') : ((notesModalContact.firstName || '') + ' ' + (notesModalContact.lastName || '')).trim() || '—' }}
                            <span v-if="getNotesArray(notesModalContact).length" class="text-gray-400 ml-2">{{ getNotesArray(notesModalContact).length }} note(s)</span>
                        </div>
                        <div class="flex-1 min-h-0 overflow-y-auto px-4 py-3 flex flex-col gap-3">
                            <div v-for="(note, i) in getNotesArray(notesModalContact).slice().reverse()" :key="i" class="text-sm border-b border-gray-100 pb-2 last:border-0">
                                <div class="text-gray-500 text-xs mb-1">{{ formatNoteTimestamp(note) }}{{ note.authorName ? ' · ' + note.authorName : '' }}</div>
                                <div class="text-gray-700 whitespace-pre-wrap">{{ note.text || '—' }}</div>
                            </div>
                            <div v-if="getNotesArray(notesModalContact).length === 0" class="text-gray-400 text-sm">No notes yet. Add one below.</div>
                            <div class="mt-2">
                                <label for="notesModalTextarea" class="block text-sm font-medium text-gray-700 mb-1">Add a note</label>
                                <textarea id="notesModalTextarea" v-model="notesModalNewText" rows="3" class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" placeholder="Type a new note..."></textarea>
                            </div>
                        </div>
                        <div class="px-4 py-3 border-t border-gray-200 flex justify-end gap-2 flex-shrink-0">
                            <button type="button" @click="closeNotesModal" class="px-3 py-1.5 bg-gray-200 rounded hover:bg-gray-300">Close</button>
                            <button type="button" @click="saveNotesFromModal" :disabled="savingNotesModal || !notesModalNewText.trim()" class="px-3 py-1.5 bg-indigo-600 text-white rounded hover:bg-indigo-700 disabled:opacity-50">{{ savingNotesModal ? 'Saving...' : 'Add note' }}</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Trash Management Section -->
        <div v-if="showTrash" class="bg-white shadow rounded-lg p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold">Trash Management</h2>
            </div>
            
            <div v-if="trash.length === 0" class="text-center py-8 text-gray-500">
                <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
                <p class="mt-2">No deleted contacts in trash</p>
            </div>
            
            <div v-else class="space-y-4">
                <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                    <div class="flex">
                        <div class="flex-shrink-0">
                            <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.63 2.725-1.63 3.49 0l5.58 11.92c.75 1.604-.213 3.44-1.745 3.44H4.42c-1.53 0-2.495-1.836-1.743-3.44l5.58-11.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                        </div>
                        <div class="ml-3">
                            <h3 class="text-sm font-medium text-yellow-800">
                                Deleted contacts are kept for 30 days
                            </h3>
                            <div class="mt-2 text-sm text-yellow-700">
                                <p>Contacts in trash will be automatically deleted after 30 days. You can restore them anytime before then.</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="overflow-x-auto border border-gray-200 rounded-lg">
                    <table id="trashTable" 
                           class="min-w-full divide-y divide-gray-200"
                           role="table"
                           aria-label="Deleted contacts table"
                           tabindex="0">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    <input type="checkbox" v-model="selectAllTrash" @change="toggleSelectAllTrash">
                                </th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Email</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Phone</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Category</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Deleted</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            <tr v-for="contact in trash" :key="contact.id" class="hover:bg-gray-50">
                                <td class="px-6 py-4 whitespace-nowrap">
                                    <input type="checkbox" 
                                           v-model="selectedTrash" 
                                           :value="contact.id"
                                           class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap">
                                    <span class="font-medium">{{ contact.lastName }}, {{ contact.firstName }}</span>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-blue-600">
                                    {{ contact.email }}
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap font-mono text-sm">
                                    {{ contact.phone }}
                                </td>
                                <td class="px-6 py-4">
                                    <div class="flex flex-wrap gap-1">
                                        <span v-if="Array.isArray(contact.categories) && contact.categories.length > 0"
                                              v-for="cat in contact.categories"
                                              :key="cat"
                                              class="inline-flex px-2 py-1 text-xs font-medium bg-gray-100 text-gray-800 rounded-full whitespace-nowrap">
                                            {{ cat }}
                                        </span>
                                        <span v-else-if="contact.category"
                                              class="inline-flex px-2 py-1 text-xs font-medium bg-gray-100 text-gray-800 rounded-full whitespace-nowrap">
                                            {{ contact.category }}
                                        </span>
                                    </div>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                    {{ formatDate(contact.deletedAt) }}
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <!-- Trash Bulk Actions -->
                <div v-if="selectedTrash.length" class="mt-4 p-4 bg-gray-50 rounded-lg">
                    <div class="flex items-center space-x-4">
                        <span class="text-sm text-gray-600">
                            {{ selectedTrash.length }} items selected
                        </span>
                        <button @click="restoreSelectedContacts" 
                                class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">
                            Restore Selected
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Smart Import Section -->
        <div class="bg-white shadow rounded-lg p-6">
            <div class="mb-4">
                <h2 class="text-xl font-semibold">Smart Contact Import</h2>
                <p class="text-sm text-gray-600 mt-1">Upload messy Excel files - we'll automatically detect and map columns for you!</p>
            </div>
            
            <div class="space-y-6">
                <!-- Step 1: File Upload or Paste -->
                <div v-if="smartImportStep === 1" class="space-y-4">
                    <!-- Toggle between file upload and paste -->
                    <div class="flex justify-center mb-4">
                        <div class="inline-flex rounded-lg border border-gray-300 bg-white p-1">
                            <button @click="smartImportMethod = 'file'" 
                                    type="button"
                                    :class="smartImportMethod === 'file' ? 'bg-indigo-600 text-white' : 'text-gray-700 hover:bg-gray-50'"
                                    class="px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Upload File
                            </button>
                            <button @click="smartImportMethod = 'paste'" 
                                    type="button"
                                    :class="smartImportMethod === 'paste' ? 'bg-indigo-600 text-white' : 'text-gray-700 hover:bg-gray-50'"
                                    class="px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Paste Data
                            </button>
                        </div>
                    </div>
                    
                    <!-- File Upload Method -->
                    <div v-if="smartImportMethod === 'file'" class="space-y-4">
                        <div class="border-2 border-dashed border-gray-300 rounded-lg p-8"
                             :class="{ 'border-indigo-500 bg-indigo-50': isDragging }"
                             @dragover.prevent="isDragging = true"
                             @dragleave.prevent="isDragging = false"
                             @drop.prevent="handleFileDrop"
                             @click="$refs.smartImportFileInput.click()">
                            <input ref="smartImportFileInput" 
                                   type="file" 
                                   accept=".xlsx,.xls,.csv"
                                   @change="handleFileSelect"
                                   class="hidden">
                            <div class="text-center space-y-4">
                                <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                </svg>
                                <div>
                                    <p class="text-lg font-medium text-gray-700">
                                        Drop your Excel file here, or click to browse
                                    </p>
                                    <p class="text-sm text-gray-500 mt-1">
                                        Supports .xlsx, .xls, and .csv files (max 10MB)
                                    </p>
                                    <p class="text-xs text-gray-400 mt-2">
                                        We'll automatically detect and map your columns - no configuration needed!
                                    </p>
                                </div>
                                <div v-if="smartImportFile" class="mt-4">
                                    <div class="inline-flex items-center px-4 py-2 bg-green-100 text-green-800 rounded-lg">
                                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                        </svg>
                                        {{ smartImportFile.name }}
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div v-if="smartImportFile" class="flex justify-center">
                            <button @click="parseSmartImportFile" 
                                    :disabled="parsingFile"
                                    class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2">
                                <svg v-if="parsingFile" class="animate-spin h-5 w-5" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <span>{{ parsingFile ? 'Analyzing file...' : 'Analyze & Preview' }}</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Paste Data Method -->
                    <div v-if="smartImportMethod === 'paste'" class="space-y-4">
                        <div class="border-2 border-dashed border-gray-300 rounded-lg p-6">
                            <div class="space-y-4">
                                <div class="text-center">
                                    <p class="text-sm font-medium text-gray-700 mb-2">
                                        Paste your Excel data here (tab-separated)
                                    </p>
                                    <p class="text-xs text-gray-500">
                                        Copy from Excel and paste - we'll automatically detect and map columns!
                                    </p>
                                </div>
                                <textarea v-model="smartImportPasteData" 
                                          rows="8" 
                                          class="w-full border rounded-md p-3 font-mono text-sm"
                                          placeholder="Paste your Excel data here (tab-separated values)..."></textarea>
                                <div class="flex justify-center">
                                    <button @click="parseSmartImportPaste" 
                                            :disabled="parsingFile || !smartImportPasteData.trim()"
                                            class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2">
                                        <svg v-if="parsingFile" class="animate-spin h-5 w-5" fill="none" viewBox="0 0 24 24">
                                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                        </svg>
                                        <span>{{ parsingFile ? 'Analyzing...' : 'Analyze & Preview' }}</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Step 2: Preview (previously Step 3) -->
                <div v-if="smartImportStep === 2" class="space-y-4">
                    <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                        <div class="flex items-center justify-between">
                            <div>
                                <h3 class="font-medium text-green-900">Preview Ready!</h3>
                                <p class="text-sm text-green-700 mt-1">
                                    Showing preview of {{ smartImportPreview.length }} contacts (out of {{ smartImportTotalRows }} total)
                                </p>
                            </div>
                            <div v-if="smartImportPreviewErrors.length > 0" class="text-sm text-red-600">
                                {{ smartImportPreviewErrors.length }} rows with errors
                            </div>
                        </div>
                    </div>
                    
                    <div class="border rounded-lg overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">First Name</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Last Name</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Email</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Phone</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Address</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">City</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Province</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Postal Code</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Category</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Poll #</th>
                                </tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                <tr v-for="(contact, index) in smartImportPreview" :key="index" class="hover:bg-gray-50">
                                    <td class="px-4 py-3 text-sm">{{ contact.firstName || '-' }}</td>
                                    <td class="px-4 py-3 text-sm">{{ contact.lastName || '-' }}</td>
                                    <td class="px-4 py-3 text-sm text-blue-600">{{ contact.email || '-' }}</td>
                                    <td class="px-4 py-3 text-sm font-mono">{{ contact.phone || '-' }}</td>
                                    <td class="px-4 py-3 text-sm">{{ contact.address || '-' }}</td>
                                    <td class="px-4 py-3 text-sm">{{ contact.city || '-' }}</td>
                                    <td class="px-4 py-3 text-sm">{{ contact.province || '-' }}</td>
                                    <td class="px-4 py-3 text-sm font-mono">{{ contact.postalCode || '-' }}</td>
                                    <td class="px-4 py-3 text-sm">
                                        <span v-for="cat in contact.categories" :key="cat" 
                                              class="inline-block px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded mr-1">
                                            {{ cat }}
                                        </span>
                                        <span v-if="!contact.categories || contact.categories.length === 0">-</span>
                                    </td>
                                    <td class="px-4 py-3 text-sm font-mono">{{ contact.pollNumber || '-' }}</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div v-if="smartImportPreviewErrors.length > 0" class="bg-red-50 border border-red-200 rounded-lg p-4">
                        <h4 class="font-medium text-red-900 mb-2">Rows with Errors:</h4>
                        <ul class="text-sm text-red-700 space-y-1">
                            <li v-for="error in smartImportPreviewErrors" :key="error.row">
                                Row {{ error.row }}: {{ error.message }}
                            </li>
                        </ul>
                    </div>
                    
                    <!-- Bulk Category Selection -->
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <div class="flex items-center justify-between">
                            <div class="flex-1">
                                <label for="bulkImportCategory" class="block text-sm font-medium text-blue-900 mb-2">
                                    Apply Category to All Imported Contacts (Optional)
                                </label>
                                <div class="space-y-2">
                                    <div class="flex gap-3">
                                        <select v-model="bulkImportCategory" 
                                                id="bulkImportCategory"
                                                class="border border-blue-300 rounded-md px-3 py-2 text-sm flex-1 bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                            <option value="">No Category</option>
                                            <option v-for="category in uniqueCategories" 
                                                    :key="category" 
                                                    :value="category">
                                                {{ category }}
                                            </option>
                                        </select>
                                        <button v-if="bulkImportCategory" 
                                                @click="bulkImportCategory = ''"
                                                type="button"
                                                class="px-3 py-2 text-sm text-blue-700 hover:text-blue-900 border border-blue-300 rounded-md hover:bg-blue-100">
                                            Clear
                                        </button>
                                    </div>
                                </div>
                                <p class="text-xs text-blue-700 mt-2">
                                    This category will be added to all {{ smartImportTotalRows }} contacts during import.
                                </p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex justify-between">
                        <button @click="cancelSmartImport" 
                                type="button"
                                class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50">
                            Cancel
                        </button>
                        <button @click="finalizeSmartImport" 
                                :disabled="finalizingImport || smartImportPreview.length === 0"
                                class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">
                            {{ finalizingImport ? 'Importing...' : `Import ${smartImportTotalRows} Contacts` }}
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Import Section (moved to bottom) -->
        <div class="bg-white shadow rounded-lg p-6">
            <div class="mb-4">
                <h2 class="text-xl font-semibold">Structured Import</h2>
                <p class="text-sm text-gray-600 mt-1">For data that's already properly formatted with standard column names</p>
            </div>
            
            <div class="space-y-6">
                <!-- Step 1: Upload or Paste -->
                <div v-if="legacyImportStep === 1" class="space-y-4">
                    <!-- Toggle between file upload and paste -->
                    <div class="flex justify-center mb-4">
                        <div class="inline-flex rounded-lg border border-gray-300 bg-white p-1">
                            <button @click="legacyImportMethod = 'file'" 
                                    type="button"
                                    :class="legacyImportMethod === 'file' ? 'bg-indigo-600 text-white' : 'text-gray-700 hover:bg-gray-50'"
                                    class="px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Upload File
                            </button>
                            <button @click="legacyImportMethod = 'paste'" 
                                    type="button"
                                    :class="legacyImportMethod === 'paste' ? 'bg-indigo-600 text-white' : 'text-gray-700 hover:bg-gray-50'"
                                    class="px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Paste Data
                            </button>
                        </div>
                    </div>
                    
                    <div class="border-2 border-dashed border-gray-300 rounded-lg p-6">
                    <div class="text-center space-y-4">
                        <div class="space-y-2">
                            <h3 class="text-lg font-medium">Excel Format Required:</h3>
                            <div class="inline-block text-left text-sm text-gray-600">
                                <p>Your Excel file should have these columns (in any order):</p>
                                <!-- Special EDA Structure Format -->
                                <ul v-if="contactStructure === 'eda_special'" class="list-disc pl-5 mt-2">
                                    <li>Name (required)</li>
                                    <li>Riding</li>
                                    <li>Province</li>
                                    <li>Email</li>
                                    <li>Role</li>
                                    <li>Phone</li>
                                    <li>category</li>
                                    <li>pollNumber</li>
                                </ul>
                                <!-- Standard Structure Format -->
                                <ul v-else class="list-disc pl-5 mt-2">
                                    <li>firstName (required)</li>
                                    <li>lastName (required)</li>
                                    <li>email</li>
                                    <li>phone</li>
                                    <li>address</li>
                                    <li>city</li>
                                    <li>province</li>
                                    <li>postalCode</li>
                                    <li>category</li>
                                    <li>pollNumber</li>
                                </ul>
                            </div>
                        </div>
                        
                        <!-- File Upload Method -->
                        <div v-if="legacyImportMethod === 'file'" class="space-y-4">
                            <div class="border-2 border-dashed border-gray-300 rounded-lg p-6"
                                 :class="{ 'border-indigo-500 bg-indigo-50': legacyIsDragging }"
                                 @dragover.prevent="legacyIsDragging = true"
                                 @dragleave.prevent="legacyIsDragging = false"
                                 @drop.prevent="handleLegacyFileDrop"
                                 @click="$refs.legacyImportFileInput.click()">
                                <input ref="legacyImportFileInput" 
                                       type="file" 
                                       accept=".xlsx,.xls,.csv"
                                       @change="handleLegacyFileSelect"
                                       class="hidden">
                                <div class="text-center space-y-4">
                                    <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                    </svg>
                                    <div>
                                        <p class="text-lg font-medium text-gray-700">
                                            Drop your Excel file here, or click to browse
                                        </p>
                                        <p class="text-sm text-gray-500 mt-1">
                                            Supports .xlsx, .xls, and .csv files
                                        </p>
                                    </div>
                                    <div v-if="legacyImportFile" class="mt-4">
                                        <div class="inline-flex items-center px-4 py-2 bg-green-100 text-green-800 rounded-lg">
                                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                            </svg>
                                            {{ legacyImportFile.name }}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <button @click="processLegacyFileImport" 
                                    :disabled="processing || !legacyImportFile"
                                    class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed">
                                {{ processing ? 'Processing...' : 'Preview Contacts' }}
                            </button>
                        </div>
                        
                        <!-- Paste Data Method -->
                        <div v-if="legacyImportMethod === 'paste'" class="space-y-4">
                            <div class="space-y-2">
                                <label class="block text-sm font-medium text-gray-700">
                                    Paste Excel Data Here:
                                </label>
                                <textarea v-model="importData" 
                                          rows="6" 
                                          class="w-full border rounded-md p-2 font-mono text-sm"
                                          placeholder="Copy and paste your Excel data here (tab-separated)..."></textarea>
                            </div>
                            
                            <button @click="processImport" 
                                    :disabled="processing || !importData.trim()"
                                    class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700 disabled:opacity-50">
                                {{ processing ? 'Processing...' : 'Preview Contacts' }}
                            </button>
                        </div>
                        
                        <!-- Category Selection (shown for both file and paste methods) -->
                        <div class="mt-4 p-4 bg-indigo-50 rounded-lg border border-indigo-200">
                            <div class="flex items-center justify-between">
                                <div class="flex-1">
                                    <label for="legacyImportCategory" class="block text-sm font-medium text-indigo-900 mb-2">
                                        Apply Category to All Imported Contacts (Optional)
                                    </label>
                                    <div class="space-y-2">
                                        <div class="flex gap-3">
                                            <select v-model="legacyImportCategory" 
                                                    id="legacyImportCategory"
                                                    class="border border-indigo-300 rounded-md px-3 py-2 text-sm flex-1 bg-white focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                                                <option value="">No Category</option>
                                                <option v-for="category in uniqueCategories" 
                                                        :key="category" 
                                                        :value="category">
                                                    {{ category }}
                                                </option>
                                            </select>
                                            <button v-if="legacyImportCategory" 
                                                    @click="legacyImportCategory = ''"
                                                    type="button"
                                                    class="px-3 py-2 text-sm text-indigo-700 hover:text-indigo-900 border border-indigo-300 rounded-md hover:bg-indigo-100">
                                                Clear
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    </div>
                </div>
                
                <!-- Step 2: Preview -->
                <div v-if="legacyImportStep === 2" class="space-y-4">
                    <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                        <div class="flex items-center justify-between">
                            <div>
                                <h3 class="font-medium text-green-900">Preview Ready!</h3>
                                <p class="text-sm text-green-700 mt-1">
                                    Showing preview of {{ legacyImportPreview.length }} contacts (out of {{ legacyImportTotalRows }} total)
                                </p>
                            </div>
                            <div v-if="legacyImportPreviewErrors.length > 0" class="text-sm text-red-600">
                                {{ legacyImportPreviewErrors.length }} rows with errors
                            </div>
                        </div>
                    </div>
                    
                    <div class="border rounded-lg overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50">
                                <tr>
                                    <!-- Special EDA Structure Headers -->
                                    <template v-if="contactStructure === 'eda_special'">
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Name</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Riding</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Province</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Email</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Role</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Phone</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Category</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Poll #</th>
                                    </template>
                                    <!-- Standard Structure Headers -->
                                    <template v-else>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">First Name</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Last Name</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Email</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Phone</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Address</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">City</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Province</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Postal Code</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Category</th>
                                        <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Poll #</th>
                                    </template>
                                </tr>
                            </thead>
                            <tbody class="bg-white divide-y divide-gray-200">
                                <tr v-for="(contact, index) in legacyImportPreview" :key="index" class="hover:bg-gray-50">
                                    <!-- Special EDA Structure Data -->
                                    <template v-if="contactStructure === 'eda_special'">
                                        <td class="px-4 py-3 text-sm">{{ contact.name || '-' }}</td>
                                        <td class="px-4 py-3 text-sm">{{ contact.riding || '-' }}</td>
                                        <td class="px-4 py-3 text-sm">{{ contact.province || '-' }}</td>
                                        <td class="px-4 py-3 text-sm text-blue-600">{{ contact.email || '-' }}</td>
                                        <td class="px-4 py-3 text-sm">{{ contact.role || '-' }}</td>
                                        <td class="px-4 py-3 text-sm font-mono">{{ contact.phone || '-' }}</td>
                                        <td class="px-4 py-3 text-sm">
                                            <span v-for="cat in getDisplayCategories(contact)" :key="cat" 
                                                  class="inline-block px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded mr-1">
                                                {{ cat }}
                                            </span>
                                            <span v-if="getDisplayCategories(contact).length === 0">-</span>
                                        </td>
                                        <td class="px-4 py-3 text-sm font-mono">{{ contact.pollNumber || '-' }}</td>
                                    </template>
                                    <!-- Standard Structure Data -->
                                    <template v-else>
                                        <td class="px-4 py-3 text-sm">{{ contact.firstName || '-' }}</td>
                                        <td class="px-4 py-3 text-sm">{{ contact.lastName || '-' }}</td>
                                        <td class="px-4 py-3 text-sm text-blue-600">{{ contact.email || '-' }}</td>
                                        <td class="px-4 py-3 text-sm font-mono">{{ contact.phone || '-' }}</td>
                                        <td class="px-4 py-3 text-sm">{{ contact.address || '-' }}</td>
                                        <td class="px-4 py-3 text-sm">{{ contact.city || '-' }}</td>
                                        <td class="px-4 py-3 text-sm">{{ contact.province || '-' }}</td>
                                        <td class="px-4 py-3 text-sm font-mono">{{ contact.postalCode || '-' }}</td>
                                        <td class="px-4 py-3 text-sm">
                                            <span v-for="cat in getDisplayCategories(contact)" :key="cat" 
                                                  class="inline-block px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded mr-1">
                                                {{ cat }}
                                            </span>
                                            <span v-if="getDisplayCategories(contact).length === 0">-</span>
                                        </td>
                                        <td class="px-4 py-3 text-sm font-mono">{{ contact.pollNumber || '-' }}</td>
                                    </template>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div v-if="legacyImportPreviewErrors.length > 0" class="bg-red-50 border border-red-200 rounded-lg p-4">
                        <h4 class="font-medium text-red-900 mb-2">Rows with Errors:</h4>
                        <ul class="text-sm text-red-700 space-y-1">
                            <li v-for="error in legacyImportPreviewErrors" :key="error.row">
                                Row {{ error.row }}: {{ error.message }}
                            </li>
                        </ul>
                    </div>
                    
                    <!-- Category Selection -->
                    <div class="bg-indigo-50 border border-indigo-200 rounded-lg p-4">
                        <div class="flex items-center justify-between">
                            <div class="flex-1">
                                <label for="legacyImportCategoryPreview" class="block text-sm font-medium text-indigo-900 mb-2">
                                    Apply Category to All Imported Contacts (Optional)
                                </label>
                                <div class="space-y-2">
                                    <div class="flex gap-3">
                                        <select v-model="legacyImportCategory" 
                                                id="legacyImportCategoryPreview"
                                                class="border border-indigo-300 rounded-md px-3 py-2 text-sm flex-1 bg-white focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                                            <option value="">No Category</option>
                                            <option v-for="category in uniqueCategories" 
                                                    :key="category" 
                                                    :value="category">
                                                {{ category }}
                                            </option>
                                        </select>
                                        <button v-if="legacyImportCategory" 
                                                @click="legacyImportCategory = ''"
                                                type="button"
                                                class="px-3 py-2 text-sm text-indigo-700 hover:text-indigo-900 border border-indigo-300 rounded-md hover:bg-indigo-100">
                                            Clear
                                        </button>
                                    </div>
                                </div>
                                <p class="text-xs text-indigo-700 mt-2">
                                    This category will be added to all {{ legacyImportTotalRows }} contacts during import.
                                </p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex justify-between">
                        <button @click="cancelLegacyImport" 
                                type="button"
                                class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50">
                            Cancel
                        </button>
                        <button @click="finalizeLegacyImport" 
                                :disabled="finalizingLegacyImport || legacyImportPreview.length === 0"
                                class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed">
                            {{ finalizingLegacyImport ? 'Importing...' : `Import ${legacyImportTotalRows} Contacts` }}
                        </button>
                    </div>
                </div>

                <!-- Import Results -->
                <div v-if="importResults" class="mt-4">
                    <div class="bg-gray-50 rounded-lg p-4">
                        <h4 class="font-medium mb-2">Import Results:</h4>
                        <ul class="space-y-2">
                            <li class="text-green-600">
                                Successfully imported: {{ importResults.success }} contacts
                            </li>
                            <li v-if="importResults.errors.length" class="text-red-600">
                                Failed to import: {{ importResults.errors.length }} contacts
                                <ul class="ml-4 mt-2 text-sm">
                                    <li v-for="error in importResults.errors" :key="error.row">
                                        Row {{ error.row }}: {{ error.message }}
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Undo Upload Confirmation Dialog -->
        <div v-if="showUndoDialog" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50" role="dialog" aria-labelledby="undo-dialog-title" aria-modal="true">
            <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <div style="margin: 0 auto; display: flex; align-items: center; justify-content: center; height: 48px; width: 48px; border-radius: 50%; background-color: #fef3c7;">
                        <svg style="height: 24px; width: 24px; color: #d97706;" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path>
                        </svg>
                    </div>
                    <h3 id="undo-dialog-title" class="text-lg leading-6 font-medium text-gray-900 mt-4">
                        Undo Contact Upload
                    </h3>
                    <div class="mt-2 px-7 py-3">
                        <p class="text-sm text-gray-500" v-if="pendingUndoOperation">
                            Are you sure you want to undo the upload of 
                            <strong>{{ pendingUndoOperation.contactCount }} contacts</strong> 
                            from {{ formatUploadDate(pendingUndoOperation.timestamp) }}?
                        </p>
                        <p style="font-size: 0.875rem; color: #d97706; margin-top: 8px; font-weight: 500;">
                            This action cannot be undone. The contacts will be permanently removed.
                        </p>
                    </div>
                    <div class="items-center px-4 py-3">
                        <div class="flex space-x-3">
                            <button @click="cancelUndo" 
                                    type="button"
                                    class="px-4 py-2 bg-gray-200 text-gray-800 text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-300">
                                Cancel
                            </button>
                            <button @click="confirmUndo" 
                                    type="button"
                                    style="padding: 8px 16px; background-color: #f59e0b; color: white; font-size: 16px; font-weight: 500; border-radius: 6px; width: 100%; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); border: none; transition: background-color 0.2s;"
                                    onmouseover="this.style.backgroundColor='#d97706'"
                                    onmouseout="this.style.backgroundColor='#f59e0b'">
                                Undo Upload
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
const { createApp } = Vue

const app = createApp({
    data() {
        return {
            contacts: [],
            contactStructure: 'standard', // 'standard' or 'eda_special'
            isElectionAccount: <%= typeof isElectionAccount !== 'undefined' ? isElectionAccount : false %>,
            search: '',
            categoryFilter: '',
            selectedContacts: [],
            selectAll: false,
            showAddForm: false,
            showEditForm: false,
            processing: false,
            importData: '',
            importResults: null,
            validationErrors: [],
            editValidationErrors: [],
            postalCodeStatus: null,
            editPostalCodeStatus: null,
            addressSuggestions: [],
            provinces: [
                { code: 'AB', name: 'Alberta' },
                { code: 'BC', name: 'British Columbia' },
                { code: 'MB', name: 'Manitoba' },
                { code: 'NB', name: 'New Brunswick' },
                { code: 'NL', name: 'Newfoundland and Labrador' },
                { code: 'NS', name: 'Nova Scotia' },
                { code: 'NT', name: 'Northwest Territories' },
                { code: 'NU', name: 'Nunavut' },
                { code: 'ON', name: 'Ontario' },
                { code: 'PE', name: 'Prince Edward Island' },
                { code: 'QC', name: 'Quebec' },
                { code: 'SK', name: 'Saskatchewan' },
                { code: 'YT', name: 'Yukon' }
            ],
            newContact: {
                // Standard structure fields
                firstName: '',
                lastName: '',
                email: '',
                phone: '',
                address: '',
                city: '',
                province: '',
                postalCode: '',
                categories: [],
                pollNumber: '',
                notes: '',
                // Special EDA structure fields
                name: '',
                riding: '',
                role: ''
            },
            editingContact: {
                id: null,
                // Standard structure fields
                firstName: '',
                lastName: '',
                email: '',
                phone: '',
                address: '',
                city: '',
                province: '',
                postalCode: '',
                categories: [],
                pollNumber: '',
                notes: '',
                // Special EDA structure fields
                name: '',
                riding: '',
                role: '',
                // Subscription status
                communicationPreferences: null,
                emailSubscribed: true,
                smsSubscribed: true,
                voiceSubscribed: true
            },
            get tableHeaders() {
                const baseHeaders = [
                    { key: 'lastName', label: 'Last Name' },
                    { key: 'firstName', label: 'First Name' },
                    { key: 'email', label: 'Email' },
                    { key: 'phone', label: 'Phone' },
                    { key: 'category', label: 'Category' },
                    { key: 'pollNumber', label: 'Poll #' },
                    { key: 'notes', label: 'Notes' },
                    { key: 'address', label: 'Address' },
                    { key: 'city', label: 'City' },
                    { key: 'province', label: 'Province' },
                    { key: 'postalCode', label: 'Postal Code' },
                    { key: 'communicationStatus', label: 'Communication Status' }
                ];
                if (this.isElectionAccount) {
                    baseHeaders.push({ key: 'interactionNotes', label: 'Latest Interaction' });
                }
                return baseHeaders;
            },
            compactTableHeaders: [
                { key: 'fullName', label: 'Name' },
                { key: 'category', label: 'Category' },
                { key: 'email', label: 'Email' },
                { key: 'city', label: 'City' },
                { key: 'communicationStatus', label: 'Status' },
                { key: 'pollNumber', label: 'Poll #' },
                { key: 'notes', label: 'Notes' }
            ],
            unsubscribeFilter: '',
            currentPage: 1,
            contactsPerPage: 50, // Reduced from 250 for better usability
            showAddressSuggestions: false,
            showEditAddressSuggestions: false,
            showEmailDomains: false,
            showEditEmailDomains: false,
            addressTimeout: null,
            newCategoryName: '',
            newEditCategoryName: '',
            availableCategories: [],
            popularEmailDomains: ['@gmail.com', '@gmail.ca', '@yahoo.com', '@hotmail.com', '@outlook.com', '@live.com'],
            compactView: false,
            showCategoryDropdown: false,
            showEditCategoryDropdown: false,
            // Trash management
            showTrash: false,
            trash: [],
            selectedTrash: [],
            selectAllTrash: false,
            showUndoToast: false,
            undoTimeout: null,
            // Upload undo functionality
            uploadHistory: [],
            showUndoDialog: false,
            pendingUndoOperation: null,
            // Notes popup
            showNotesModal: false,
            notesModalContact: null,
            notesModalNewText: '',
            notesModalAuthorName: '',
            savingNotesModal: false,
            // Export functionality
            exportingContacts: false,
            // Smart Import functionality
            smartImportStep: 1, // 1 = upload, 2 = preview
            smartImportMethod: 'file', // 'file' or 'paste'
            smartImportFile: null,
            smartImportPasteData: '',
            isDragging: false,
            parsingFile: false,
            smartImportHeaders: [],
            smartImportColumnMapping: {},
            smartImportFileData: [],
            smartImportTotalRows: 0,
            previewingImport: false,
            smartImportPreview: [],
            smartImportPreviewErrors: [],
            finalizingImport: false,
            bulkImportCategory: '', // Category to apply to all imported contacts
            newBulkImportCategory: '', // Input field for adding new category in smart import
            // Legacy Import functionality
            legacyImportStep: 1, // 1 = upload/paste, 2 = preview
            legacyImportMethod: 'paste', // 'file' or 'paste'
            legacyImportFile: null,
            legacyIsDragging: false,
            legacyImportCategory: '', // Category to apply to all imported contacts
            newLegacyImportCategory: '', // Input field for adding new category in legacy import
            legacyImportPreview: [], // Preview of contacts to be imported
            legacyImportPreviewErrors: [], // Errors in preview
            legacyImportTotalRows: 0, // Total number of contacts
            legacyImportProcessedData: null, // Processed contact data ready for import
            finalizingLegacyImport: false
        }
    },
    computed: {
        filteredContacts() {
            const isSpecial = this.contactStructure === 'eda_special';

            const filtered = this.contacts.filter(contact => {
                // Match search term - search specific fields based on structure
                const searchMatch = !this.search || (() => {
                    const searchLower = this.search.toLowerCase();
                    if (isSpecial) {
                        return (contact.name || '').toLowerCase().includes(searchLower) ||
                               (contact.riding || '').toLowerCase().includes(searchLower) ||
                               (contact.province || '').toLowerCase().includes(searchLower) ||
                               (contact.email || '').toLowerCase().includes(searchLower) ||
                               (contact.role || '').toLowerCase().includes(searchLower) ||
                               (contact.phone || '').toLowerCase().includes(searchLower);
                    } else {
                        return (contact.firstName || '').toLowerCase().includes(searchLower) ||
                               (contact.lastName || '').toLowerCase().includes(searchLower) ||
                               (contact.email || '').toLowerCase().includes(searchLower) ||
                               (contact.phone || '').toLowerCase().includes(searchLower) ||
                               (contact.city || '').toLowerCase().includes(searchLower);
                    }
                })();

                // Match category filter - support both single and multiple categories
                const categoryMatch = !this.categoryFilter || 
                    (Array.isArray(contact.categories) 
                        ? contact.categories.some(cat => 
                            cat === this.categoryFilter ||
                            cat.toLowerCase() === this.categoryFilter.toLowerCase() ||
                            cat.trim() === this.categoryFilter.trim()
                          )
                        : (contact.category === this.categoryFilter ||
                           contact.category?.toLowerCase() === this.categoryFilter.toLowerCase() ||
                           contact.category?.trim() === this.categoryFilter.trim()));

                // Match unsubscribe filter
                const unsubscribeMatch = !this.unsubscribeFilter || (() => {
                    const prefs = contact.communicationPreferences || {};
                    const emailSubscribed = !prefs.email || prefs.email.subscribed !== false;
                    const smsSubscribed = !prefs.sms || prefs.sms.subscribed !== false;
                    const voiceSubscribed = !prefs.voice || prefs.voice.subscribed !== false;
                    
                    switch(this.unsubscribeFilter) {
                        case 'subscribed_all':
                            return emailSubscribed && smsSubscribed && voiceSubscribed;
                        case 'unsubscribed_email':
                            return !emailSubscribed;
                        case 'unsubscribed_sms':
                            return !smsSubscribed;
                        case 'unsubscribed_voice':
                            return !voiceSubscribed;
                        case 'unsubscribed_any':
                            return !emailSubscribed || !smsSubscribed || !voiceSubscribed;
                        case 'unsubscribed_all':
                            return !emailSubscribed && !smsSubscribed && !voiceSubscribed;
                        default:
                            return true;
                    }
                })();

                return searchMatch && categoryMatch && unsubscribeMatch;
            });

            // Sort based on structure type
            return filtered.sort((a, b) => {
                if (isSpecial) {
                    const nameA = (a.name || '').toLowerCase();
                    const nameB = (b.name || '').toLowerCase();
                    return nameA.localeCompare(nameB);
                } else {
                    const firstNameA = (a.firstName || '').toLowerCase();
                    const firstNameB = (b.firstName || '').toLowerCase();
                    const lastNameA = (a.lastName || '').toLowerCase();
                    const lastNameB = (b.lastName || '').toLowerCase();
                    
                    // First sort by lastName
                    if (lastNameA !== lastNameB) {
                        return lastNameA.localeCompare(lastNameB);
                    }
                    
                    // If lastName is the same, sort by firstName
                    return firstNameA.localeCompare(firstNameB);
                }
            });
        },
        displayTableHeaders() {
                if (this.contactStructure === 'eda_special') {
                if (this.compactView) {
                    // Compact view for special structure - show fewer columns
                    const headers = [
                        { key: 'name', label: 'Name' },
                        { key: 'category', label: 'Category' },
                        { key: 'province', label: 'Province' },
                        { key: 'communicationStatus', label: 'Status' },
                        { key: 'pollNumber', label: 'Poll #' },
                        { key: 'notes', label: 'Notes' }
                    ];
                    if (this.isElectionAccount) {
                        headers.push({ key: 'interactionNotes', label: 'Latest Interaction' });
                    }
                    return headers;
                } else {
                    // Normal view for special structure - show all columns
                    const headers = [
                        { key: 'name', label: 'Name' },
                        { key: 'riding', label: 'Riding' },
                        { key: 'province', label: 'Province' },
                        { key: 'email', label: 'Email' },
                        { key: 'role', label: 'Role' },
                        { key: 'phone', label: 'Phone' },
                        { key: 'category', label: 'Category' },
                        { key: 'pollNumber', label: 'Poll #' },
                        { key: 'notes', label: 'Notes' },
                        { key: 'communicationStatus', label: 'Communication Status' }
                    ];
                    if (this.isElectionAccount) {
                        headers.push({ key: 'interactionNotes', label: 'Latest Interaction' });
                    }
                    return headers;
                }
            }
            const baseHeaders = this.compactView ? this.compactTableHeaders : this.tableHeaders;
            if (this.isElectionAccount && !baseHeaders.find(h => h.key === 'interactionNotes')) {
                return [...baseHeaders, { key: 'interactionNotes', label: 'Latest Interaction' }];
            }
            return baseHeaders;
        },
        paginatedContacts() {
            const start = (this.currentPage - 1) * this.contactsPerPage;
            const end = this.currentPage * this.contactsPerPage;
            return this.filteredContacts.slice(start, end);
        },
        hasMoreContacts() {
            return this.paginatedContacts.length < this.filteredContacts.length;
        },
        totalPages() {
            return Math.ceil(this.filteredContacts.length / this.contactsPerPage);
        },
        visiblePages() {
            const pages = [];
            const start = Math.max(1, this.currentPage - 2);
            const end = Math.min(this.totalPages, this.currentPage + 2);
            
            for (let i = start; i <= end; i++) {
                pages.push(i);
            }
            
            return pages;
        },
        showPagination() {
            return this.filteredContacts.length > this.contactsPerPage;
        },
        uniqueCategories() {
            // Use the availableCategories data property instead of trying to modify computed property
            return this.availableCategories;
        },
        totalContactsCount() {
            return this.contacts.length;
        },
        trashCount() {
            return this.trash.length;
        },
        canUndoUpload() {
            return this.uploadHistory && this.uploadHistory.length > 0;
        },
        mostRecentUpload() {
            return this.uploadHistory && this.uploadHistory.length > 0 ? this.uploadHistory[0] : null;
        },

    },
    watch: {
        categoryFilter() {
            // Reset pagination when filter changes
            this.currentPage = 1;
            this.selectedContacts = [];
            this.selectAll = false;
        },
        search() {
            // Reset pagination when search changes
            this.currentPage = 1;
            this.selectedContacts = [];
            this.selectAll = false;
        },
        unsubscribeFilter() {
            // Reset pagination when unsubscribe filter changes
            this.currentPage = 1;
            this.selectedContacts = [];
            this.selectAll = false;
        }
    },
    methods: {
        // Validation methods
        validateField(field, value, isEdit = false) {
            const errorsArray = isEdit ? this.editValidationErrors : this.validationErrors;
            
            // Remove any existing errors for this field
            const filteredErrors = errorsArray.filter(error => {
                if (field === 'firstName' && error.includes('First name')) return false;
                if (field === 'lastName' && error.includes('Last name')) return false;
                if (field === 'email' && error.includes('email')) return false;
                if (field === 'phone' && error.includes('phone')) return false;
                if (field === 'postalCode' && error.includes('postal code')) return false;
                return true;
            });
            
            // Update the appropriate errors array
            if (isEdit) {
                this.editValidationErrors = filteredErrors;
            } else {
                this.validationErrors = filteredErrors;
            }
            
            switch (field) {
                case 'firstName':
                case 'lastName':
                    if (!value.trim()) {
                        const errorMessage = `${field === 'firstName' ? 'First name' : 'Last name'} is required`;
                        if (isEdit) {
                            this.editValidationErrors.push(errorMessage);
                        } else {
                            this.validationErrors.push(errorMessage);
                        }
                    }
                    break;
                case 'email':
                    if (value && !this.isValidEmail(value)) {
                        const errorMessage = 'Please enter a valid email address';
                        if (isEdit) {
                            this.editValidationErrors.push(errorMessage);
                        } else {
                            this.validationErrors.push(errorMessage);
                        }
                    }
                    break;
                case 'phone':
                    if (value && !this.isValidPhone(value)) {
                        const errorMessage = 'Please enter a valid phone number';
                        if (isEdit) {
                            this.editValidationErrors.push(errorMessage);
                        } else {
                            this.validationErrors.push(errorMessage);
                        }
                    }
                    break;
                case 'postalCode':
                    if (value && !this.isValidPostalCode(value)) {
                        const errorMessage = 'Please enter a valid postal code (e.g., A1A 1A1)';
                        if (isEdit) {
                            this.editValidationErrors.push(errorMessage);
                        } else {
                            this.validationErrors.push(errorMessage);
                        }
                    }
                    break;
            }
        },
        
        // Validation helper methods
        isValidEmail(email) {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return emailRegex.test(email);
        },
        
        isValidPhone(phone) {
            // Remove all non-digits
            const digits = phone.replace(/\D/g, '');
            return digits.length >= 10 && digits.length <= 11;
        },
        
        isValidPostalCode(postalCode) {
            // Remove spaces and convert to uppercase for validation
            const cleanCode = postalCode.replace(/\s/g, '').toUpperCase();
            
            // More flexible validation - just check if it's 6 characters with letters and numbers
            // This allows various Canadian postal code formats
            return cleanCode.length === 6 && /^[A-Z0-9]{6}$/.test(cleanCode);
        },

        // Header normalization helpers for messy imports
        normalizeHeaderAlias(header = '') {
            return header
                .toLowerCase()
                .replace(/[\s/_-]+/g, ' ')
                .replace(/[^a-z0-9 ]/g, '')
                .trim();
        },

        findHeaderAlias(headers = [], aliases = []) {
            const normalizedAliases = aliases.map(alias => this.normalizeHeaderAlias(alias));
            return headers.find(header => normalizedAliases.includes(this.normalizeHeaderAlias(header)));
        },

        getCPCHeader(headers = [], type) {
            const aliasMap = {
                name: [
                    'last name',
                    'member name / id',
                    'member name/id',
                    'member name id',
                    'member name',
                    'member name and id'
                ],
                info: [
                    'member information',
                    'member info',
                    'member details',
                    'member information / details'
                ]
            };
            const aliases = aliasMap[type] || [];
            return this.findHeaderAlias(headers, aliases);
        },
        
        // Formatting methods
        formatEmail(isEdit = false) {
            const contact = isEdit ? this.editingContact : this.newContact;
            if (contact.email) {
                contact.email = contact.email.toLowerCase().trim();
            }
        },
        
        formatPhone(isEdit = false) {
            const contact = isEdit ? this.editingContact : this.newContact;
            if (contact.phone) {
                // Remove all non-digits
                const digits = contact.phone.replace(/\D/g, '');
                
                if (digits.length === 10) {
                    // Format as (XXX) XXX-XXXX
                    contact.phone = `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
                } else if (digits.length === 11 && digits[0] === '1') {
                    // Format as 1 (XXX) XXX-XXXX
                    contact.phone = `1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;
                }
            }
        },
        
        formatPostalCodeInput(isEdit = false) {
            const contact = isEdit ? this.editingContact : this.newContact;
            if (contact.postalCode) {
                // Remove all non-alphanumeric characters and convert to uppercase
                let formatted = contact.postalCode.replace(/[^A-Za-z0-9]/g, '').toUpperCase();
                
                // Only format if we have exactly 6 characters
                if (formatted.length === 6) {
                    formatted = formatted.slice(0, 3) + ' ' + formatted.slice(3);
                    contact.postalCode = formatted;
                    // Trigger address lookup after formatting
                    this.$nextTick(() => {
                        if (isEdit) {
                            this.lookupAddressByPostalCode(true);
                        } else {
                            this.lookupAddressByPostalCode();
                        }
                    });
                } else {
                    contact.postalCode = formatted;
                }
            }
        },
        
        // Address auto-completion
        async handleAddressInput(isEdit = false) {
            const contact = isEdit ? this.editingContact : this.newContact;
            const input = contact.address;
            
            if (!input || input.length < 2) {
                this.addressSuggestions = [];
                return;
            }
            
            // Clear any existing timeout
            if (this.addressTimeout) {
                clearTimeout(this.addressTimeout);
            }
            
            // Debounce the API call
            this.addressTimeout = setTimeout(async () => {
                try {
                    // Build search query - include postal code if available for better results
                    let searchQuery = input;
                    if (contact.postalCode && contact.city) {
                        // Include city and postal code for more specific results
                        searchQuery = `${input}, ${contact.city}, ${contact.postalCode}`;
                    } else if (contact.postalCode) {
                        // Include postal code if no city
                        searchQuery = `${input}, ${contact.postalCode}`;
                    }
                    
                    const response = await fetch(`/api/places/autocomplete?input=${encodeURIComponent(searchQuery)}`, {
                        credentials: 'include'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.addressSuggestions = data.predictions || [];
                    } else {
                        console.error('Address autocomplete failed:', response.status);
                        this.addressSuggestions = [];
                    }
                } catch (error) {
                    console.error('Address autocomplete error:', error);
                    this.addressSuggestions = [];
                }
            }, 200); // Reduced from 300ms to 200ms for faster response
        },
        
        // Postal code lookup methods
        async lookupAddressByPostalCode(isEdit = false) {
            const contact = isEdit ? this.editingContact : this.newContact;
            const statusProperty = isEdit ? 'editPostalCodeStatus' : 'postalCodeStatus';
            const clearMethod = isEdit ? 'clearEditAddressFields' : 'clearAddressFields';
            
            if (!contact.postalCode) {
                this.clearAddressFields(isEdit);
                this[statusProperty] = null;
                return;
            }
            
            const postalCode = contact.postalCode.replace(/\s/g, '').toUpperCase();
            
            try {
                const response = await fetch(`/api/geocode/postalcode?postalCode=${encodeURIComponent(postalCode)}`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.success) {
                        contact.city = data.location.city;
                        contact.province = data.location.province;
                        
                        this[statusProperty] = {
                            type: 'success',
                            message: `City and province auto-filled for ${data.location.city}, ${data.location.province}. Please enter your street address.`
                        };
                    } else {
                        this[statusProperty] = {
                            type: 'warning',
                            message: 'Postal code not found. Please enter address manually.'
                        };
                    }
                } else {
                    this[statusProperty] = {
                        type: 'warning',
                        message: 'Unable to lookup postal code. Please enter address manually.'
                    };
                }
            } catch (error) {
                console.error('Postal code lookup error:', error);
                this[statusProperty] = {
                    type: 'warning',
                    message: 'Error looking up postal code. Please enter address manually.'
                };
            }
        },
        
        getProvinceName(code) {
            const province = this.provinces.find(p => p.code === code);
            return province ? province.name : code;
        },
        
        clearAddressFields(isEdit = false) {
            const contact = isEdit ? this.editingContact : this.newContact;
            contact.address = '';
            contact.city = '';
            contact.province = '';
        },
        
        async loadContacts() {
            try {
                // Load user data to get contact structure
                const userResponse = await fetch('/api/user', {
                    credentials: 'include'
                });
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    this.contactStructure = userData.contactStructure || 'standard';
                }
                
                const response = await fetch('/api/contacts', {
                    credentials: 'include' // Include cookies
                });
                if (response.ok) {
                    this.contacts = await response.json();
                    this.updateAvailableCategories(); // Update categories after loading contacts
                } else if (window.redirectToLoginOn401 && window.redirectToLoginOn401(response, { from: 'contact-manager', api: 'loadContacts' })) {
                } else {
                    console.error('Failed to load contacts:', response.status);
                    // Show user-friendly error message
                    alert('Failed to load contacts. Please refresh the page and try again.');
                }
            } catch (error) {
                console.error('Failed to load contacts:', error);
                // Show user-friendly error message
                alert('Failed to load contacts. Please refresh the page and try again.');
            }
        },
        
        async addContact() {
            // Clear previous validation errors
            this.validationErrors = [];
            
            // Validate required fields based on structure
            if (this.contactStructure === 'eda_special') {
                if (!this.newContact.name || !this.newContact.name.trim()) {
                    this.validationErrors.push('Name is required');
                }
            } else {
                this.validateField('firstName', this.newContact.firstName);
                this.validateField('lastName', this.newContact.lastName);
            }
            
            if (this.newContact.email) {
                this.validateField('email', this.newContact.email);
            }
            if (this.newContact.phone) {
                this.validateField('phone', this.newContact.phone);
            }
            if (this.newContact.postalCode) {
                this.validateField('postalCode', this.newContact.postalCode);
            }
            
            if (this.validationErrors.length > 0) {
                return;
            }
            
            try {
                // Prepare contact data based on structure
                let contactData;
                if (this.contactStructure === 'eda_special') {
                    contactData = {
                        name: this.newContact.name,
                        riding: this.newContact.riding || '',
                        province: this.newContact.province || '',
                        email: this.newContact.email || '',
                        role: this.newContact.role || '',
                        phone: this.newContact.phone || '',
                        categories: this.newContact.categories || [],
                        notes: (this.newContact.notes || '').trim() || undefined,
                        notesUpdatedAt: (this.newContact.notes || '').trim() ? new Date().toISOString() : undefined
                    };
                } else {
                    contactData = { ...this.newContact };
                }
                if ((contactData.notes || '').trim()) {
                    contactData.notesUpdatedAt = new Date().toISOString();
                }
                
                const response = await fetch('/api/contacts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include', // Include cookies
                    body: JSON.stringify(contactData)
                });
                
                if (response.ok) {
                    this.contacts = await response.json();
                    this.updateAvailableCategories(); // Update categories after adding contact
                    this.showAddForm = false;
                    this.resetNewContact();
                    this.validationErrors = [];
                } else if (response.status === 401) {
                    window.location.href = '/login?loop=1';
                } else {
                    throw new Error('Failed to add contact');
                }
            } catch (error) {
                console.error('Failed to add contact:', error);
                alert(`Failed to add contact: ${error.message || 'Please check your input and try again.'}`);
            }
        },
        
        async deleteContact(id) {
            if (!confirm('Are you sure you want to delete this contact?')) return;
            
            try {
                const response = await fetch(`/api/contacts/${id}`, {
                    method: 'DELETE',
                    credentials: 'include' // Include cookies
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    // Handle both old format (direct array) and new format (object with contacts property)
                    if (Array.isArray(result)) {
                        this.contacts = result;
                    } else {
                        this.contacts = result.contacts || [];
                    }
                    
                    this.updateAvailableCategories(); // Update categories after deleting contact
                    this.showToast('Contact moved to trash. It can be restored within 30 days.', 'success');
                    
                    // Load trash to update the count
                    await this.loadTrash();
                } else if (window.redirectToLoginOn401 && window.redirectToLoginOn401(response, { from: 'contact-manager', api: 'deleteContact' })) {
                } else {
                    throw new Error('Failed to delete contact');
                }
            } catch (error) {
                console.error('Failed to delete contact:', error);
                this.showToast(`Failed to delete contact: ${error.message || 'Please try again.'}`, 'error');
            }
        },
        
        async deleteSelectedContacts() {
            if (!confirm(`Are you sure you want to delete ${this.selectedContacts.length} contacts?`)) return;
            
            try {
                const response = await fetch('/api/contacts/bulk-delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include', // Include cookies
                    body: JSON.stringify({ ids: this.selectedContacts })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    // Handle both old format (direct array) and new format (object with contacts property)
                    if (Array.isArray(result)) {
                        this.contacts = result;
                    } else {
                        this.contacts = result.contacts || [];
                    }
                    
                    this.selectedContacts = [];
                    this.selectAll = false;
                    this.updateAvailableCategories(); // Update categories after deleting selected contacts
                    
                    // Show success message
                    const deletedCount = result.deletedCount || this.selectedContacts.length;
                    this.showToast(`${deletedCount} contacts moved to trash. They can be restored within 30 days.`, 'success');
                    
                    // Load trash to update the count
                    await this.loadTrash();
                } else if (window.redirectToLoginOn401 && window.redirectToLoginOn401(response, { from: 'contact-manager', api: 'deleteContacts' })) {
                } else {
                    throw new Error('Failed to delete contacts');
                }
            } catch (error) {
                console.error('Failed to delete selected contacts:', error);
                this.showToast(`Failed to delete selected contacts: ${error.message || 'Please try again.'}`, 'error');
            }
        },
        
        async editSelectedContact() {
            if (this.selectedContacts.length !== 1) {
                alert('Please select exactly one contact to edit');
                return;
            }
            
            const contactId = this.selectedContacts[0];
            const contact = this.contacts.find(c => c.id === contactId);
            
            if (contact) {
                this.editingContact = { ...contact };
                this.showEditForm = true;
                this.showAddForm = false;
                this.editValidationErrors = [];
                setTimeout(() => {
                    window.scrollTo({
                        top: document.querySelector('.mt-4').offsetTop - 100,
                        behavior: 'smooth'
                    });
                }, 100);
            }
        },
        
        async processImport() {
            if (!this.importData.trim()) {
                this.showToast('Please paste some data to preview', 'error');
                return;
            }
            
            this.processing = true;
            try {
                // Split the pasted data into rows
                const rows = this.importData.trim().split('\n');
                const headers = rows[0].split('\t').map(h => h.trim().toLowerCase());
                
                // Validate headers based on structure
                const isSpecial = this.contactStructure === 'eda_special';
                const requiredFields = isSpecial ? ['name'] : ['firstname', 'lastname'];
                const missingFields = requiredFields.filter(field => !headers.includes(field));
                if (missingFields.length) {
                    throw new Error(`Missing required fields: ${missingFields.join(', ')}`);
                }
                
                // Process rows
                const contacts = [];
                const errors = [];
                
                for (let i = 1; i < rows.length; i++) {
                    try {
                        const values = rows[i].split('\t');
                        const contact = {};
                        
                        headers.forEach((header, index) => {
                            const value = values[index]?.trim() || '';
                            contact[header] = value;
                        });
                        
                        // Validate required fields based on structure
                        if (isSpecial) {
                            if (!contact.name) {
                                throw new Error('Missing required field: name');
                            }
                        } else {
                            if (!contact.firstname || !contact.lastname) {
                                throw new Error('Missing required fields');
                            }
                        }
                        
                        // Build categories array - only include category from data during preview
                        // Bulk category will be applied during final import
                        const categories = [];
                        if (contact.category) {
                            categories.push(contact.category);
                        }
                        
                        if (isSpecial) {
                            // Special EDA structure
                            contacts.push({
                                name: contact.name,
                                riding: contact.riding || '',
                                province: contact.province || '',
                                email: contact.email || '',
                                role: contact.role || '',
                                phone: contact.phone || '',
                                categories: categories,
                                pollNumber: contact.pollnumber || contact.pollNumber || ''
                            });
                        } else {
                            // Standard structure
                            contacts.push({
                                firstName: contact.firstname,
                                lastName: contact.lastname,
                                email: contact.email || '',
                                phone: contact.phone || '',
                                address: contact.address || '',
                                city: contact.city || '',
                                province: contact.province || '',
                                postalCode: contact.postalcode || '',
                                categories: categories,
                                pollNumber: contact.pollnumber || contact.pollNumber || ''
                            });
                        }
                    } catch (error) {
                        errors.push({ row: i + 1, message: error.message });
                    }
                }
                
                // Store preview data and show preview
                // Set preview data - ensure all data is set before changing step
                this.legacyImportPreview = contacts.slice(0, 20); // Show first 20 for preview
                this.legacyImportPreviewErrors = errors;
                this.legacyImportTotalRows = contacts.length;
                this.legacyImportProcessedData = contacts; // Store all contacts for final import
                
                // Use nextTick to ensure DOM updates after state change
                await this.$nextTick();
                
                // Set step after data is ready
                this.legacyImportStep = 2; // Move to preview step
                
                // Wait for DOM to update with new step
                await this.$nextTick();
                
                this.showToast(`Preview generated! ${contacts.length} contacts ready.`, 'success');
            } catch (error) {
                console.error('Failed to process import:', error);
                this.showToast(`Failed to process data: ${error.message || 'Please check your data format and try again.'}`, 'error');
            } finally {
                this.processing = false;
            }
        },
        
        async finalizeLegacyImport() {
            if (!this.legacyImportProcessedData || this.legacyImportProcessedData.length === 0) {
                this.showToast('No contacts to import', 'error');
                return;
            }
            
            this.finalizingLegacyImport = true;
            try {
                // Apply bulk category to all contacts if set
                const contactsToImport = this.legacyImportProcessedData.map(contact => {
                    const categories = [...(contact.categories || [])];
                    if (this.legacyImportCategory && this.legacyImportCategory.trim()) {
                        const bulkCat = this.legacyImportCategory.trim();
                        if (!categories.includes(bulkCat)) {
                            categories.push(bulkCat);
                        }
                    }
                    return {
                        ...contact,
                        categories: categories
                    };
                });
                
                const response = await fetch('/api/contacts/bulk-import', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ contacts: contactsToImport })
                });
                
                if (response.ok) {
                    this.contacts = await response.json();
                    this.updateAvailableCategories();
                    
                    // Show success message with category info
                    const categoryMsg = this.legacyImportCategory ? ` with category "${this.legacyImportCategory}"` : '';
                    this.showToast(`Successfully imported ${contactsToImport.length} contact${contactsToImport.length !== 1 ? 's' : ''}${categoryMsg}!`, 'success');
                    
                    // Reset import state
                    this.legacyImportStep = 1;
                    this.legacyImportFile = null;
                    this.importData = '';
                    this.legacyImportCategory = '';
                    this.newLegacyImportCategory = ''; // Reset new category input
                    this.legacyImportPreview = [];
                    this.legacyImportPreviewErrors = [];
                    this.legacyImportTotalRows = 0;
                    this.legacyImportProcessedData = null;
                    
                    // Clear file input if it exists
                    if (this.$refs.legacyImportFileInput) {
                        this.$refs.legacyImportFileInput.value = '';
                    }
                    
                    // Refresh upload history
                    await this.loadUploadHistory();
                } else if (response.status === 401) {
                    window.location.href = '/login?loop=1';
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to import contacts');
                }
            } catch (error) {
                console.error('Failed to import contacts:', error);
                this.showToast(`Failed to import contacts: ${error.message || 'Please try again.'}`, 'error');
            } finally {
                this.finalizingLegacyImport = false;
            }
        },
        
        cancelLegacyImport() {
            this.legacyImportStep = 1;
            this.legacyImportFile = null;
            this.importData = '';
            this.legacyImportCategory = '';
            this.newLegacyImportCategory = ''; // Reset new category input
            this.legacyImportPreview = [];
            this.legacyImportPreviewErrors = [];
            this.legacyImportTotalRows = 0;
            this.legacyImportProcessedData = null;
            
            // Clear file input if it exists
            if (this.$refs.legacyImportFileInput) {
                this.$refs.legacyImportFileInput.value = '';
            }
        },
        
        getDisplayCategories(contact) {
            const categories = [...(contact.categories || [])];
            if (this.legacyImportCategory && this.legacyImportCategory.trim()) {
                const bulkCat = this.legacyImportCategory.trim();
                if (!categories.includes(bulkCat)) {
                    categories.push(bulkCat);
                }
            }
            return categories;
        },
        
        toggleSelectAll() {
            if (this.selectAll) {
                this.selectedContacts = this.filteredContacts.map(c => c.id);
            } else {
                this.selectedContacts = [];
            }
        },
        
        resetNewContact() {
            this.newContact = {
                // Standard structure fields
                firstName: '',
                lastName: '',
                email: '',
                phone: '',
                address: '',
                city: '',
                province: '',
                postalCode: '',
                categories: [],
                pollNumber: '',
                notes: '',
                // Special EDA structure fields
                name: '',
                riding: '',
                role: ''
            };
            this.validationErrors = [];
            this.postalCodeStatus = null;
            this.showCategoryDropdown = false;
        },
        
        clearNewContact() {
            this.resetNewContact();
            // Also clear any additional form state
            this.newCategoryName = '';
            this.addressSuggestions = [];
            this.showEmailDomains = false;
            this.showAddressSuggestions = false;
            this.showCategoryDropdown = false;
        },
        
        editContact(contact) {
            // Extract subscription status from communicationPreferences
            const prefs = contact.communicationPreferences || {};
            const emailSubscribed = prefs.email?.subscribed !== false;
            const smsSubscribed = prefs.sms?.subscribed !== false;
            const voiceSubscribed = prefs.voice?.subscribed !== false;
            
            this.editingContact = { 
                ...contact,
                // Convert old single category to array format if needed
                categories: Array.isArray(contact.categories) 
                    ? [...contact.categories] 
                    : (contact.category ? [contact.category] : []),
                // Set subscription toggles
                emailSubscribed: emailSubscribed,
                smsSubscribed: smsSubscribed,
                voiceSubscribed: voiceSubscribed
            };
            this.showEditForm = true;
            this.showAddForm = false;
            this.editValidationErrors = [];
            setTimeout(() => {
                window.scrollTo({
                    top: document.querySelector('.mt-4').offsetTop - 100,
                    behavior: 'smooth'
                });
            }, 100);
        },
        
        async updateContact() {
            // Clear previous validation errors
            this.editValidationErrors = [];
            
            // Validate required fields based on structure
            if (this.contactStructure === 'eda_special') {
                if (!this.editingContact.name || !this.editingContact.name.trim()) {
                    this.editValidationErrors.push('Name is required');
                }
            } else {
                this.validateField('firstName', this.editingContact.firstName, true);
                this.validateField('lastName', this.editingContact.lastName, true);
            }
            
            if (this.editingContact.email) {
                this.validateField('email', this.editingContact.email, true);
            }
            if (this.editingContact.phone) {
                this.validateField('phone', this.editingContact.phone, true);
            }
            if (this.editingContact.postalCode) {
                this.validateField('postalCode', this.editingContact.postalCode, true);
            }
            
            if (this.editValidationErrors.length > 0) {
                return;
            }

            try {
                // Build communicationPreferences from subscription toggles
                const existingPrefs = this.editingContact.communicationPreferences || {};
                const communicationPreferences = {
                    email: {
                        subscribed: this.editingContact.emailSubscribed,
                        unsubscribedAt: !this.editingContact.emailSubscribed ? (existingPrefs.email?.unsubscribedAt || new Date().toISOString()) : null,
                        unsubscribeReason: !this.editingContact.emailSubscribed ? (existingPrefs.email?.unsubscribeReason || 'Manual unsubscribe by admin') : null
                    },
                    sms: {
                        subscribed: this.editingContact.smsSubscribed,
                        unsubscribedAt: !this.editingContact.smsSubscribed ? (existingPrefs.sms?.unsubscribedAt || new Date().toISOString()) : null,
                        unsubscribeReason: !this.editingContact.smsSubscribed ? (existingPrefs.sms?.unsubscribeReason || 'Manual unsubscribe by admin') : null
                    },
                    voice: {
                        subscribed: this.editingContact.voiceSubscribed,
                        unsubscribedAt: !this.editingContact.voiceSubscribed ? (existingPrefs.voice?.unsubscribedAt || new Date().toISOString()) : null,
                        unsubscribeReason: !this.editingContact.voiceSubscribed ? (existingPrefs.voice?.unsubscribeReason || 'Manual unsubscribe by admin') : null
                    }
                };
                
                // Prepare contact data based on structure
                let contactData;
                if (this.contactStructure === 'eda_special') {
                    contactData = {
                        id: this.editingContact.id,
                        name: this.editingContact.name,
                        riding: this.editingContact.riding || '',
                        province: this.editingContact.province || '',
                        email: this.editingContact.email || '',
                        role: this.editingContact.role || '',
                        phone: this.editingContact.phone || '',
                        categories: this.editingContact.categories || [],
                        communicationPreferences: communicationPreferences
                    };
                    // Notes are edited only via the notes modal; do not overwrite from main form
                } else {
                    contactData = {
                        ...this.editingContact,
                        communicationPreferences: communicationPreferences
                    };
                    // Remove the toggle fields as they're not part of the contact model
                    delete contactData.emailSubscribed;
                    delete contactData.smsSubscribed;
                    delete contactData.voiceSubscribed;
                    // Do not overwrite notes from main form; notes are managed in the notes modal
                    delete contactData.notes;
                    delete contactData.notesUpdatedAt;
                }
                
                const response = await fetch(`/api/contacts/${this.editingContact.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include', // Include cookies
                    body: JSON.stringify(contactData)
                });

                if (response.ok) {
                    const updatedContact = await response.json();
                    const index = this.contacts.findIndex(c => c.id === updatedContact.id);
                    if (index !== -1) {
                        this.contacts.splice(index, 1, updatedContact);
                    }
                    this.updateAvailableCategories(); // Update categories after updating contact
                    this.showEditForm = false;
                    this.editingContact = {
                        id: null,
                        firstName: '',
                        lastName: '',
                        email: '',
                        phone: '',
                        address: '',
                        city: '',
                        province: '',
                        postalCode: '',
                        categories: [],
                        pollNumber: '',
                        notes: ''
                    };
                    this.editValidationErrors = [];
                    // Unselect the contact to prevent accidental re-editing
                    this.selectedContacts = [];
                    this.selectAll = false;
                } else if (window.redirectToLoginOn401 && window.redirectToLoginOn401(response, { from: 'contact-manager', api: 'updateContact' })) {
                } else {
                    throw new Error('Failed to update contact');
                }
            } catch (error) {
                console.error('Failed to update contact:', error);
                alert(`Failed to update contact: ${error.message || 'Please check your input and try again.'}`);
            }
        },
        
        cancelEdit() {
            this.showEditForm = false;
            this.editingContact = {
                id: null,
                firstName: '',
                lastName: '',
                email: '',
                phone: '',
                address: '',
                city: '',
                province: '',
                postalCode: '',
                categories: [],
                pollNumber: '',
                notes: ''
            };
            this.editValidationErrors = [];
            this.editPostalCodeStatus = null;
            this.showEditCategoryDropdown = false;
        },
        
        clearEditContact() {
            // Clear the form but keep it open for editing
            this.editingContact = {
                id: this.editingContact.id, // Keep the ID
                firstName: '',
                lastName: '',
                email: '',
                phone: '',
                address: '',
                city: '',
                province: '',
                postalCode: '',
                categories: [],
                pollNumber: '',
                notes: ''
            };
            this.editValidationErrors = [];
            this.editPostalCodeStatus = null;
            // Also clear any additional form state
            this.newEditCategoryName = '';
            this.addressSuggestions = [];
            this.showEditEmailDomains = false;
            this.showEditAddressSuggestions = false;
            this.showEditCategoryDropdown = false;
        },
        
        handlePhoneInput(isEdit = false) {
            const contact = isEdit ? this.editingContact : this.newContact;
            if (!contact.phone) return;
            
            // Remove all non-digits
            const digits = contact.phone.replace(/\D/g, '');
            
            // If user is trying to clear the field, allow it
            if (digits.length === 0) {
                contact.phone = '';
                return;
            }
            
            // Format based on number of digits
            let formatted = '';
            if (digits.length <= 3) {
                formatted = `(${digits}`;
            } else if (digits.length <= 6) {
                formatted = `(${digits.slice(0, 3)}) ${digits.slice(3)}`;
            } else if (digits.length <= 10) {
                formatted = `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
            } else if (digits.length === 11 && digits[0] === '1') {
                formatted = `1 (${digits.slice(1, 4)}) ${digits.slice(4, 7)}-${digits.slice(7)}`;
            } else {
                // For numbers longer than expected, just format the first 10 digits
                formatted = `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6, 10)}`;
            }
            
            contact.phone = formatted;
        },
        
        handlePhoneKeydown(isEdit = false) {
            const contact = isEdit ? this.editingContact : this.newContact;
            const input = event.target;
            
            // Allow backspace, delete, tab, escape, enter, and arrow keys
            if ([8, 9, 27, 13, 37, 38, 39, 40, 46].includes(event.keyCode)) {
                return;
            }
            
            // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X, Ctrl+Z
            if (event.ctrlKey && [65, 67, 86, 88, 90].includes(event.keyCode)) {
                return;
            }
            
            // Only allow digits
            if (!/[0-9]/.test(event.key)) {
                event.preventDefault();
                return;
            }
            
            // If user is typing and we have a complete number, allow them to start over
            const digits = contact.phone.replace(/\D/g, '');
            if (digits.length >= 10 && !event.ctrlKey) {
                // If they're typing a new digit and we already have 10+ digits, clear and start fresh
                if (input.selectionStart === input.selectionEnd && input.selectionStart === input.value.length) {
                    contact.phone = event.key;
                    event.preventDefault();
                }
            }
        },
        
        hideAddressSuggestions(isEdit = false) {
            // Add a small delay to allow clicking on suggestions
            setTimeout(() => {
                if (isEdit) {
                    this.showEditAddressSuggestions = false;
                } else {
                    this.showAddressSuggestions = false;
                }
            }, 150);
        },
        
        hideEmailDomains(isEdit = false) {
            // Add a small delay to allow clicking on domain buttons
            setTimeout(() => {
                if (isEdit) {
                    this.showEditEmailDomains = false;
                } else {
                    this.showEmailDomains = false;
                }
            }, 150);
        },
        
        // Convert full province name to province code
        getProvinceCode(fullName) {
            const provinceMap = {
                'Alberta': 'AB',
                'British Columbia': 'BC',
                'Manitoba': 'MB',
                'New Brunswick': 'NB',
                'Newfoundland and Labrador': 'NL',
                'Nova Scotia': 'NS',
                'Northwest Territories': 'NT',
                'Nunavut': 'NU',
                'Ontario': 'ON',
                'Prince Edward Island': 'PE',
                'Quebec': 'QC',
                'Saskatchewan': 'SK',
                'Yukon': 'YT'
            };
            return provinceMap[fullName] || fullName;
        },
        
        async selectAddress(suggestion, isEdit = false) {
            const contact = isEdit ? this.editingContact : this.newContact;
            const showSuggestions = isEdit ? 'showEditAddressSuggestions' : 'showAddressSuggestions';
            
            try {
                // Extract the original house number from the address input field
                const addressInput = contact.address;
                const inputHouseNumberMatch = addressInput.match(/^(\d+)/);
                const originalHouseNumber = inputHouseNumberMatch ? inputHouseNumberMatch[1] : '';
                
                // First, try to get full address details from LocationIQ
                const response = await fetch(`/api/places/details?placeId=${suggestion.place_id}&lat=${suggestion.lat}&lon=${suggestion.lon}`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.success) {
                        // Fill in the address fields with the selected address
                        const address = data.address;
                        
                        // Build the street address - ALWAYS use the original house number if available
                        const streetParts = [];
                        if (originalHouseNumber) {
                            streetParts.push(originalHouseNumber);
                        } else if (address.house_number) {
                            streetParts.push(address.house_number);
                        }
                        if (address.road) streetParts.push(address.road);
                        contact.address = streetParts.join(' ').trim();
                        
                        // Fill in city, province, and postal code
                        contact.city = address.city || address.town || address.village || address.hamlet || '';
                        contact.province = this.getProvinceCode(address.state || '');
                        contact.postalCode = address.postcode || '';
                    }
                } else {
                    // Use the autocomplete data directly instead of falling back to fake addresses
                    this.fillAddressFromSuggestion(suggestion, contact, originalHouseNumber);
                }
            } catch (error) {
                console.error('Error getting address details:', error);
                // Use the autocomplete data directly instead of falling back to fake addresses
                this.fillAddressFromSuggestion(suggestion, contact, originalHouseNumber);
            }
            
            this[showSuggestions] = false;
        },
        
        // Helper method to fill address from autocomplete suggestion
        fillAddressFromSuggestion(suggestion, contact, originalHouseNumber = '') {
            const address = suggestion.address || {};
            
            // Build street address from suggestion - ALWAYS use original house number if available
            const streetParts = [];
            if (originalHouseNumber) {
                streetParts.push(originalHouseNumber);
            } else if (address.house_number) {
                streetParts.push(address.house_number);
            }
            if (address.road) streetParts.push(address.road);
            if (address.name && !address.road) streetParts.push(address.name); // Use name if road is not available
            
            if (streetParts.length > 0) {
                contact.address = streetParts.join(' ').trim();
            } else {
                // Try to extract from main_text if available
                const mainText = suggestion.structured_formatting?.main_text || '';
                if (mainText && mainText !== address.city) {
                    contact.address = mainText;
                } else {
                    contact.address = suggestion.structured_formatting?.main_text || '';
                }
            }
            
            // Fill in city, province, and postal code from suggestion
            contact.city = address.city || address.town || address.village || address.hamlet || '';
            contact.province = this.getProvinceCode(address.state || '');
            contact.postalCode = address.postcode || '';
        },
        
        confirmDeleteAllContacts() {
            // Enhanced confirmation dialog
            const contactCount = this.contacts.length;
            const confirmationMessage = `⚠️  DANGEROUS ACTION ⚠️\n\n` +
                `Are you sure you want to delete ALL ${contactCount} contacts?\n\n` +
                `This will move all contacts to trash where they can be restored within 30 days.\n\n` +
                `Type "DELETE ALL" to confirm:`;
            
            const userInput = prompt(confirmationMessage);
            
            if (userInput === 'DELETE ALL') {
                this.deleteAllContacts();
            } else if (userInput !== null) {
                alert('Confirmation text did not match. Action cancelled.');
            }
        },
        
        async deleteAllContacts() {
            try {

                const response = await fetch('/api/contacts/bulk-delete', {
                    method: 'DELETE',
                    credentials: 'include' // Include cookies
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    // Handle both old format (direct array) and new format (object with contacts property)
                    if (Array.isArray(result)) {
                        this.contacts = result;
                    } else {
                        this.contacts = result.contacts || [];
                    }
                    
                    this.updateAvailableCategories(); // Update categories after deleting all contacts
                    
                    // Show success message with undo option
                    const deletedCount = result.deletedCount || this.contacts.length;
                    this.showToast(`${deletedCount} contacts moved to trash. They can be restored within 30 days.`, 'success');
                    
                    // Load trash to update the count
                    await this.loadTrash();
                } else if (window.redirectToLoginOn401 && window.redirectToLoginOn401(response, { from: 'contact-manager', api: 'deleteAllContacts' })) {
                } else {
                    throw new Error('Failed to delete all contacts');
                }
            } catch (error) {
                console.error('Delete all contacts error:', error);
                this.showToast('Failed to delete all contacts: ' + error.message, 'error');
            }
        },
        
        removeCategory(category, isEdit = false) {
            const contact = isEdit ? this.editingContact : this.newContact;
            const index = contact.categories.indexOf(category);
            if (index > -1) {
                contact.categories.splice(index, 1);
            }
        },
        
        addNewCategory(isEdit = false) {
            const contact = isEdit ? this.editingContact : this.newContact;
            const categoryNameField = isEdit ? 'newEditCategoryName' : 'newCategoryName';
            const categoryName = this[categoryNameField].trim();
            
            if (!categoryName) {
                return; // Don't do anything if empty
            }
            
            // Normalize the category name
            const normalizedCategory = this.normalizeCategoryName(categoryName);
            
            // Check if category already exists in available categories (case-insensitive)
            const existingCategory = this.availableCategories.find(cat => 
                cat.toLowerCase() === normalizedCategory.toLowerCase()
            );
            
            if (existingCategory) {
                // If it exists but isn't selected, select it (use exact name from availableCategories)
                if (!contact.categories.includes(existingCategory)) {
                    contact.categories.push(existingCategory);
                }
                this[categoryNameField] = '';
                return;
            }
            
            // Check if this matches an allowed category (even if not yet in availableCategories)
            const allowedCategories = [
                'Member',
                'Donor',
                'Donor 400',
                'Donor 1000',
                'Volunteer',
                'Volunteer Driver',
                'Volunteer Door Knocker',
                'Volunteer Signs',
                'Volunteer Callers',
                'Lawn Sign',
                'Supporter',
                'Lapsed Member',
                'Undecided',
                'Non-Supporter',
                'Non-Supporter Liberal',
                'Non-Supporter NDP',
                'Non-Supporter Green'
            ];
            
            const matchingAllowedCategory = allowedCategories.find(allowed => 
                allowed.toLowerCase() === normalizedCategory.toLowerCase()
            );
            
            if (matchingAllowedCategory) {
                // Use the exact name from allowed categories
                if (!contact.categories.includes(matchingAllowedCategory)) {
                    contact.categories.push(matchingAllowedCategory);
                }
                // Add to available categories if not already there
                if (!this.availableCategories.includes(matchingAllowedCategory)) {
                    this.availableCategories.push(matchingAllowedCategory);
                    this.availableCategories.sort();
                }
            } else {
                // Category doesn't match allowed list - still add to contact but not to dropdown
                // This allows flexibility while keeping dropdown clean
                if (!contact.categories.includes(normalizedCategory)) {
                    contact.categories.push(normalizedCategory);
                }
            }
            
            this[categoryNameField] = '';
        },
        
        addBulkImportCategory() {
            const categoryName = this.newBulkImportCategory.trim();
            
            if (!categoryName) {
                return; // Don't do anything if empty
            }
            
            // Use the same normalization as updateAvailableCategories
            const normalizedCategory = categoryName.charAt(0).toUpperCase() + categoryName.slice(1).toLowerCase();
            
            // Check if category already exists (case-insensitive)
            const existingCategory = this.availableCategories.find(cat => 
                cat.toLowerCase() === normalizedCategory.toLowerCase()
            );
            
            if (existingCategory) {
                // If it exists, select it
                this.bulkImportCategory = existingCategory;
                this.newBulkImportCategory = '';
                return;
            }
            
            // Add to available categories and select it
            this.availableCategories.push(normalizedCategory);
            this.availableCategories.sort(); // Keep sorted
            this.bulkImportCategory = normalizedCategory;
            this.newBulkImportCategory = '';
        },
        
        addLegacyImportCategory() {
            const categoryName = this.newLegacyImportCategory.trim();
            
            if (!categoryName) {
                return; // Don't do anything if empty
            }
            
            // Use the same normalization as updateAvailableCategories
            const normalizedCategory = categoryName.charAt(0).toUpperCase() + categoryName.slice(1).toLowerCase();
            
            // Check if category already exists (case-insensitive)
            const existingCategory = this.availableCategories.find(cat => 
                cat.toLowerCase() === normalizedCategory.toLowerCase()
            );
            
            if (existingCategory) {
                // If it exists, select it
                this.legacyImportCategory = existingCategory;
                this.newLegacyImportCategory = '';
                return;
            }
            
            // Add to available categories and select it
            this.availableCategories.push(normalizedCategory);
            this.availableCategories.sort(); // Keep sorted
            this.legacyImportCategory = normalizedCategory;
            this.newLegacyImportCategory = '';
        },
        
        // Method to update available categories from contacts
        updateAvailableCategories() {
            // Define the allowed individual categories in hierarchical order (only these should appear in dropdowns)
            const allowedCategories = [
                'Member',
                'Donor',
                'Donor 400',
                'Donor 1000',
                'Volunteer',
                'Volunteer Driver',
                'Volunteer Door Knocker',
                'Volunteer Signs',
                'Volunteer Callers',
                'Lawn Sign',
                'Supporter',
                'Lapsed Member',
                'Undecided',
                'Non-Supporter',
                'Non-Supporter Liberal',
                'Non-Supporter NDP',
                'Non-Supporter Green'
            ];
            
            // Get all categories from contacts (both old single category and new multiple categories)
            const rawCategories = [];
            this.contacts.forEach(contact => {
                if (Array.isArray(contact.categories)) {
                    rawCategories.push(...contact.categories);
                } else if (contact.category) {
                    rawCategories.push(contact.category);
                }
            });

            // Process categories: extract individual categories and normalize
            const individualCategories = new Set();
            
            rawCategories.forEach(category => {
                if (!category || !category.trim()) return;
                
                const trimmed = category.trim();
                
                // Check if this is a combined category (contains semicolon or multiple categories)
                if (trimmed.includes(';')) {
                    // Split by semicolon and extract individual categories
                    const parts = trimmed.split(';').map(p => p.trim()).filter(p => p);
                    parts.forEach(part => {
                        // Normalize the individual category
                        const normalized = this.normalizeCategoryName(part);
                        // Only add if it's in the allowed list
                        if (allowedCategories.some(allowed => 
                            allowed.toLowerCase() === normalized.toLowerCase()
                        )) {
                            // Use the exact name from allowedCategories to maintain consistency
                            const exactMatch = allowedCategories.find(allowed => 
                                allowed.toLowerCase() === normalized.toLowerCase()
                            );
                            if (exactMatch) {
                                individualCategories.add(exactMatch);
                            }
                        }
                    });
                } else {
                    // Single category - normalize and check if allowed
                    const normalized = this.normalizeCategoryName(trimmed);
                    if (allowedCategories.some(allowed => 
                        allowed.toLowerCase() === normalized.toLowerCase()
                    )) {
                        // Use the exact name from allowedCategories to maintain consistency
                        const exactMatch = allowedCategories.find(allowed => 
                            allowed.toLowerCase() === normalized.toLowerCase()
                        );
                        if (exactMatch) {
                            individualCategories.add(exactMatch);
                        }
                    }
                }
            });

            // Maintain the hierarchical order: show all allowed categories in order,
            // but only include those that are either in the allowed list or found in contacts
            const orderedCategories = [];
            allowedCategories.forEach(category => {
                // Always include allowed categories (they should always be available)
                orderedCategories.push(category);
            });
            
            // Set the available categories in the specified hierarchical order
            this.availableCategories = orderedCategories;
        },
        
        // Helper method to normalize category names
        normalizeCategoryName(category) {
            if (!category || !category.trim()) return '';
            
            const trimmed = category.trim();
            
            // Handle different case formats
            if (trimmed === trimmed.toUpperCase()) {
                // ALL CAPS - convert to title case
                return trimmed.charAt(0).toUpperCase() + trimmed.slice(1).toLowerCase();
            } else if (trimmed === trimmed.toLowerCase()) {
                // all lowercase - convert to title case
                return trimmed.charAt(0).toUpperCase() + trimmed.slice(1).toLowerCase();
            } else {
                // Mixed case - assume it's already properly formatted, but ensure first letter is uppercase
                return trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
            }
        },

        selectEmailDomain(domain, isEdit = false) {
            const emailInput = isEdit ? this.editingContact.email : this.newContact.email;
            
            // Always extract the local part (everything before any @ symbol)
            let localPart = '';
            if (emailInput && emailInput.includes('@')) {
                localPart = emailInput.split('@')[0];
            } else if (emailInput) {
                localPart = emailInput;
            } else {
                localPart = 'user';
            }
            
            // Create new email with the selected domain
            const newEmail = `${localPart}${domain}`;
            
            if (isEdit) {
                this.editingContact.email = newEmail;
                this.validateField('email', newEmail, isEdit);
            } else {
                this.newContact.email = newEmail;
                this.validateField('email', newEmail);
            }
        },
        
        // Force refresh categories method
        forceRefreshCategories() {
            this.updateAvailableCategories();
            // Force Vue to re-render the dropdown
            this.$nextTick(() => {

            });
        },
        
        // Trash management methods
        async loadTrash() {
            try {
                const response = await fetch('/api/contacts/trash', {
                    credentials: 'include'
                });
                if (response.ok) {
                    this.trash = await response.json();
                } else {
                    console.error('Failed to load trash');
                }
            } catch (error) {
                console.error('Failed to load trash:', error);
            }
        },
        
        async restoreContact(contactId) {
            try {
                const response = await fetch('/api/contacts/restore', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ ids: [contactId] })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    this.contacts = result.contacts;
                    await this.loadTrash();
                    this.updateAvailableCategories();
                    this.showToast(result.message, 'success');
                }
            } catch (error) {
                console.error('Failed to restore contact:', error);
                this.showToast('Failed to restore contact', 'error');
            }
        },
        
        async restoreSelectedContacts() {
            if (this.selectedTrash.length === 0) return;
            
            try {
                const response = await fetch('/api/contacts/restore', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ ids: this.selectedTrash })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    this.contacts = result.contacts;
                    this.selectedTrash = [];
                    this.selectAllTrash = false;
                    await this.loadTrash();
                    this.updateAvailableCategories();
                    this.showToast(result.message, 'success');
                }
            } catch (error) {
                console.error('Failed to restore contacts:', error);
                this.showToast('Failed to restore contacts', 'error');
            }
        },
        
        async permanentlyDeleteContact(contactId) {
            if (!confirm('Are you sure you want to permanently delete this contact? This action cannot be undone.')) {
                return;
            }
            
            try {

                const response = await fetch('/api/contacts/trash', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ ids: [contactId] })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    await this.loadTrash();
                    this.showToast(result.message, 'success');
                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    console.error('Server error:', errorData);
                    this.showToast(`Failed to delete contact: ${errorData.error || 'Server error'}`, 'error');
                }
            } catch (error) {
                console.error('Failed to delete contact:', error);
                this.showToast(`Failed to delete contact: ${error.message}`, 'error');
            }
        },
        
        async permanentlyDeleteSelectedContacts() {
            if (this.selectedTrash.length === 0) return;
            
            if (!confirm(`Are you sure you want to permanently delete ${this.selectedTrash.length} contacts? This action cannot be undone.`)) {
                return;
            }
            
            try {

                const response = await fetch('/api/contacts/trash', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ ids: this.selectedTrash })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    this.selectedTrash = [];
                    this.selectAllTrash = false;
                    await this.loadTrash();
                    this.showToast(result.message, 'success');
                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    console.error('Server error:', errorData);
                    this.showToast(`Failed to delete contacts: ${errorData.error || 'Server error'}`, 'error');
                }
            } catch (error) {
                console.error('Failed to delete contacts:', error);
                this.showToast(`Failed to delete contacts: ${error.message}`, 'error');
            }
        },
        
        confirmEmptyTrash() {
            if (!confirm('Are you sure you want to permanently delete all contacts in trash? This action cannot be undone.')) {
                return;
            }
            this.permanentlyDeleteAllTrash();
        },
        
        async permanentlyDeleteAllTrash() {
            try {

                const response = await fetch('/api/contacts/trash', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({})
                });
                
                if (response.ok) {
                    const result = await response.json();
                    this.selectedTrash = [];
                    this.selectAllTrash = false;
                    await this.loadTrash();
                    this.showToast(result.message, 'success');
                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    console.error('Server error:', errorData);
                    this.showToast(`Failed to empty trash: ${errorData.error || 'Server error'}`, 'error');
                }
            } catch (error) {
                console.error('Failed to empty trash:', error);
                this.showToast(`Failed to empty trash: ${error.message}`, 'error');
            }
        },
        
        toggleSelectAllTrash() {
            if (this.selectAllTrash) {
                this.selectedTrash = this.trash.map(c => c.id);
            } else {
                this.selectedTrash = [];
            }
        },
        
        formatDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        },
        getNotesArray(contact) {
            if (!contact) return [];
            if (Array.isArray(contact.notes)) return contact.notes.filter(n => n && (n.text != null || n.updatedAt));
            const text = (contact.notes || '').trim();
            return text ? [{ text, updatedAt: contact.notesUpdatedAt || contact.updatedAt || null }] : [];
        },
        formatNoteTimestamp(note) {
            if (!note || !note.updatedAt) return 'Date unknown';
            const date = new Date(note.updatedAt);
            return isNaN(date.getTime()) ? 'Date unknown' : date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        },
        formatNotesTimestamp(contact) {
            const arr = this.getNotesArray(contact);
            if (arr.length === 0) return '—';
            const latest = arr[arr.length - 1];
            return this.formatNoteTimestamp(latest);
        },
        openNotesModal(contact) {
            this.notesModalContact = contact;
            this.notesModalNewText = '';
            this.showNotesModal = true;
        },
        closeNotesModal() {
            this.showNotesModal = false;
            this.notesModalContact = null;
            this.notesModalNewText = '';
            this.notesModalAuthorName = '';
        },
        async saveNotesFromModal() {
            if (!this.notesModalContact || !this.notesModalContact.id) return;
            const newText = (this.notesModalNewText || '').trim();
            const authorName = (this.notesModalAuthorName || '').trim();
            if (!newText || !authorName) {
                alert('Please enter your full name and the note text.');
                return;
            }
            try {
                this.savingNotesModal = true;
                const notesArray = this.getNotesArray(this.notesModalContact);
                notesArray.push({ text: newText, updatedAt: new Date().toISOString(), authorName });
                const res = await fetch(`/api/contacts/${this.notesModalContact.id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ notes: notesArray })
                });
                if (res.ok) {
                    const updated = await res.json();
                    const idx = this.contacts.findIndex(c => c.id === updated.id);
                    if (idx !== -1) this.contacts.splice(idx, 1, updated);
                    this.notesModalContact = updated;
                    this.notesModalNewText = '';
                    this.notesModalAuthorName = '';
                    if (this.editingContact && this.editingContact.id === updated.id) this.editingContact.notes = updated.notes;
                } else {
                    const err = await res.json();
                    alert('Failed to save note: ' + (err.error || 'Unknown error'));
                }
            } catch (e) {
                console.error(e);
                alert('Failed to save note.');
            } finally {
                this.savingNotesModal = false;
            }
        },
        
        showToast(message, type = 'info') {
            // Simple toast notification with close button and 30 second timeout
            const toast = document.createElement('div');
            toast.className = `fixed top-4 right-4 z-50 px-6 py-3 pr-10 rounded-lg text-white font-medium shadow-lg ${
                type === 'success' ? 'bg-green-500' : 
                type === 'error' ? 'bg-red-500' : 
                'bg-blue-500'
            }`;
            toast.style.minWidth = '300px';
            toast.style.maxWidth = '500px';
            toast.textContent = message;
            
            // Add close button
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '&times;';
            closeButton.className = 'absolute top-2 right-2 text-white hover:text-gray-200 font-bold text-xl leading-none';
            closeButton.style.width = '24px';
            closeButton.style.height = '24px';
            closeButton.style.lineHeight = '20px';
            closeButton.style.cursor = 'pointer';
            closeButton.setAttribute('aria-label', 'Close');
            closeButton.onclick = () => {
                clearTimeout(timeoutId);
                toast.remove();
            };
            toast.appendChild(closeButton);
            
            document.body.appendChild(toast);
            
            // Auto-remove after 30 seconds
            const timeoutId = setTimeout(() => {
                toast.remove();
            }, 30000);
        },
        
        // Upload undo methods
        async loadUploadHistory() {
            try {
                const response = await fetch('/api/contacts/upload-history', {
                    credentials: 'include'
                });
                if (response.ok) {
                    this.uploadHistory = await response.json();
                } else {
                    console.error('Failed to load upload history - Status:', response.status);
                }
            } catch (error) {
                console.error('Failed to load upload history:', error);
            }
        },
        
        showUndoConfirmation() {
            if (!this.canUndoUpload) return;
            
            this.pendingUndoOperation = this.mostRecentUpload;
            this.showUndoDialog = true;
        },
        
        cancelUndo() {
            this.showUndoDialog = false;
            this.pendingUndoOperation = null;
        },
        
        async confirmUndo() {
            if (!this.pendingUndoOperation) return;
            
            try {
                const response = await fetch('/api/contacts/undo-upload', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ 
                        uploadOperationId: this.pendingUndoOperation.id 
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    this.contacts = result.contacts;
                    this.uploadHistory = this.uploadHistory.filter(op => 
                        op.id !== this.pendingUndoOperation.id
                    );
                    this.updateAvailableCategories();
                    this.showToast(result.message, 'success');
                } else {
                    const errorData = await response.json();
                    this.showToast(`Failed to undo upload: ${errorData.error}`, 'error');
                }
            } catch (error) {
                console.error('Failed to undo upload:', error);
                this.showToast(`Failed to undo upload: ${error.message}`, 'error');
            } finally {
                this.showUndoDialog = false;
                this.pendingUndoOperation = null;
            }
        },
        
        formatUploadDate(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            return date.toLocaleDateString() + ' at ' + date.toLocaleTimeString();
        },
        
        getSubscriptionStatus(contact, channel) {
            // Ensure contact has communicationPreferences
            if (!contact.communicationPreferences) {
                return { subscribed: true, unsubscribedAt: null };
            }
            
            const prefs = contact.communicationPreferences[channel];
            if (!prefs) {
                return { subscribed: true, unsubscribedAt: null };
            }
            
            return {
                subscribed: prefs.subscribed !== false,
                unsubscribedAt: prefs.unsubscribedAt || null,
                unsubscribeReason: prefs.unsubscribeReason || null
            };
        },
        
        // Format transformation system - supports multiple scenarios
        // This allows different Excel format patterns to be detected and transformed
        // Each scenario should:
        // 1. Have a detect function that checks if the format matches
        // 2. Have a transform function that parses and adds standard fields (firstName, lastName, email, phone, address, city, province, postalCode)
        // 3. Preserve original data while adding/updating standard fields
        applyFormatTransformations(data, headers) {
            // Try each format detector and apply transformations
            // Multiple formats can be detected and transformations can be chained
            
            let updatedHeaders = [...headers];
            const detectedColumns = {};
            
            const addStandardHeaders = () => {
                const standardFields = ['firstName', 'lastName', 'email', 'phone', 'address', 'city', 'province', 'postalCode'];
                standardFields.forEach(field => {
                    if (!updatedHeaders.includes(field)) {
                        updatedHeaders.push(field);
                    }
                });
            };
            
            // Scenario 1: CPC Membership format
            if (this.detectCPCFormat(headers, data)) {
                const result = this.transformCPCFormat(data, headers);
                data = result.data;
                if (result.headers && Array.isArray(result.headers)) {
                    updatedHeaders = result.headers;
                }
                addStandardHeaders();
                if (result._detectedColumns) {
                    Object.assign(detectedColumns, result._detectedColumns);
                }
            }
            
            // Scenario 2: Res./Post. Address format (with "Last, First Middle" names)
            if (this.detectResPostFormat(headers, data)) {
                const result = this.transformResPostFormat(data, headers);
                data = result.data;
                if (result.headers && Array.isArray(result.headers)) {
                    updatedHeaders = result.headers;
                }
                addStandardHeaders();
                if (result._detectedColumns) {
                    Object.assign(detectedColumns, result._detectedColumns);
                }
            }
            
            return { data, headers: updatedHeaders, _detectedColumns: detectedColumns };
        },
        
        // CPC Membership format detection and parsing
        // This format is very specific: "Last Name" column with "Mr. Name - CPC Membership" 
        // and "Member Information" column with "Res. Add:" and "E-mail Address:"
        detectCPCFormat(headers, data) {
            // Must have exact column headers (case-insensitive but must match pattern)
            const nameHeader = this.getCPCHeader(headers, 'name');
            const memberInfoHeader = this.getCPCHeader(headers, 'info');
            
            // Must have both exact headers
            if (!nameHeader || !memberInfoHeader) {
                return false;
            }
            
            // Check sample data to confirm CPC format - must have BOTH patterns
            const sampleRows = data.slice(0, Math.min(5, data.length)).filter(row => {
                const lastNameValue = String(row[nameHeader] || '').trim();
                const memberInfo = String(row[memberInfoHeader] || '').trim();
                return lastNameValue.length > 0 || memberInfo.length > 0;
            });
            
            if (sampleRows.length === 0) {
                return false;
            }
            
            // Must have CPC name pattern (with "- CPC Membership" suffix)
            const hasCPCNamePattern = sampleRows.some(row => {
                const lastNameValue = String(row[nameHeader] || '').trim();
                return lastNameValue.includes('- CPC Membership');
            });
            
            // Must have CPC member info pattern (with "Res. Add:" and "E-mail Address:")
            const hasCPCMemberInfo = sampleRows.some(row => {
                const memberInfo = String(row[memberInfoHeader] || '').trim();
                return memberInfo.includes('Res. Add:') && 
                       memberInfo.includes('E-mail Address:');
            });
            
            // Both patterns must be present to be CPC format
            return hasCPCNamePattern && hasCPCMemberInfo;
        },
        
        transformCPCFormat(data, headers) {
            // Use exact header matching (same as detection)
            const nameHeader = this.getCPCHeader(headers, 'name');
            const memberInfoHeader = this.getCPCHeader(headers, 'info');
            
            if (!nameHeader || !memberInfoHeader) {
                return { data, headers };
            }
            
            const parsedData = [];
            
            for (const row of data) {
                const lastNameValue = String(row[nameHeader] || '').trim();
                const memberInfo = String(row[memberInfoHeader] || '').trim();
                
                if (!lastNameValue && !memberInfo) {
                    continue; // Skip empty rows
                }
                
                // Parse name from "Last Name" column
                const nameParts = this.parseCPCName(lastNameValue);
                
                // Parse member information
                const memberInfoParts = this.parseCPCMemberInfo(memberInfo);
                
                // Create new row with parsed data
                // Preserve all original fields and add/update standard contact fields
                const parsedRow = {
                    ...row, // Keep all original data
                    // Add/update standard fields if not already present or if parsed values are better
                    firstName: nameParts.firstName || row.firstName || '',
                    lastName: nameParts.lastName || row.lastName || '',
                    email: memberInfoParts.email || row.email || '',
                    phone: memberInfoParts.phone || row.phone || '',
                    address: memberInfoParts.address || row.address || '',
                    city: memberInfoParts.city || row.city || '',
                    province: memberInfoParts.province || row.province || '',
                    postalCode: memberInfoParts.postalCode || row.postalCode || ''
                };
                
                parsedData.push(parsedRow);
            }
            
            return { data: parsedData, headers };
        },
        
        // Res./Post. Address format detection and parsing
        // Format: First column has "Last, First Middle" names, second column has "Res.:" and "Post.:" addresses
        detectResPostFormat(headers, data) {
            // Don't detect if CPC format was already detected
            if (this.detectCPCFormat(headers, data)) {
                return false;
            }
            
            // Check sample rows for "Res.:" and "Post.:" patterns
            const sampleRows = data.slice(0, Math.min(5, data.length)).filter(row => {
                return Object.values(row).some(val => val && String(val).trim().length > 0);
            });
            
            if (sampleRows.length === 0) {
                return false;
            }
            
            // Check if any column contains "Res.:" or "Post.:" patterns
            let hasResPostPattern = false;
            let hasNamePattern = false;
            
            for (const row of sampleRows) {
                for (const [header, value] of Object.entries(row)) {
                    const strValue = String(value || '').trim();
                    
                    // Check for "Res.:" or "Post.:" patterns
                    if (/Res\.:\s*|Post\.:\s*/i.test(strValue)) {
                        hasResPostPattern = true;
                    }
                    
                    // Check for "Last, First Middle" name pattern
                    if (/^[A-Z][a-z]+,\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?/.test(strValue)) {
                        hasNamePattern = true;
                    }
                }
            }
            
            // Must have both patterns to be this format
            return hasResPostPattern && hasNamePattern;
        },
        
        transformResPostFormat(data, headers) {
            // For this format, we just need to identify columns and let the backend parse them
            // The backend has robust parseAddress() that handles "Res.:" and "Post.:" formats
            // So we just need to extract names and mark address/phone columns for mapping
            
            const parsedData = [];
            
            // Find columns that contain names, addresses, and phones
            let nameColumn = null;
            let addressColumn = null;
            let phoneColumn = null;
            
            // Check first few rows to identify columns
            const sampleRows = data.slice(0, Math.min(5, data.length)).filter(row => {
                return Object.values(row).some(val => val && String(val).trim().length > 0);
            });
            
            // Track which columns have which patterns
            const columnScores = {};
            headers.forEach(header => {
                columnScores[header] = { name: 0, address: 0, phone: 0 };
            });
            
            for (const header of headers) {
                for (const row of sampleRows) {
                    const value = String(row[header] || '').trim();
                    if (!value) continue;
                    
                    // Check for name pattern "Last, First Middle"
                    if (/^[A-Z][a-z]+,\s+[A-Z][a-z]+/.test(value)) {
                        columnScores[header].name++;
                    }
                    
                    // Check for address pattern "Res.:" or "Post.:"
                    if (/Res\.:\s*|Post\.:\s*|Res\.\s+Add\.?:|Mailing\s+Add\.?:/i.test(value)) {
                        columnScores[header].address += 2; // Strong match
                    }
                    
                    // Also check for address-like content (postal codes, provinces, street names)
                    if (/\b(AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT)\b/i.test(value) || 
                        /\b[A-Z]\d[A-Z]\s?\d[A-Z]\d\b/i.test(value) ||
                        /\b(Rd|Road|Ave|Avenue|Dr|Drive|St|Street|Cres|Crescent|Blvd|Boulevard|Hwy|Highway)\b/i.test(value)) {
                        columnScores[header].address += 0.5; // Partial match
                    }
                    
                    // Check for phone pattern
                    if (/\(\d{3}\)\s*\d{3}[.-]\d{4}|\(\d{3}\)\s*\d{3}\s+\d{4}/.test(value)) {
                        columnScores[header].phone++;
                    }
                }
            }
            
            // Find best matches (columns with highest scores)
            let maxNameScore = 0;
            let maxAddressScore = 0;
            let maxPhoneScore = 0;
            
            for (const header of headers) {
                const scores = columnScores[header];
                if (scores.name > maxNameScore) {
                    maxNameScore = scores.name;
                    nameColumn = header;
                }
                if (scores.address > maxAddressScore) {
                    maxAddressScore = scores.address;
                    addressColumn = header;
                }
                if (scores.phone > maxPhoneScore) {
                    maxPhoneScore = scores.phone;
                    phoneColumn = header;
                }
            }
            
            // Fallback: if no address column found, try all columns
            if (!addressColumn) {
                // Try each column to find one with address-like content
                for (const header of headers) {
                    if (header === nameColumn) continue; // Skip name column
                    
                    let addressScore = 0;
                    for (const row of sampleRows) {
                        const value = String(row[header] || '').trim();
                        if (!value) continue;
                        
                        // Strong indicators
                        if (/Res\.:\s*|Post\.:\s*/i.test(value)) {
                            addressScore += 3;
                        }
                        // Medium indicators
                        if (/\b(AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT)\b/i.test(value)) {
                            addressScore += 2;
                        }
                        if (/\b[A-Z]\d[A-Z]\s?\d[A-Z]\d\b/i.test(value)) {
                            addressScore += 2; // Postal code
                        }
                        // Weak indicators
                        if (value.length > 30 && /\b(Rd|Road|Ave|Avenue|Dr|Drive|St|Street|Cres|Crescent|Blvd|Boulevard|Hwy|Highway)\b/i.test(value)) {
                            addressScore += 1;
                        }
                    }
                    
                    if (addressScore >= 2) {
                        addressColumn = header;
                        break;
                    }
                }
            }
            
            // Last resort: if still no address column and we have at least 2 columns, use the second one
            if (!addressColumn && headers.length >= 2 && nameColumn) {
                const secondColumn = headers.find(h => h !== nameColumn);
                if (secondColumn) {
                    addressColumn = secondColumn; // Assume second column is address
                }
            }
            
            // Parse names and add to rows (for immediate use)
            if (nameColumn) {
                data.forEach(row => {
                    if (row[nameColumn]) {
                        const nameValue = String(row[nameColumn] || '').trim();
                        if (nameValue) {
                            const nameParts = this.parseResPostName(nameValue);
                            if (nameParts.firstName) row.firstName = nameParts.firstName;
                            if (nameParts.lastName) row.lastName = nameParts.lastName;
                        }
                    }
                });
            }
            
            // Return data with detected columns for mapping
            // The column mapping will use these to map addressColumn -> 'address'
            // and the backend's parseAddress() will handle the parsing
            return { 
                data: data, 
                headers: headers,
                _detectedColumns: {
                    nameColumn: nameColumn,
                    addressColumn: addressColumn,
                    phoneColumn: phoneColumn
                }
            };
        },
        
        parseResPostName(nameString) {
            if (!nameString) {
                return { firstName: '', lastName: '' };
            }
            
            // Format is "Last, First Middle" or "Last, First"
            const trimmed = nameString.trim();
            
            if (trimmed.includes(',')) {
                const parts = trimmed.split(',').map(p => p.trim()).filter(p => p);
                if (parts.length >= 2) {
                    return {
                        lastName: parts[0],
                        firstName: parts.slice(1).join(' ')
                    };
                }
            }
            
            // Fallback: split by spaces
            const spaceParts = trimmed.split(/\s+/).filter(p => p);
            if (spaceParts.length === 0) {
                return { firstName: '', lastName: '' };
            } else if (spaceParts.length === 1) {
                return { firstName: '', lastName: spaceParts[0] };
            } else {
                return {
                    firstName: spaceParts.slice(0, -1).join(' '),
                    lastName: spaceParts[spaceParts.length - 1]
                };
            }
        },
        
        parseResPostAddress(addressString) {
            const result = {
                address: '',
                city: '',
                province: '',
                postalCode: ''
            };
            
            if (!addressString) {
                return result;
            }
            
            // Normalize newlines
            const normalized = addressString.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            
            // Extract postal code first
            const postalCodeMatch = normalized.match(/\b([A-Z]\d[A-Z]\s?\d[A-Z]\d)\b/i);
            if (postalCodeMatch) {
                let postalCode = postalCodeMatch[1].toUpperCase();
                if (postalCode.length === 6) {
                    postalCode = postalCode.substring(0, 3) + ' ' + postalCode.substring(3);
                }
                result.postalCode = postalCode;
            }
            
            // Prefer "Post.:" over "Res.:" for mailing address
            let addressToParse = '';
            const postMatch = normalized.match(/Post\.:\s*([\s\S]+?)(?:\s*$|"|'|\s*Res\.:)/i);
            const resMatch = !postMatch ? normalized.match(/Res\.:\s*([\s\S]+?)(?:\s*Post\.:|$|"|')/i) : null;
            
            if (postMatch) {
                addressToParse = postMatch[1].trim();
            } else if (resMatch) {
                addressToParse = resMatch[1].trim();
            } else {
                // No pattern found, use the whole string
                addressToParse = normalized.trim();
            }
            
            // Remove postal code from address string
            let addressWithoutPostal = addressToParse.replace(/\b[A-Z]\d[A-Z]\s?\d[A-Z]\d\b/i, '').trim();
            
            // Extract province (AB, BC, etc.)
            const provinceMatch = addressWithoutPostal.match(/\b(AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT)\b/i);
            if (provinceMatch) {
                result.province = provinceMatch[1].toUpperCase();
                addressWithoutPostal = addressWithoutPostal.replace(/\b(AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT)\b/i, '').trim();
            }
            
            // Known Canadian cities (multi-word)
            const knownCities = [
                'Spruce Grove', 'Stony Plain', 'Yellowhead County', 'Parkland County', 
                'Lac Ste. Anne County', 'Brazeau County', 'Seba Beach', 'Evansburg',
                'Wildwood', 'Fallis', 'Wabamun', 'Breton', 'Mayerthorpe', 'Duffield',
                'Calgary', 'Drayton Valley', 'Rocky Rapids', 'Lodgepole', 'Lindale',
                'Carnwood', 'Onoway', 'Tomahawk', 'Acheson', 'Carvel', 'Spring Lake'
            ];
            
            // Try to find known city
            let cityFound = null;
            let cityStartIndex = -1;
            
            for (const city of knownCities) {
                const cityRegex = new RegExp(city.replace(/\./g, '\\.'), 'i');
                const match = addressWithoutPostal.match(cityRegex);
                if (match) {
                    cityFound = city;
                    cityStartIndex = match.index;
                    break;
                }
            }
            
            // Street suffixes
            const streetSuffixes = ['Rd', 'Road', 'Ave', 'Avenue', 'Dr', 'Drive', 'St', 'Street', 
                                    'Cres', 'Crescent', 'Crt', 'Court', 'Pl', 'Place', 'Way', 
                                    'Blvd', 'Boulevard', 'Hwy', 'Highway', 'Ln', 'Lane', 'Ct', 'Close',
                                    'Bay', 'Pt', 'Point', 'Gate', 'Cove', 'Trail', 'Wynd', 'Green',
                                    'Fairway', 'Landng', 'Bend', 'Close'];
            
            if (cityFound && cityStartIndex >= 0) {
                // Extract city
                result.city = cityFound;
                // Everything before the city is the street address
                result.address = addressWithoutPostal.substring(0, cityStartIndex).trim();
            } else {
                // Fallback: Look for street suffix to identify where street ends
                const words = addressWithoutPostal.split(/\s+/);
                let foundStreetSuffix = false;
                let cityWords = [];
                
                for (let i = words.length - 1; i >= 0; i--) {
                    const word = words[i];
                    const wordUpper = word.toUpperCase();
                    
                    // Check if this is a street suffix
                    if (streetSuffixes.some(suffix => wordUpper === suffix.toUpperCase())) {
                        foundStreetSuffix = true;
                        // Everything from here to the end is likely street address
                        result.address = words.slice(0, i + 1).join(' ').trim();
                        if (cityWords.length > 0) {
                            result.city = cityWords.reverse().join(' ');
                        }
                        break;
                    }
                    
                    // Check if word is capitalized (likely part of city name)
                    if (/^[A-Z][a-z]+/.test(word) || /^[A-Z]+$/.test(word)) {
                        cityWords.unshift(word);
                    } else {
                        if (cityWords.length > 0) {
                            break;
                        }
                    }
                }
                
                // If we didn't find a street suffix, use the last 1-2 capitalized words as city
                if (!foundStreetSuffix) {
                    if (cityWords.length > 0) {
                        const cityWordCount = Math.min(2, cityWords.length);
                        result.city = cityWords.slice(-cityWordCount).join(' ');
                        result.address = words.slice(0, words.length - cityWordCount).join(' ').trim();
                    } else {
                        result.address = addressWithoutPostal;
                    }
                }
            }
            
            return result;
        },
        
        parseCPCName(nameString) {
            if (!nameString) {
                return { firstName: '', lastName: '' };
            }
            
            // Remove "- CPC Membership" suffix
            let cleanName = nameString.replace(/\s*-\s*CPC\s+Membership\s*$/i, '').trim();
            
            // Remove title (Mr., Mrs., Ms., Miss)
            const titleMatch = cleanName.match(/^(Mr\.|Mrs\.|Ms\.|Miss)\s+/i);
            if (titleMatch) {
                cleanName = cleanName.substring(titleMatch[0].length).trim();
            }
            
            // Handle names in parentheses like "Kristine (Kris) Alex"
            const parenMatch = cleanName.match(/^([A-Z][a-z]+)\s*\([^)]+\)\s+(.+)$/);
            if (parenMatch) {
                return {
                    firstName: parenMatch[1],
                    lastName: parenMatch[2].trim()
                };
            }
            
            // Split by spaces - typically "FirstName LastName"
            const parts = cleanName.split(/\s+/).filter(p => p.trim());
            
            if (parts.length === 0) {
                return { firstName: '', lastName: '' };
            } else if (parts.length === 1) {
                // Only one name - assume it's last name
                return { firstName: '', lastName: parts[0] };
            } else {
                // First part is first name, rest is last name
                const firstName = parts[0];
                const lastName = parts.slice(1).join(' ');
                return { firstName, lastName };
            }
        },
        
        parseCPCMemberInfo(memberInfo) {
            const result = {
                email: '',
                phone: '',
                address: '',
                city: '',
                province: '',
                postalCode: ''
            };
            
            if (!memberInfo) {
                return result;
            }
            
            // Split by newlines to parse different sections
            const lines = memberInfo.split(/\n/).map(l => l.trim()).filter(l => l);
            
            let currentAddress = '';
            const phones = [];
            const phoneTypes = [];
            
            for (const line of lines) {
                // Extract email
                const emailMatch = line.match(/E-mail\s+Address:\s*(.+)/i);
                if (emailMatch) {
                    result.email = emailMatch[1].trim();
                    continue;
                }
                
                // Extract residential address
                const resAddrMatch = line.match(/Res\.\s+Add:\s*(.+)/i);
                if (resAddrMatch) {
                    currentAddress = resAddrMatch[1].trim();
                    continue;
                }
                
                // Extract mailing address (we'll use residential as primary)
                const mailAddrMatch = line.match(/Mailing\s+Add:\s*(.+)/i);
                if (mailAddrMatch) {
                    // Store mailing address if no residential address
                    if (!currentAddress) {
                        currentAddress = mailAddrMatch[1].trim();
                    }
                    continue;
                }
                
                // Extract phone numbers with type detection
                const phoneMatch = line.match(/(Home\s+Cell\s+Phone|Home\s+Phone|Business\s+Phone|Unknown\s+Cell\s+Phone|Unknown\s+Phone|Cell\s+Phone|Phone):\s*\(?([0-9]{3})\)?\s*[-.\s]?\s*([0-9]{3})[-.\s]?([0-9]{4})/i);
                if (phoneMatch) {
                    const phoneType = phoneMatch[1].trim();
                    const phoneNumber = `(${phoneMatch[2]}) ${phoneMatch[3]}-${phoneMatch[4]}`;
                    phones.push(phoneNumber);
                    phoneTypes.push(phoneType);
                    continue;
                }
            }
            
            // Parse address to extract components
            if (currentAddress) {
                const addressParts = this.parseCPCAddress(currentAddress);
                result.address = addressParts.address;
                result.city = addressParts.city;
                result.province = addressParts.province;
                result.postalCode = addressParts.postalCode;
            }
            
            // Prioritize phone numbers: Home Cell Phone > Home Phone > Business Phone > others
            if (phones.length > 0) {
                // Priority order
                const priority = ['Home Cell Phone', 'Home Phone', 'Business Phone', 'Cell Phone', 'Phone'];
                let selectedPhone = phones[0];
                
                for (let i = 0; i < priority.length; i++) {
                    const priorityType = priority[i];
                    const index = phoneTypes.findIndex(type => 
                        type.toLowerCase().includes(priorityType.toLowerCase())
                    );
                    if (index !== -1) {
                        selectedPhone = phones[index];
                        break;
                    }
                }
                
                result.phone = selectedPhone;
            }
            
            return result;
        },
        
        parseCPCAddress(addressString) {
            const result = {
                address: '',
                city: '',
                province: '',
                postalCode: ''
            };
            
            if (!addressString) {
                return result;
            }
            
            // Canadian postal code pattern: A1A 1A1 or A1A1A1
            const postalCodeMatch = addressString.match(/\b([A-Z]\d[A-Z]\s?\d[A-Z]\d)\b/i);
            if (postalCodeMatch) {
                let postalCode = postalCodeMatch[1].toUpperCase();
                // Format as A1A 1A1
                if (postalCode.length === 6) {
                    postalCode = postalCode.substring(0, 3) + ' ' + postalCode.substring(3);
                }
                result.postalCode = postalCode;
            }
            
            // Extract province (2-letter codes)
            const provinceMatch = addressString.match(/\b(AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT)\b/i);
            if (provinceMatch) {
                result.province = provinceMatch[1].toUpperCase();
            }
            
            // Remove postal code and province from string for easier parsing
            let addressWithoutPostal = addressString;
            if (result.postalCode) {
                addressWithoutPostal = addressWithoutPostal.replace(result.postalCode, '').trim();
            }
            if (result.province) {
                addressWithoutPostal = addressWithoutPostal.replace(new RegExp(`\\b${result.province}\\b`, 'i'), '').trim();
            }
            
            // Common Canadian street suffixes
            const streetSuffixes = ['Rd', 'Road', 'Ave', 'Avenue', 'St', 'Street', 'Dr', 'Drive', 'Cres', 'Crescent', 
                                   'Ct', 'Court', 'Crt', 'Blvd', 'Boulevard', 'Way', 'Gate', 'Hwy', 'Highway', 
                                   'Ln', 'Lane', 'Pl', 'Place', 'Tr', 'Trail', 'Cir', 'Circle', 'Pkwy', 'Parkway'];
            
            // Common Canadian city patterns (multi-word cities)
            const cityPatterns = [
                'Spruce Grove', 'Stony Plain', 'Yellowhead County', 'Lac Ste. Anne County', 
                'Parkland County', 'St. Albert', 'Fort McMurray', 'Grande Prairie', 'Red Deer',
                'Medicine Hat', 'Lethbridge', 'Calgary', 'Edmonton', 'Fort Saskatchewan'
            ];
            
            // Try to match known city patterns first
            let cityFound = '';
            let cityStartIndex = -1;
            
            for (const cityPattern of cityPatterns) {
                const patternRegex = new RegExp(`\\b${cityPattern.replace(/\./g, '\\.')}\\b`, 'i');
                const match = addressWithoutPostal.match(patternRegex);
                if (match) {
                    cityFound = cityPattern;
                    cityStartIndex = match.index;
                    break;
                }
            }
            
            if (cityFound) {
                // Extract city
                result.city = cityFound;
                // Everything before the city is the street address
                result.address = addressWithoutPostal.substring(0, cityStartIndex).trim();
            } else {
                // Fallback: Look for capitalized words at the end that might be city
                // Split into words
                const words = addressWithoutPostal.split(/\s+/);
                
                // Work backwards to find city (last 1-3 capitalized words)
                let cityWords = [];
                let foundStreetSuffix = false;
                
                for (let i = words.length - 1; i >= 0; i--) {
                    const word = words[i];
                    const wordUpper = word.toUpperCase();
                    
                    // Check if this is a street suffix
                    if (streetSuffixes.some(suffix => wordUpper === suffix.toUpperCase())) {
                        foundStreetSuffix = true;
                        // Everything from here to the end is likely street address
                        result.address = words.slice(0, i + 1).join(' ').trim();
                        if (cityWords.length > 0) {
                            result.city = cityWords.reverse().join(' ');
                        }
                        break;
                    }
                    
                    // Check if word is capitalized (likely part of city name)
                    if (/^[A-Z][a-z]+/.test(word) || /^[A-Z]+$/.test(word)) {
                        cityWords.unshift(word);
                    } else {
                        // If we hit a non-capitalized word and we have city words, stop
                        if (cityWords.length > 0) {
                            break;
                        }
                    }
                }
                
                // If we didn't find a street suffix, use the last 1-2 capitalized words as city
                if (!foundStreetSuffix) {
                    if (cityWords.length > 0) {
                        // Take last 1-2 words as city (most Canadian cities are 1-2 words)
                        const cityWordCount = Math.min(2, cityWords.length);
                        result.city = cityWords.slice(-cityWordCount).join(' ');
                        result.address = words.slice(0, words.length - cityWordCount).join(' ').trim();
                    } else {
                        // Can't determine, put everything as address
                        result.address = addressWithoutPostal;
                    }
                }
            }
            
            return result;
        },
        
        // Smart Import methods
        handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                this.smartImportFile = file;
                this.isDragging = false;
            }
        },
        
        handleFileDrop(event) {
            event.preventDefault();
            this.isDragging = false;
            const file = event.dataTransfer.files[0];
            if (file && (file.name.endsWith('.xlsx') || file.name.endsWith('.xls') || file.name.endsWith('.csv'))) {
                this.smartImportFile = file;
            } else {
                this.showToast('Please upload a valid file (.xlsx, .xls, or .csv)', 'error');
            }
        },
        
        // Parse TSV with proper handling of quoted fields containing newlines
        parseTSV(tsvText) {
            const rows = [];
            let currentRow = [];
            let currentField = '';
            let inQuotes = false;
            let fieldStartedWithQuote = false;
            let i = 0;
            
            while (i < tsvText.length) {
                const char = tsvText[i];
                const nextChar = tsvText[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        // Escaped quote (double quote) - add one quote to field
                        currentField += '"';
                        i += 2;
                        continue;
                    } else {
                        // Toggle quote state
                        if (!inQuotes && currentField.length === 0) {
                            // Field starts with quote
                            fieldStartedWithQuote = true;
                        }
                        inQuotes = !inQuotes;
                        i++;
                        continue;
                    }
                }
                
                if (char === '\t' && !inQuotes) {
                    // End of field
                    currentRow.push(currentField);
                    currentField = '';
                    fieldStartedWithQuote = false;
                    i++;
                    continue;
                }
                
                if (char === '\n' && !inQuotes) {
                    // End of row
                    currentRow.push(currentField);
                    if (currentRow.some(field => field.length > 0)) {
                        rows.push(currentRow);
                    }
                    currentRow = [];
                    currentField = '';
                    fieldStartedWithQuote = false;
                    i++;
                    continue;
                }
                
                // Regular character (including newlines inside quoted fields)
                currentField += char;
                i++;
            }
            
            // Handle last field/row
            if (currentField.trim() || currentRow.length > 0) {
                currentRow.push(currentField);
                if (currentRow.some(field => field.length > 0)) {
                    rows.push(currentRow);
                }
            }
            
            return rows;
        },
        
        async parseSmartImportPaste() {
            if (!this.smartImportPasteData.trim()) {
                this.showToast('Please paste some data first', 'error');
                return;
            }
            
            this.parsingFile = true;
            try {
                // Parse TSV with proper handling of quoted fields
                const parsedRows = this.parseTSV(this.smartImportPasteData.trim());
                
                if (parsedRows.length < 2) {
                    throw new Error('Please paste at least a header row and one data row');
                }
                
                const headers = parsedRows[0].map(h => h.trim());
                let data = [];
                let previousRowData = null;
                
                for (let i = 1; i < parsedRows.length; i++) {
                    const values = parsedRows[i];
                    const rowData = {};
                    headers.forEach((header, index) => {
                        rowData[header] = values[index]?.trim() || '';
                    });
                    
                    // Only process row if it has at least one non-empty value
                    if (Object.values(rowData).some(val => val && val.trim() !== '')) {
                        const rowValues = Object.values(rowData).map(v => String(v || '').trim()).filter(v => v);
                        const rowString = rowValues.join(' ').toLowerCase();
                        
                        // Check if this is a "Post.:" continuation row that should be merged with previous
                        const isPostContinuation = rowValues.some(v => /^post\.:/i.test(v)) && 
                                                   (!rowValues.some(v => /^[A-Z][a-z]+,\s+[A-Z]/i.test(v))); // No name pattern
                        
                        if (isPostContinuation && previousRowData) {
                            // Merge "Post.:" address with previous row's address field
                            for (const [header, value] of Object.entries(rowData)) {
                                if (value && /^post\.:/i.test(value)) {
                                    // Find address-related column in previous row
                                    const addressHeaders = ['address', 'addresses', 'fulladdress', 'residential', 'postal'];
                                    let merged = false;
                                    for (const addrHeader of addressHeaders) {
                                        const matchingHeader = Object.keys(previousRowData).find(h => 
                                            h.toLowerCase().includes(addrHeader));
                                        if (matchingHeader) {
                                            const existingAddr = previousRowData[matchingHeader] || '';
                                            previousRowData[matchingHeader] = existingAddr ? 
                                                `${existingAddr}\n${value}` : value;
                                            merged = true;
                                            break;
                                        }
                                    }
                                    // If no address column found, use the first column that has data
                                    if (!merged) {
                                        const firstDataCol = Object.keys(previousRowData).find(h => 
                                            previousRowData[h] && previousRowData[h].trim());
                                        if (firstDataCol) {
                                            previousRowData[firstDataCol] = `${previousRowData[firstDataCol]}\n${value}`;
                                        }
                                    }
                                }
                            }
                            // Update the last row in data array with merged address
                            if (data.length > 0) {
                                data[data.length - 1] = { ...previousRowData };
                            }
                            // Don't add this row as a separate contact, it's merged
                            continue;
                        }
                        
                        // Skip rows that are clearly not contact data
                        // Only treat as a "poll row" if it's ONLY a poll identifier with no real contact data
                        // (e.g., a row that just contains "Poll 10" and nothing else meaningful)
                        const isPollRow = /^poll\s*\d+$/i.test(rowString.trim()) || 
                                          (rowValues.length <= 2 && /^poll\s*\d+$/i.test(rowValues[0] || ''));
                        const isNumberOnlyRow = /^\d+\s+[a-z]+$/i.test(rowString.trim()) || /^\d+$/i.test(rowString.trim());
                        const firstValue = rowValues[0] || '';
                        const isLocationIdentifier = /^\d+\s+[A-Z][a-z]+$/.test(firstValue) && rowValues.length <= 2;
                        
                        if (!isPollRow && !isNumberOnlyRow && !isLocationIdentifier) {
                            // Save this as the previous row for potential merging
                            previousRowData = { ...rowData };
                            data.push(rowData);
                        }
                    }
                }
                
                if (data.length === 0) {
                    throw new Error('No valid data rows found');
                }
                
                // Apply format-specific transformations (multiple scenarios can be detected)
                const transformationResult = this.applyFormatTransformations(data, headers);
                data = transformationResult.data;
                const updatedHeaders = transformationResult.headers || headers;
                const detectedColumns = transformationResult._detectedColumns || {};
                
                // Get sample values for column detection
                const columnSamples = {};
                updatedHeaders.forEach(header => {
                    columnSamples[header] = data
                        .slice(0, 5)
                        .map(row => row[header])
                        .filter(val => val && val.toString().trim() !== '')
                        .slice(0, 3);
                });
                
                // Auto-detect column types (we'll need to import the detectColumnType function logic)
                // For now, use simple detection based on header names
                const columnMapping = {};
                
                // First, map standard field names directly (these come from format transformations)
                // Also check if these fields exist in the data rows (even if not in headers)
                const standardFieldNames = ['firstName', 'lastName', 'email', 'phone', 'address', 'city', 'province', 'postalCode', 'category'];
                standardFieldNames.forEach(fieldName => {
                    if (updatedHeaders.includes(fieldName)) {
                        columnMapping[fieldName] = fieldName;
                    } else {
                        // Check if data rows have this field (from transformations)
                        const hasFieldInData = data.length > 0 && data.some(row => 
                            row.hasOwnProperty(fieldName) && row[fieldName] && String(row[fieldName]).trim() !== ''
                        );
                        if (hasFieldInData) {
                            // Field exists in data but not in headers - add it to headers and map it
                            if (!updatedHeaders.includes(fieldName)) {
                                updatedHeaders.push(fieldName);
                            }
                            columnMapping[fieldName] = fieldName;
                        }
                    }
                });
                
                // Use detected columns from format transformations (e.g., Res./Post. format)
                // This MUST happen before other mapping logic
                // Verify the detected columns actually exist in headers before mapping
                if (detectedColumns.addressColumn && updatedHeaders.includes(detectedColumns.addressColumn)) {
                    // Map address column to 'fullAddress' - backend will parse it using parseAddress()
                    // This allows the backend to extract city, province, and postal code from "Res.:" format
                    columnMapping[detectedColumns.addressColumn] = 'fullAddress';
                }
                if (detectedColumns.phoneColumn && updatedHeaders.includes(detectedColumns.phoneColumn)) {
                    columnMapping[detectedColumns.phoneColumn] = 'phone';
                }
                if (detectedColumns.nameColumn && updatedHeaders.includes(detectedColumns.nameColumn)) {
                    // Map name column to fullName - backend will split it using splitFullName()
                    // But we've already extracted firstName/lastName, so check if those exist first
                    const hasExtractedNames = data.length > 0 && data.some(row => 
                        (row.firstName && row.firstName.trim()) || (row.lastName && row.lastName.trim())
                    );
                    if (!hasExtractedNames) {
                        columnMapping[detectedColumns.nameColumn] = 'fullName';
                    }
                }
                
                // Then, map other headers that might contain similar data
                updatedHeaders.forEach(header => {
                    // Skip if already mapped as a standard field
                    if (columnMapping[header]) {
                        return;
                    }
                    
                    // Skip if this is a detected column (already handled above)
                    if (header === detectedColumns.addressColumn || 
                        header === detectedColumns.phoneColumn || 
                        header === detectedColumns.nameColumn) {
                        return;
                    }
                    
                    const headerLower = header.toLowerCase().trim();
                    const headerNormalized = headerLower.replace(/[_\s-]/g, '');
                    
                    // Don't map original columns if we already have the standard field
                    // (e.g., don't map "Last Name" to lastName if we already have a "lastName" column)
                    if (headerNormalized.includes('email')) {
                        if (!columnMapping['email']) {
                            columnMapping[header] = 'email';
                        }
                    } else if (headerNormalized.includes('phone') || headerNormalized.includes('tel')) {
                        if (!columnMapping['phone']) {
                            columnMapping[header] = 'phone';
                        }
                    } else if (headerNormalized.includes('firstname') || headerNormalized === 'first' || headerNormalized === 'fname') {
                        if (!columnMapping['firstName']) {
                            columnMapping[header] = 'firstName';
                        }
                    } else if (headerNormalized.includes('lastname') || headerNormalized === 'last' || headerNormalized === 'lname' || headerNormalized === 'surname') {
                        if (!columnMapping['lastName']) {
                            columnMapping[header] = 'lastName';
                        }
                    } else if (headerNormalized.includes('fullname') || (headerNormalized === 'name' && !headerNormalized.includes('first') && !headerNormalized.includes('last'))) {
                        // ALWAYS map "Name" column to fullName - it's the most common column name for contacts
                        // Check if this column contains "Last, First" format names
                        const columnSamples = data.slice(0, 20).map(row => String(row[header] || '').trim()).filter(v => v && v !== '-');
                        const hasCommaNames = columnSamples.some(sample => 
                            /^[A-Z][a-z]+,\s+[A-Z]/.test(sample)  // "Last, First" format
                        );
                        const hasNameLikeData = columnSamples.some(sample => 
                            /^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+/.test(sample) ||  // "First Last" format
                            /^[A-Z][a-z]+,\s+[A-Z]/.test(sample)  // "Last, First" format
                        );
                        
                        // ALWAYS map "Name" column to fullName - prioritize this over other mappings
                        if (headerNormalized === 'name' || hasCommaNames || hasNameLikeData) {
                            // Force map to fullName, even if something else was mapped
                            columnMapping[header] = 'fullName';
                        } else if (!columnMapping['fullName']) {
                            // Map to 'fullName' so backend can parse names
                            columnMapping[header] = 'fullName';
                        }
                    } else if (headerNormalized.includes('address') && !headerNormalized.includes('city') && !headerNormalized.includes('province') && !headerNormalized.includes('postal')) {
                        // Check if this column contains "Res.:" or "Post.:" patterns - if so, map to 'fullAddress' for parsing
                        const columnSamples = data.slice(0, 5).map(row => String(row[header] || '').trim()).filter(v => v);
                        const hasResPostPattern = columnSamples.some(sample => 
                            /Res\.:\s*|Post\.:\s*|Res\.\s+Add\.?:|Mailing\s+Add\.?:/i.test(sample)
                        );
                        
                        if (hasResPostPattern && !columnMapping['fullAddress']) {
                            // Map to 'fullAddress' so backend can parse city, province, postal code
                            columnMapping[header] = 'fullAddress';
                        } else if (!columnMapping['address'] && !columnMapping['fullAddress']) {
                            columnMapping[header] = 'address';
                        }
                    } else if (headerNormalized === 'city' || headerNormalized === 'town') {
                        if (!columnMapping['city']) {
                            columnMapping[header] = 'city';
                        }
                    } else if (headerNormalized === 'province' || headerNormalized === 'state' || headerNormalized === 'prov') {
                        if (!columnMapping['province']) {
                            columnMapping[header] = 'province';
                        }
                    } else if (headerNormalized.includes('postal') || headerNormalized.includes('zip') || headerNormalized === 'postcode') {
                        if (!columnMapping['postalCode']) {
                            columnMapping[header] = 'postalCode';
                        }
                    } else if (headerNormalized.includes('category') || headerNormalized.includes('cat') || headerNormalized.includes('tag')) {
                        if (!columnMapping['category']) {
                            columnMapping[header] = 'category';
                        }
                    } else if (headerNormalized.includes('poll') || headerNormalized === 'pollnumber' || headerNormalized === 'poll#') {
                        if (!columnMapping['pollNumber']) {
                            columnMapping[header] = 'pollNumber';
                        }
                    }
                });
                
                this.smartImportHeaders = updatedHeaders;
                this.smartImportColumnMapping = columnMapping;
                this.smartImportFileData = data;
                this.smartImportTotalRows = data.length;
                
                // Initialize unmapped columns
                this.smartImportHeaders.forEach(header => {
                    if (!this.smartImportColumnMapping[header]) {
                        this.smartImportColumnMapping[header] = 'unmapped';
                    }
                });
                
                // Automatically generate preview
                await this.previewSmartImport();
            } catch (error) {
                console.error('Parse paste error:', error);
                this.showToast(`Failed to parse pasted data: ${error.message}`, 'error');
            } finally {
                this.parsingFile = false;
            }
        },
        
        // Legacy Import methods
        handleLegacyFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                this.legacyImportFile = file;
                this.legacyIsDragging = false;
            }
        },
        
        handleLegacyFileDrop(event) {
            event.preventDefault();
            this.legacyIsDragging = false;
            const file = event.dataTransfer.files[0];
            if (file && (file.name.endsWith('.xlsx') || file.name.endsWith('.xls') || file.name.endsWith('.csv'))) {
                this.legacyImportFile = file;
            } else {
                this.showToast('Please upload a valid Excel file (.xlsx, .xls, or .csv)', 'error');
            }
        },
        
        async processLegacyFileImport() {
            if (!this.legacyImportFile) {
                this.showToast('Please select a file first', 'error');
                return;
            }
            
            this.processing = true;
            try {
                // Use the smart import parse endpoint to get the data
                const formData = new FormData();
                formData.append('file', this.legacyImportFile);
                
                const parseResponse = await fetch('/api/contacts/smart-import/parse', {
                    method: 'POST',
                    credentials: 'include',
                    body: formData
                });
                
                if (!parseResponse.ok) {
                    const error = await parseResponse.json();
                    throw new Error(error.error || 'Failed to parse file');
                }
                
                const parseResult = await parseResponse.json();
                const fileData = parseResult.fileData;
                
                // Convert to legacy format (tab-separated string)
                if (fileData.length === 0) {
                    throw new Error('File is empty');
                }
                
                // Get headers
                const headers = Object.keys(fileData[0]);
                
                // Convert to tab-separated format
                let tabData = headers.join('\t') + '\n';
                fileData.forEach(row => {
                    const values = headers.map(header => row[header] || '');
                    tabData += values.join('\t') + '\n';
                });
                
                // Set importData and process using existing legacy import
                this.importData = tabData;
                await this.processImport();
            } catch (error) {
                console.error('Legacy file import error:', error);
                this.showToast(`Failed to import file: ${error.message}`, 'error');
            } finally {
                this.processing = false;
            }
        },
        
        async parseSmartImportFile() {
            if (!this.smartImportFile) {
                this.showToast('Please select a file first', 'error');
                return;
            }
            
            this.parsingFile = true;
            try {
                const formData = new FormData();
                formData.append('file', this.smartImportFile);
                
                const response = await fetch('/api/contacts/smart-import/parse', {
                    method: 'POST',
                    credentials: 'include',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    let headers = result.headers;
                    let fileData = result.fileData || result.sampleData; // Use full data if available
                    
                    // Apply format transformations (CPC format, etc.) to file upload data
                    // This ensures messy data formats are parsed correctly
                    const transformationResult = this.applyFormatTransformations(fileData, headers);
                    fileData = transformationResult.data;
                    headers = transformationResult.headers || headers;
                    const detectedColumns = transformationResult._detectedColumns || {};
                    
                    // Update column mapping based on transformations
                    // Map detected columns from transformations
                    if (detectedColumns.addressColumn && headers.includes(detectedColumns.addressColumn)) {
                        // Map address column to 'fullAddress' - backend will parse it using parseAddress()
                        // This allows the backend to extract city, province, and postal code from "Res.:" format
                        result.columnMapping[detectedColumns.addressColumn] = 'fullAddress';
                    }
                    if (detectedColumns.phoneColumn && headers.includes(detectedColumns.phoneColumn)) {
                        result.columnMapping[detectedColumns.phoneColumn] = 'phone';
                    }
                    // ALWAYS map Name column to fullName - don't check if names were extracted
                    // The backend will handle name extraction properly from fullName
                    if (detectedColumns.nameColumn && headers.includes(detectedColumns.nameColumn)) {
                        result.columnMapping[detectedColumns.nameColumn] = 'fullName';
                    }
                    
                    // Also check if there's a "Name" column that wasn't detected by transformations
                    // This ensures we catch the Name column even if transformations didn't detect it
                    headers.forEach(header => {
                        const headerLower = header.toLowerCase().trim();
                        const headerNormalized = headerLower.replace(/[_\s-]/g, '');
                        if ((headerLower === 'name' || headerNormalized === 'name') && !result.columnMapping[header]) {
                            result.columnMapping[header] = 'fullName';
                        }
                    });
                    
                    // Map standard fields that were created by transformations
                    const standardFields = ['firstName', 'lastName', 'email', 'phone', 'address', 'city', 'province', 'postalCode'];
                    standardFields.forEach(fieldName => {
                        if (headers.includes(fieldName) && !result.columnMapping[fieldName]) {
                            result.columnMapping[fieldName] = fieldName;
                        }
                    });
                    
                    this.smartImportHeaders = headers;
                    this.smartImportColumnMapping = result.columnMapping;
                    this.smartImportFileData = fileData;
                    this.smartImportTotalRows = result.totalRows;
                    
                    // Initialize unmapped columns (for any columns that weren't auto-detected)
                    this.smartImportHeaders.forEach(header => {
                        if (!this.smartImportColumnMapping[header]) {
                            this.smartImportColumnMapping[header] = 'unmapped';
                        }
                    });
                    
                    // Automatically generate preview after parsing (skip mapping step)
                    await this.previewSmartImport();
                } else {
                    const error = await response.json();
                    this.showToast(`Failed to parse file: ${error.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('Parse error:', error);
                this.showToast(`Failed to parse file: ${error.message}`, 'error');
            } finally {
                this.parsingFile = false;
            }
        },
        
        getColumnSample(header) {
            if (!this.smartImportFileData || this.smartImportFileData.length === 0) {
                return 'No sample data';
            }
            
            const sample = this.smartImportFileData[0][header];
            if (!sample) return 'Empty';
            
            const sampleStr = String(sample);
            return sampleStr.length > 30 ? sampleStr.substring(0, 30) + '...' : sampleStr;
        },
        
        async previewSmartImport() {
            this.previewingImport = true;
            try {
                const response = await fetch('/api/contacts/smart-import/preview', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        fileData: this.smartImportFileData,
                        columnMapping: this.smartImportColumnMapping
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    this.smartImportPreview = result.preview;
                    this.smartImportPreviewErrors = result.errors;
                    this.smartImportStep = 2; // Step 2 is now the preview step
                    this.showToast(`Preview generated! ${result.preview.length} contacts ready.`, 'success');
                } else {
                    const error = await response.json();
                    this.showToast(`Failed to generate preview: ${error.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('Preview error:', error);
                this.showToast(`Failed to generate preview: ${error.message}`, 'error');
            } finally {
                this.previewingImport = false;
            }
        },
        
        cancelSmartImport() {
            // Reset all smart import state
            this.smartImportStep = 1;
            this.smartImportFile = null;
            this.smartImportPasteData = '';
            this.smartImportHeaders = [];
            this.smartImportColumnMapping = {};
            this.smartImportFileData = [];
            this.smartImportTotalRows = 0;
            this.smartImportPreview = [];
            this.smartImportPreviewErrors = [];
            this.bulkImportCategory = ''; // Reset bulk category
            this.newBulkImportCategory = ''; // Reset new category input
            this.parsingFile = false;
            this.previewingImport = false;
            this.finalizingImport = false;
            this.isDragging = false;
            
            // Clear file input if it exists
            if (this.$refs.smartImportFileInput) {
                this.$refs.smartImportFileInput.value = '';
            }
            
            this.showToast('Import cancelled', 'info');
        },
        
        async finalizeSmartImport() {
            if (!confirm(`Are you sure you want to import ${this.smartImportTotalRows} contacts?`)) {
                return;
            }
            
            this.finalizingImport = true;
            try {
                const response = await fetch('/api/contacts/smart-import/finalize', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        fileData: this.smartImportFileData,
                        columnMapping: this.smartImportColumnMapping,
                        bulkCategory: this.bulkImportCategory || null
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    this.contacts = result.contacts;
                    this.updateAvailableCategories();
                    
                    // Capture bulk category before resetting
                    const appliedCategory = result.bulkCategoryApplied || (this.bulkImportCategory || null);
                    
                    // Reset smart import state
                    this.smartImportStep = 1;
                    this.smartImportFile = null;
                    this.smartImportPasteData = '';
                    this.smartImportHeaders = [];
                    this.smartImportColumnMapping = {};
                    this.smartImportFileData = [];
                    this.smartImportPreview = [];
                    this.smartImportPreviewErrors = [];
                    this.bulkImportCategory = ''; // Reset bulk category
                    this.newBulkImportCategory = ''; // Reset new category input
                    
                    // Clear file input if it exists
                    if (this.$refs.smartImportFileInput) {
                        this.$refs.smartImportFileInput.value = '';
                    }
                    
                    // Refresh upload history
                    await this.loadUploadHistory();
                    
                    const categoryMsg = appliedCategory ? ` with category "${appliedCategory}"` : '';
                    let message = '';
                    
                    // Build clear summary: imported + updated + skipped = total attempted
                    const parts = [];
                    if (result.imported > 0) {
                        parts.push(`${result.imported} new contact${result.imported !== 1 ? 's' : ''} imported`);
                    }
                    if (result.updated && result.updated > 0) {
                        parts.push(`${result.updated} existing contact${result.updated !== 1 ? 's' : ''} updated`);
                    }
                    if (result.skipped && result.skipped > 0) {
                        parts.push(`${result.skipped} duplicate${result.skipped !== 1 ? 's' : ''} skipped`);
                    }
                    
                    if (parts.length > 0) {
                        message = parts.join(', ') + categoryMsg + '.';
                    } else {
                        message = `Import completed${categoryMsg}!`;
                    }
                    
                    // Show total attempted if available for verification
                    if (result.totalAttempted !== undefined) {
                        message += ` (${result.totalAttempted} total processed)`;
                    }
                    
                    if (result.errors > 0) {
                        message += ` ${result.errors} row${result.errors !== 1 ? 's' : ''} had errors.`;
                    }
                    
                    this.showToast(message, 'success');
                } else {
                    const error = await response.json();
                    this.showToast(`Failed to import: ${error.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('Finalize error:', error);
                this.showToast(`Failed to import: ${error.message}`, 'error');
            } finally {
                this.finalizingImport = false;
            }
        },
        
        // Export to Excel methods
        getExportCount() {
            // If contacts are manually selected, return count of selected
            if (this.selectedContacts.length > 0) {
                return this.selectedContacts.length;
            }
            // Otherwise return count of filtered contacts
            return this.filteredContacts.length;
        },
        
        getExportButtonLabel() {
            const count = this.getExportCount();
            if (this.selectedContacts.length > 0) {
                return `Export ${count} selected contact${count !== 1 ? 's' : ''} to Excel`;
            } else if (this.categoryFilter || this.search) {
                return `Export ${count} filtered contact${count !== 1 ? 's' : ''} to Excel`;
            } else {
                return `Export all ${count} contacts to Excel`;
            }
        },
        
        async exportToExcel() {
            if (this.exportingContacts) return;
            
            this.exportingContacts = true;
            
            try {
                // Determine which contacts to export
                let contactIds = [];
                
                if (this.selectedContacts.length > 0) {
                    // Export manually selected contacts
                    contactIds = this.selectedContacts;
                } else {
                    // Export filtered contacts (respects category/search filters)
                    contactIds = this.filteredContacts.map(c => c.id);
                }
                
                if (contactIds.length === 0) {
                    this.showToast('No contacts to export', 'error');
                    this.exportingContacts = false;
                    return;
                }
                
                // Use POST request to avoid URL length limits with large contact lists
                const response = await fetch('/api/contacts/export', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ ids: contactIds })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Export failed' }));
                    throw new Error(errorData.error || 'Export failed');
                }
                
                // Get the CSV content as blob
                const blob = await response.blob();
                
                // Create a download link
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `contacts_export_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);
                
                this.showToast(`Successfully exported ${contactIds.length} contact${contactIds.length !== 1 ? 's' : ''} to Excel`, 'success');
            } catch (error) {
                console.error('Failed to export contacts:', error);
                this.showToast(`Failed to export contacts: ${error.message}`, 'error');
            } finally {
                this.exportingContacts = false;
            }
        }
    },
            async created() {
            await this.loadContacts();
            // Force refresh categories after loading
            this.$nextTick(() => {
                this.forceRefreshCategories();
            });
            
            // Load trash count
            await this.loadTrash();
            
            // Load upload history
            await this.loadUploadHistory();
        },
        mounted() {
            // Close dropdowns when clicking outside
            document.addEventListener('click', (event) => {
                const target = event.target;
                // Close category dropdowns if clicking outside
                if (!target.closest('.relative') || !target.closest('[class*="Category"]')) {
                    this.showCategoryDropdown = false;
                    this.showEditCategoryDropdown = false;
                }
            });
            // Arrow keys scroll the page (up/down = window, left/right = table overflow container when present)
            this._arrowKeyScrollHandler = (e) => {
                const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
                const isEditable = tag === 'input' || tag === 'textarea' || tag === 'select' || (e.target && e.target.isContentEditable);
                if (isEditable) return;
                const step = 100;
                let dx = 0, dy = 0;
                if (e.key === 'ArrowDown') dy = step;
                else if (e.key === 'ArrowUp') dy = -step;
                else if (e.key === 'ArrowRight') dx = step;
                else if (e.key === 'ArrowLeft') dx = -step;
                else return;
                e.preventDefault();
                if (dy !== 0) window.scrollBy({ top: dy, behavior: 'smooth' });
                if (dx !== 0) {
                    const table = document.getElementById('contactsTable');
                    const horizontalScroll = table && table.closest('.overflow-x-auto');
                    if (horizontalScroll) {
                        horizontalScroll.scrollBy({ left: dx, behavior: 'smooth' });
                    } else {
                        window.scrollBy({ left: dx, behavior: 'smooth' });
                    }
                }
            };
            document.addEventListener('keydown', this._arrowKeyScrollHandler);
        },
        beforeUnmount() {
            if (this._arrowKeyScrollHandler) {
                document.removeEventListener('keydown', this._arrowKeyScrollHandler);
            }
        }
    });

app.mount('#app')

// Table keyboard navigation (contact-manager has its own layout, so define here)
function initializeTableNavigation(tableId) {
    const table = document.getElementById(tableId);
    if (!table) return;

    const rows = table.querySelectorAll('tbody tr');
    let currentRow = 0;
    let currentCell = 0;

    function highlightCell(row, cell) {
        table.querySelectorAll('.keyboard-focus').forEach(el => el.classList.remove('keyboard-focus'));
        const targetRow = rows[row];
        if (targetRow) {
            const cells = targetRow.querySelectorAll('td, th');
            if (cells[cell]) {
                cells[cell].classList.add('keyboard-focus');
                cells[cell].scrollIntoView({ block: 'nearest' });
                const interactive = cells[cell].querySelector('button, input, select, a');
                if (interactive) interactive.focus();
            }
        }
    }

    table.addEventListener('keydown', function(e) {
        const maxRows = rows.length - 1;
        const currentRowElement = rows[currentRow];
        const maxCells = currentRowElement ? currentRowElement.querySelectorAll('td, th').length - 1 : 0;

        switch(e.key) {
            case 'ArrowUp':
                e.preventDefault();
                if (currentRow > 0) { currentRow--; highlightCell(currentRow, currentCell); }
                break;
            case 'ArrowDown':
                e.preventDefault();
                if (currentRow < maxRows) { currentRow++; highlightCell(currentRow, currentCell); }
                break;
            case 'ArrowLeft':
                e.preventDefault();
                if (currentCell > 0) { currentCell--; highlightCell(currentRow, currentCell); }
                break;
            case 'ArrowRight':
                e.preventDefault();
                if (currentCell < maxCells) { currentCell++; highlightCell(currentRow, currentCell); }
                break;
            case 'Enter':
            case ' ':
                e.preventDefault();
                const cell = rows[currentRow]?.querySelectorAll('td, th')[currentCell];
                const button = cell?.querySelector('button, a');
                if (button) button.click();
                break;
        }
    });

    if (rows.length > 0) {
        table.setAttribute('tabindex', '0');
        highlightCell(0, 0);
    }
}

// Initialize keyboard navigation for tables (after Vue has rendered)
document.addEventListener('DOMContentLoaded', function() {
    if (document.getElementById('contactsTable')) {
        initializeTableNavigation('contactsTable');
    }
    if (document.getElementById('trashTable')) {
        initializeTableNavigation('trashTable');
    }
});
</script> 