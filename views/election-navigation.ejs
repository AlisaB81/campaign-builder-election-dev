<%- include('partials/nav') %>
<% var safeMapboxToken = (typeof mapboxToken !== 'undefined' && mapboxToken != null) ? String(mapboxToken) : ''; %>
<link href="https://api.mapbox.com/mapbox-gl-js/v3.6.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v3.6.0/mapbox-gl.js"></script>

<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8" id="app">
    <div class="py-6 space-y-6">
        <!-- Page Header -->
        <div class="bg-white shadow rounded-lg p-6">
            <h1 class="text-2xl font-bold text-gray-900">Navigation</h1>
            <p class="mt-1 text-sm text-gray-500">Choose a list, set travel mode (driving or walking), then click <strong>Start route</strong> to build an optimized route from your current location. Your place is saved when you switch to Voter Interactions to record a note.</p>
        </div>

        <!-- List selection + Travel mode -->
        <div class="bg-white shadow rounded-lg p-6">
            <h2 class="text-lg font-semibold text-gray-900 mb-3">List &amp; travel</h2>
            <div class="flex flex-wrap gap-4 items-end">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">List</label>
                    <select v-model="selectedListId"
                            @change="onListSelected"
                            class="rounded-md border border-gray-300 shadow-sm px-3 py-2 text-sm focus:ring-indigo-500 focus:border-indigo-500 min-w-[220px]">
                        <option value="">— Select a list —</option>
                        <option v-for="list in savedLists" :key="list.id" :value="list.id">
                            {{ list.name || 'Unnamed' }} ({{ list.contact_count || 0 }})
                        </option>
                    </select>
                </div>
                <div v-if="selectedListId">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Travel</label>
                    <div class="flex rounded-md border border-gray-300 overflow-hidden">
                        <button type="button"
                                :class="travelMode === 'driving' ? 'bg-indigo-600 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'"
                                class="px-3 py-2 text-sm font-medium border-r border-gray-300"
                                @click="setTravelMode('driving')">
                            Driving
                        </button>
                        <button type="button"
                                :class="travelMode === 'walking' ? 'bg-indigo-600 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'"
                                class="px-3 py-2 text-sm font-medium"
                                @click="setTravelMode('walking')">
                            Walking
                        </button>
                    </div>
                </div>
            </div>
            <p v-if="savedLists.length === 0 && !loadingLists" class="mt-3 text-sm text-amber-700">No lists yet. Create a list in the Lists view first.</p>
        </div>

        <!-- Loading / empty -->
        <div v-if="loadingContacts || optimizingRoute" class="bg-white shadow rounded-lg p-8 text-center text-gray-500">
            <span v-if="loadingContacts">Loading contacts…</span>
            <span v-else>Optimizing route ({{ travelMode }})…</span>
        </div>
        <div v-else-if="selectedListId && !currentList" class="bg-white shadow rounded-lg p-8 text-center text-gray-500">
            Could not load list details.
        </div>
        <div v-else-if="selectedListId && currentList && optimizedStops.length === 0" class="bg-white shadow rounded-lg p-8 text-center text-gray-500">
            No contacts in this list, or none have addresses. Add contacts with addresses in the Lists view.
        </div>

        <!-- Map + Route (optimized list) -->
        <template v-else-if="optimizedStops.length > 0">
            <div class="bg-white shadow rounded-lg overflow-hidden">
                <div class="px-6 py-4 border-b border-gray-200 flex flex-wrap items-center justify-between gap-3">
                    <div>
                        <h2 class="text-lg font-semibold text-gray-900">Route: {{ currentList.name || 'Unnamed list' }}</h2>
                        <p class="text-sm text-gray-500">{{ optimizedStops.length }} stop(s) · time-optimized from your location for {{ travelMode }} (Mapbox)</p>
                    </div>
                    <div class="flex flex-wrap gap-2">
                        <button type="button"
                                @click.prevent="startRouteFromCurrentLocation"
                                :disabled="optimizingRoute"
                                class="px-3 py-1.5 text-sm font-medium bg-indigo-100 text-indigo-700 rounded-md hover:bg-indigo-200 disabled:opacity-50">
                            Re-optimize from my location
                        </button>
                    </div>
                </div>

                <!-- Map (Mapbox) – always show when we have stops so "Show on map" works -->
                <div v-if="mapboxTokenAvailable && optimizedStops.length > 0" class="relative w-full h-[400px] bg-gray-100" id="nav-map-container">
                    <div id="nav-map" class="absolute inset-0"></div>
                </div>

                <!-- Numbered stops: list + map link + Record note -->
                <div class="overflow-x-auto max-h-[50vh] overflow-y-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50 sticky top-0 z-10">
                            <tr>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-12">#</th>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Address</th>
                                <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-40">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            <tr v-for="(stop, index) in optimizedStops" :key="stop.contact.id"
                                :class="{ 'bg-indigo-50': currentStopIndex === index, 'bg-gray-100 opacity-75': index < currentStopIndex }"
                                :data-stop-index="index">
                                <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">{{ index + 1 }}</td>
                                <td class="px-4 py-2 text-sm text-gray-900">
                                    {{ [stop.contact.firstName, stop.contact.lastName].filter(Boolean).join(' ') || stop.contact.name || '—' }}
                                </td>
                                <td class="px-4 py-2 text-sm text-gray-600">
                                    {{ stop.fullAddress || 'No address' }}
                                </td>
                                <td class="px-4 py-2 whitespace-nowrap text-sm space-x-2">
                                    <button type="button"
                                            v-if="stop.fullAddress"
                                            @click.prevent="navigateToStop(stop)"
                                            class="text-indigo-600 hover:text-indigo-800 font-medium">
                                        Navigate
                                    </button>
                                    <a :href="'/election/interactions?contactId=' + encodeURIComponent(stop.contact.id) + '&returnTo=/election/navigation'"
                                       class="text-green-600 hover:text-green-800 font-medium">
                                        Record note
                                    </a>
                                    <button type="button"
                                            @click.prevent="skipStop(index)"
                                            class="text-amber-600 hover:text-amber-800 font-medium">
                                        Skip
                                    </button>
                                    <button type="button"
                                            @click.prevent="completeStop(index)"
                                            class="text-gray-700 hover:text-gray-900 font-medium">
                                        Complete stop
                                    </button>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </template>
    </div>
</div>

<script>
(function() {
const MAPBOX_TOKEN = <%- typeof safeMapboxToken !== 'undefined' ? JSON.stringify(safeMapboxToken) : '""' %>;
const STORAGE_KEY_LIST = 'navigation_listId';
const STORAGE_KEY_TRAVEL = 'navigation_travelMode';
const STORAGE_KEY_STOP = 'navigation_currentStopIndex';

function polylineToGeoJSON(encoded) {
    if (typeof encoded !== 'string' || !encoded) return null;
    var precision = 6;
    var inv = 1 / Math.pow(10, precision);
    var len = encoded.length;
    var index = 0;
    var lat = 0, lng = 0;
    var coords = [];
    while (index < len) {
        var b, shift = 0, result = 0;
        do {
            b = encoded.charCodeAt(index++) - 63;
            result |= (b & 0x1f) << shift;
            shift += 5;
        } while (b >= 0x20);
        var dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
        lat += dlat;
        shift = 0; result = 0;
        do {
            b = encoded.charCodeAt(index++) - 63;
            result |= (b & 0x1f) << shift;
            shift += 5;
        } while (b >= 0x20);
        var dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
        lng += dlng;
        coords.push([lng * inv, lat * inv]);
    }
    return { type: 'LineString', coordinates: coords };
}

const { createApp } = Vue;

function fullAddress(contact) {
    const parts = [
        (contact.address || '').trim(),
        (contact.city || '').trim(),
        (contact.province || '').trim(),
        (contact.postalCode || contact.postal_code || '').trim()
    ].filter(Boolean);
    return parts.join(', ') || '';
}

createApp({
    data() {
        return {
            mapboxTokenAvailable: !!MAPBOX_TOKEN,
            savedLists: [],
            loadingLists: false,
            selectedListId: '',
            travelMode: 'driving',
            currentList: null,
            contacts: [],
            optimizedStops: [],
            loadingContacts: false,
            optimizingRoute: false,
            routeGeometry: null,
            currentStopIndex: 0,
            mapboxMap: null,
            mapboxMarkerLayer: null,
            startRouteInProgress: false
        };
    },
    async mounted() {
        const travel = typeof sessionStorage !== 'undefined' ? sessionStorage.getItem(STORAGE_KEY_TRAVEL) : null;
        if (travel === 'walking' || travel === 'driving') this.travelMode = travel;

        await this.loadLists();
        // Never auto-select or load a list on page load: user must choose from dropdown every time.
        this.persistState();
    },
    computed: {
        directionsUrl() {
            const stops = this.optimizedStops || [];
            const withAddr = stops.filter(s => s.fullAddress && s.fullAddress.trim());
            if (withAddr.length < 2) return '';
            const mode = this.travelMode === 'walking' ? 'walking' : 'driving';
            const origin = encodeURIComponent(withAddr[0].fullAddress);
            const dest = encodeURIComponent(withAddr[withAddr.length - 1].fullAddress);
            const waypoints = withAddr.length > 2
                ? encodeURIComponent(withAddr.slice(1, -1).map(s => s.fullAddress).join('|'))
                : '';
            let url = 'https://www.google.com/maps/dir/?api=1&origin=' + origin + '&destination=' + dest + '&travelmode=' + mode;
            if (waypoints) url += '&waypoints=' + waypoints;
            return url;
        }
    },
    watch: {
        selectedListId() { this.persistState(); },
        travelMode() { this.persistState(); },
        currentStopIndex() { this.persistState(); },
        optimizedStops: {
            handler(stops) {
                const withCoords = stops.filter(s => s.coordinates && s.coordinates.length === 2);
                if (withCoords.length && MAPBOX_TOKEN) this.$nextTick(() => this.initMap());
            },
            deep: true
        }
    },
    methods: {
        persistState() {
            try {
                if (typeof sessionStorage === 'undefined') return;
                if (this.selectedListId) sessionStorage.setItem(STORAGE_KEY_LIST, this.selectedListId);
                sessionStorage.setItem(STORAGE_KEY_TRAVEL, this.travelMode);
                sessionStorage.setItem(STORAGE_KEY_STOP, String(this.currentStopIndex));
            } catch (e) {}
        },
        setTravelMode(mode) {
            this.travelMode = mode;
            if (this.optimizedStops.length) this.optimizeRoute();
        },
        async loadLists() {
            try {
                this.loadingLists = true;
                const res = await fetch('/api/election/lists', { credentials: 'include' });
                if (res.ok) {
                    const data = await res.json();
                    this.savedLists = data.lists || [];
                    // Do not auto-select first list; user must choose from dropdown.
                }
            } catch (e) {
                console.error(e);
            } finally {
                this.loadingLists = false;
            }
        },
        async onListSelected() {
            if (!this.selectedListId) {
                this.currentList = null;
                this.contacts = [];
                this.optimizedStops = [];
                this.routeGeometry = null;
                return;
            }
            await this.loadListContacts();
        },
        async startRoute() {
            if (!this.selectedListId) {
                alert('Select a list first.');
                return;
            }
            this.startRouteInProgress = true;
            try {
                if (!this.currentList || !this.contacts.length) {
                    await this.loadListContacts();
                }
                const withAddr = this.contacts.filter(c => fullAddress(c).trim());
                if (withAddr.length < 2) {
                    alert('List needs at least 2 contacts with addresses.');
                    return;
                }
                await this.startRouteFromCurrentLocation();
            } finally {
                this.startRouteInProgress = false;
            }
        },
        navigateToStop(stop) {
            if (!stop || !stop.fullAddress || !stop.fullAddress.trim()) return;
            const mode = this.travelMode === 'walking' ? 'walking' : 'driving';
            const dest = encodeURIComponent(stop.fullAddress.trim());
            const openUrl = (originParam) => {
                const url = 'https://www.google.com/maps/dir/?api=1&destination=' + dest + '&travelmode=' + mode + (originParam ? '&origin=' + originParam : '');
                window.open(url, '_blank', 'noopener,noreferrer');
            };
            if (!navigator.geolocation) {
                openUrl('');
                return;
            }
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    const origin = encodeURIComponent(pos.coords.latitude + ',' + pos.coords.longitude);
                    openUrl(origin);
                },
                () => { openUrl(''); },
                { enableHighAccuracy: true, timeout: 8000, maximumAge: 60000 }
            );
        },
        focusMapOnStop(index) {
            const stop = this.optimizedStops[index];
            if (!stop || !stop.coordinates) return;
            const container = document.getElementById('nav-map-container');
            if (container) container.scrollIntoView({ behavior: 'smooth', block: 'center' });
            if (this.mapboxMap) {
                try {
                    this.mapboxMap.flyTo({ center: stop.coordinates, zoom: 16, duration: 800 });
                } catch (e) {}
            } else {
                this.$nextTick(() => this.initMap());
                this.$nextTick(() => {
                    setTimeout(() => {
                        if (this.mapboxMap && stop.coordinates) {
                            try {
                                this.mapboxMap.flyTo({ center: stop.coordinates, zoom: 16, duration: 800 });
                            } catch (err) {}
                        }
                    }, 500);
                });
            }
        },
        async loadListContacts() {
            try {
                this.loadingContacts = true;
                this.currentList = null;
                this.contacts = [];
                this.optimizedStops = [];
                this.routeGeometry = null;

                const listRes = await fetch('/api/election/lists/' + this.selectedListId, { credentials: 'include' });
                if (!listRes.ok) return;
                const listData = await listRes.json();
                this.currentList = listData.list || null;
                if (!this.currentList || !this.currentList.filter_config) {
                    this.loadingContacts = false;
                    return;
                }

                const contactsRes = await fetch('/api/election/lists/contacts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        filterConfig: this.currentList.filter_config,
                        limit: 5000,
                        offset: 0
                    })
                });
                if (!contactsRes.ok) {
                    this.loadingContacts = false;
                    return;
                }
                const contactsData = await contactsRes.json();
                this.contacts = contactsData.contacts || [];
                await this.optimizeRoute();
            } catch (e) {
                console.error(e);
            } finally {
                this.loadingContacts = false;
            }
        },
        startRouteFromCurrentLocation() {
            if (!navigator.geolocation) {
                alert('Your browser does not support location. Use Re-optimize order instead.');
                return Promise.resolve();
            }
            return new Promise((resolve, reject) => {
                this.optimizingRoute = true;
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        const origin = [pos.coords.longitude, pos.coords.latitude];
                        this.optimizeRoute(origin).finally(() => {
                            this.optimizingRoute = false;
                            resolve();
                        });
                    },
                    () => {
                        this.optimizingRoute = false;
                        alert('Could not get your location. Allow location access or use Re-optimize order.');
                        reject(new Error('Location denied'));
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
                );
            });
        },
        async optimizeRoute(origin) {
            const withAddress = this.contacts.map(c => ({
                contact: c,
                fullAddress: fullAddress(c),
                sortKey: [
                    (c.postalCode || c.postal_code || '').replace(/\s/g, '').toUpperCase(),
                    (c.city || '').toLowerCase(),
                    (c.address || '').toLowerCase()
                ].join(' ')
            })).filter(s => s.fullAddress.trim() !== '');
            const noAddress = this.contacts.filter(c => !fullAddress(c).trim()).map(c => ({
                contact: c,
                fullAddress: '',
                sortKey: ''
            }));
            withAddress.sort((a, b) => (a.sortKey || '').localeCompare(b.sortKey || ''));

            const maxOptimize = 12;
            if (withAddress.length < 2) {
                this.optimizedStops = [...withAddress, ...noAddress];
                this.routeGeometry = null;
                return;
            }

            const toSend = withAddress.slice(0, maxOptimize);
            this.optimizingRoute = true;
            try {
                const body = { stops: toSend, profile: this.travelMode };
                if (origin && Array.isArray(origin) && origin.length >= 2) body.origin = origin;
                const res = await fetch('/api/election/navigation/optimize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(body)
                });
                const data = await res.json();
                if (res.ok && data.stops && data.stops.length) {
                    const ordered = data.stops.map(s => ({ ...s, contact: s.contact || s }));
                    const rest = withAddress.slice(maxOptimize);
                    this.optimizedStops = [...ordered, ...rest, ...noAddress];
                    this.routeGeometry = data.routeGeometry || null;
                } else {
                    this.optimizedStops = [...withAddress, ...noAddress];
                    this.routeGeometry = null;
                }
            } catch (e) {
                console.error(e);
                this.optimizedStops = [...withAddress, ...noAddress];
                this.routeGeometry = null;
            } finally {
                this.optimizingRoute = false;
            }
            this.persistState();
        },
        initMap() {
            if (!MAPBOX_TOKEN || !window.mapboxgl || !this.optimizedStops.length) return;
            const coords = this.optimizedStops
                .filter(s => s.coordinates && s.coordinates.length === 2)
                .map(s => s.coordinates);
            if (coords.length === 0) return;

            const el = document.getElementById('nav-map');
            if (!el) return;

            if (this.mapboxMap) {
                try { this.mapboxMap.remove(); } catch (e) {}
                this.mapboxMap = null;
            }

            mapboxgl.accessToken = MAPBOX_TOKEN;
            const lngs = coords.map(c => c[0]);
            const lats = coords.map(c => c[1]);
            const center = [
                (Math.min(...lngs) + Math.max(...lngs)) / 2,
                (Math.min(...lats) + Math.max(...lats)) / 2
            ];
            const map = new mapboxgl.Map({
                container: 'nav-map',
                style: 'mapbox://styles/mapbox/streets-v12',
                center: center,
                zoom: 11
            });
            map.addControl(new mapboxgl.NavigationControl(), 'top-right');

            map.on('load', () => {
                let geom = this.routeGeometry;
                if (geom && typeof geom === 'string') {
                    try {
                        geom = polylineToGeoJSON(geom);
                    } catch (e) {
                        geom = null;
                    }
                }
                if (geom && geom.coordinates && geom.coordinates.length >= 2) {
                    map.addSource('route', {
                        type: 'geojson',
                        data: {
                            type: 'Feature',
                            properties: {},
                            geometry: geom
                        }
                    });
                    map.addLayer({
                        id: 'route-line',
                        type: 'line',
                        source: 'route',
                        layout: { 'line-join': 'round', 'line-cap': 'round' },
                        paint: { 'line-color': '#4f46e5', 'line-width': 4 }
                    });
                }

                coords.forEach((c, i) => {
                    const markerEl = document.createElement('div');
                    markerEl.className = 'nav-marker';
                    markerEl.textContent = i + 1;
                    markerEl.style.cssText = 'width:24px;height:24px;background:#4f46e5;color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:700;border:2px solid #fff;';
                    new mapboxgl.Marker(markerEl).setLngLat(c).addTo(map);
                });

                const bounds = new mapboxgl.LngLatBounds();
                coords.forEach(c => bounds.extend(c));
                map.fitBounds(bounds, { padding: 50, maxZoom: 14 });
            });

            this.mapboxMap = map;
        },
        skipStop(index) {
            if (index < 0 || index >= this.optimizedStops.length) return;
            const stop = this.optimizedStops[index];
            const rest = this.optimizedStops.filter((_, i) => i !== index);
            this.optimizedStops = [...rest, stop];
            this.routeGeometry = null;
            this.persistState();
        },
        completeStop(index) {
            if (index < 0 || index >= this.optimizedStops.length) return;
            this.currentStopIndex = Math.min(index + 1, this.optimizedStops.length);
            this.persistState();
            if (this.currentStopIndex >= this.optimizedStops.length) {
                this.routeCompleted();
            }
        },
        routeCompleted() {
            if (this.mapboxMap) {
                try { this.mapboxMap.remove(); } catch (e) {}
                this.mapboxMap = null;
            }
            this.optimizedStops = [];
            this.routeGeometry = null;
            this.currentStopIndex = 0;
            this.persistState();
        },
        copyStopsToClipboard() {
            const lines = this.optimizedStops.map((s, i) => {
                const name = [s.contact.firstName, s.contact.lastName].filter(Boolean).join(' ') || s.contact.name || '—';
                return (i + 1) + '. ' + name + ' – ' + (s.fullAddress || 'No address');
            });
            const text = lines.join('\n');
            navigator.clipboard.writeText(text).then(() => {
                alert('Route list copied to clipboard.');
            }).catch(() => {
                alert('Could not copy. Select and copy the table manually.');
            });
        }
    }
}).mount('#app');
})();
</script>
