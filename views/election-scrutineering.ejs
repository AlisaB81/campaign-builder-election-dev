<%- include('partials/nav') %>
<div id="page-scrutineering" data-page="scrutineering" style="display:none" aria-hidden="true"></div>
<% 
const isElectionAccount = (typeof user !== 'undefined' && user && (user.electionMode || user.accountType === 'election'));
%>

<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6" id="app">
    <h1 class="text-xl font-bold text-gray-900 mb-6">Vote Tracking</h1>

    <!-- Search -->
    <div class="mb-6">
        <input type="text" v-model="verifySearch"
               @input="searchVerifyContacts"
               placeholder="Search contact (name, email, or phone)"
               class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
        <div v-if="verifySearchResults.length > 0" class="mt-1 border border-gray-200 rounded-md max-h-48 overflow-y-auto bg-white shadow">
            <div v-for="c in verifySearchResults"
                 :key="c.id"
                 @click="selectVerifyContact(c)"
                 class="px-3 py-2 hover:bg-gray-50 cursor-pointer border-b border-gray-100 last:border-0">
                <div class="font-medium text-gray-900">{{ contactDisplayName(c) }}</div>
                <div class="text-sm text-gray-500">{{ c.email || c.phone || '' }}</div>
            </div>
        </div>
        <div v-if="verifyContact" class="mt-3 flex items-center justify-between py-2 px-3 bg-gray-50 rounded-md">
            <span class="font-medium text-gray-900">{{ contactDisplayName(verifyContact) }}</span>
            <span v-if="verifyStatus.supportCategory" class="text-xs px-2 py-0.5 rounded bg-gray-200 text-gray-700">{{ formatSupportCategory(verifyStatus.supportCategory) }}</span>
            <label class="flex items-center gap-2 cursor-pointer">
                <input type="checkbox" :checked="verifyStatus.isVoted" @change="toggleVoted">
                <span class="text-sm font-medium text-gray-700">Voted</span>
            </label>
        </div>
    </div>

    <!-- Tally -->
    <div class="border border-gray-200 rounded-lg p-4">
        <div class="flex items-center justify-between mb-3">
            <h2 class="text-lg font-semibold text-gray-900">Running tally</h2>
            <div class="flex gap-2">
                <button @click="loadTally" class="px-2 py-1 text-sm text-indigo-600 hover:text-indigo-800">Refresh</button>
                <button @click="confirmClearVoted" class="px-2 py-1 text-sm text-red-600 hover:text-red-800">Clear voted</button>
            </div>
        </div>
        <p class="text-2xl font-semibold text-gray-900 mb-2">Total marked voted: {{ tally.totalVoted }}</p>
        <div class="space-y-1 text-sm text-gray-700 mb-3">
            <div v-for="(count, cat) in tally.byCategory" :key="cat" v-show="count > 0" class="flex justify-between">
                <span>{{ formatSupportCategory(cat) }}</span>
                <span>{{ count }}</span>
            </div>
        </div>
        <div v-if="tally.projectedOutcome" class="pt-3 border-t border-gray-200">
            <p class="text-sm font-medium text-gray-500 mb-1">Projected outcome (of those marked voted)</p>
            <div class="text-sm space-y-0.5">
                <div>Support: <strong>{{ tally.projectedOutcome.supportPct }}%</strong></div>
                <div>Oppose: <strong>{{ tally.projectedOutcome.opposePct }}%</strong></div>
                <div>Undecided: <strong>{{ tally.projectedOutcome.undecidedPct }}%</strong></div>
                <div>Unknown: <strong>{{ tally.projectedOutcome.unknownPct }}%</strong></div>
            </div>
        </div>
        <p v-if="tally.totalVoted === 0" class="text-sm text-gray-500 mt-2">Search and mark contacts as Voted to see the tally.</p>
    </div>

<!-- Mark Vote Modal -->
<div v-if="showMarkVoteModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50" @click.self="showMarkVoteModal = false" role="dialog" aria-modal="true" aria-labelledby="mark-vote-title">
    <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white" @click.stop>
        <div class="mt-3">
            <h3 id="mark-vote-title" class="text-lg font-medium text-gray-900 mb-4">Mark Vote</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Search Contact</label>
                    <input type="text" v-model="markVoteForm.contactSearch" 
                           @input="searchContacts"
                           placeholder="Name, email, or phone"
                           class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    <div v-if="contactSearchResults.length > 0" class="mt-2 border border-gray-200 rounded-md max-h-40 overflow-y-auto">
                        <div v-for="contact in contactSearchResults" 
                             :key="contact.id"
                             @click="selectContact(contact)"
                             class="px-3 py-2 hover:bg-gray-100 cursor-pointer">
                            <div class="font-medium">{{ contact.name || (contact.firstName + ' ' + contact.lastName) }}</div>
                            <div class="text-sm text-gray-500">{{ contact.email || contact.phone }}</div>
                        </div>
                    </div>
                </div>
                <div v-if="markVoteForm.selectedContact">
                    <div class="bg-gray-50 p-3 rounded-md mb-2">
                        <div class="font-medium">{{ markVoteForm.selectedContact.name || (markVoteForm.selectedContact.firstName + ' ' + markVoteForm.selectedContact.lastName) }}</div>
                        <div class="text-sm text-gray-600">{{ markVoteForm.selectedContact.email || markVoteForm.selectedContact.phone }}</div>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Poll Number *</label>
                    <input type="text" v-model="markVoteForm.pollNumber" required
                           class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Riding</label>
                    <input type="text" v-model="markVoteForm.riding"
                           class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Province</label>
                    <input type="text" v-model="markVoteForm.province"
                           class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Notes (Optional)</label>
                    <textarea v-model="markVoteForm.notes" rows="3"
                              class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"></textarea>
                </div>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button @click="showMarkVoteModal = false" 
                        class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">
                    Cancel
                </button>
                <button @click="submitMarkVote" 
                        :disabled="!markVoteForm.selectedContact || !markVoteForm.pollNumber || submitting"
                        class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 disabled:opacity-50">
                    {{ submitting ? 'Marking...' : 'Mark Vote' }}
                </button>
            </div>
        </div>
    </div>
</div>
</div>

<script>
const { createApp } = Vue;

function fetchWithTimeout(url, options, timeoutMs) {
    timeoutMs = timeoutMs || 15000;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    return fetch(url, { ...options, signal: controller.signal })
        .finally(() => clearTimeout(timeoutId));
}

createApp({
    data() {
        return {
            voteMarks: [],
            stats: {
                totalVotes: 0,
                turnoutRate: 0,
                activePolls: 0
            },
            filters: {
                pollNumber: '',
                riding: '',
                contactSearch: ''
            },
            loading: false,
            showMarkVoteModal: false,
            markVoteForm: {
                selectedContact: null,
                contactSearch: '',
                pollNumber: '',
                riding: '',
                province: '',
                notes: '',
                markedByName: ''
            },
            contactSearchResults: [],
            submitting: false,
            loadError: null,
            // Verify voter info
            verifySearch: '',
            verifySearchResults: [],
            verifyContact: null,
            verifyEdit: {},
            verifyEditCategoriesStr: '',
            verifyStatus: { isVoted: false, supportCategory: '' },
            verifySaving: false,
            // Running tally
            tally: {
                totalVoted: 0,
                byCategory: { strong_support: 0, likely_support: 0, undecided: 0, likely_oppose: 0, strong_oppose: 0, unknown: 0 },
                projectedOutcome: null
            }
        }
    },
    mounted() {
        this.loadVoteMarks();
        this.loadStats();
        this.loadTally();
        var vm = this;
        setTimeout(function() { vm.loading = false; }, 12000);
        document.addEventListener('keydown', this.onKeydown);
    },
    beforeUnmount() {
        document.removeEventListener('keydown', this.onKeydown);
    },
    methods: {
        async loadVoteMarks() {
            try {
                this.loading = true;
                this.loadError = null;
                let url = '/api/election/vote-marks';
                const params = new URLSearchParams();
                if (this.filters.pollNumber) params.append('pollNumber', this.filters.pollNumber);
                if (this.filters.riding) params.append('riding', this.filters.riding);
                if (this.filters.contactSearch) params.append('contactSearch', this.filters.contactSearch);
                if (params.toString()) url += '?' + params.toString();
                
                const response = await fetchWithTimeout(url, { credentials: 'include' });
                
                if (response.ok) {
                    const data = await response.json();
                    this.voteMarks = data.voteMarks || [];
                } else {
                    console.error('Failed to load vote marks:', response.status);
                }
            } catch (error) {
                console.error('Failed to load vote marks:', error);
                this.loadError = error && (error.message || String(error));
            } finally {
                this.loading = false;
            }
        },
        async loadStats() {
            try {
                const response = await fetchWithTimeout('/api/election/poll-turnout', { credentials: 'include' });
                
                if (response.ok) {
                    const data = await response.json();
                    const turnout = data.turnout || [];
                    this.stats.totalVotes = turnout.reduce((sum, t) => sum + (t.votes_cast || 0), 0);
                    this.stats.activePolls = new Set(turnout.map(t => t.poll_number)).size;
                    
                    const totalVoters = turnout.reduce((sum, t) => sum + (t.total_voters || 0), 0);
                    this.stats.turnoutRate = totalVoters > 0 ? Math.round((this.stats.totalVotes / totalVoters) * 100) : 0;
                }
            } catch (error) {
                console.error('Failed to load stats:', error);
            }
        },
        async searchContacts() {
            if (!this.markVoteForm.contactSearch || this.markVoteForm.contactSearch.length < 2) {
                this.contactSearchResults = [];
                return;
            }
            
            try {
                const response = await fetch(`/api/contacts?search=${encodeURIComponent(this.markVoteForm.contactSearch)}`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const contacts = await response.json();
                    this.contactSearchResults = contacts.slice(0, 10); // Limit to 10 results
                }
            } catch (error) {
                console.error('Failed to search contacts:', error);
            }
        },
        selectContact(contact) {
            this.markVoteForm.selectedContact = contact;
            this.contactSearchResults = [];
            this.markVoteForm.contactSearch = contact.name || (contact.firstName + ' ' + contact.lastName);
        },
        async submitMarkVote() {
            if (!this.markVoteForm.selectedContact || !this.markVoteForm.pollNumber) {
                alert('Please select a contact and enter a poll number.');
                return;
            }
            
            try {
                this.submitting = true;
                const response = await fetch('/api/election/vote-marks', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        contactId: this.markVoteForm.selectedContact.id,
                        pollNumber: this.markVoteForm.pollNumber,
                        riding: this.markVoteForm.riding || null,
                        province: this.markVoteForm.province || null,
                        notes: this.markVoteForm.notes || null
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    alert('Vote marked successfully! Verification code: ' + data.voteMark.verification_code);
                    this.showMarkVoteModal = false;
                    this.resetMarkVoteForm();
                    await this.loadVoteMarks();
                    await this.loadStats();
                } else {
                    const error = await response.json();
                    alert('Failed to mark vote: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Failed to mark vote:', error);
                alert('Failed to mark vote. Please try again.');
            } finally {
                this.submitting = false;
            }
        },
        resetMarkVoteForm() {
            this.markVoteForm = {
                selectedContact: null,
                contactSearch: '',
                pollNumber: '',
                riding: '',
                province: '',
                notes: '',
                markedByName: ''
            };
            this.contactSearchResults = [];
        },
        async verifyVote(verificationCode) {
            try {
                const response = await fetch(`/api/election/vote-marks/verify/${verificationCode}`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    alert('Vote verified!\nContact: ' + (data.voteMark.contact_name || 'Unknown') + '\nPoll: ' + data.voteMark.poll_number);
                } else {
                    alert('Verification code not found.');
                }
            } catch (error) {
                console.error('Failed to verify vote:', error);
                alert('Failed to verify vote. Please try again.');
            }
        },
        formatDate(dateString) {
            if (!dateString) return '-';
            const date = new Date(dateString);
            return date.toLocaleString();
        },
        contactDisplayName(c) {
            if (!c) return '';
            return c.name || (c.firstName && c.lastName ? (c.firstName + ' ' + c.lastName) : (c.firstName || c.lastName || c.email || c.id || 'Unknown'));
        },
        formatSupportCategory(cat) {
            const labels = { strong_support: 'Strong support', likely_support: 'Likely support', undecided: 'Undecided', likely_oppose: 'Likely oppose', strong_oppose: 'Strong oppose', unknown: 'Unknown' };
            return labels[cat] || (cat && cat.replace(/_/g, ' ')) || 'Unknown';
        },
        async searchVerifyContacts() {
            const q = (this.verifySearch || '').trim();
            if (q.length < 2) { this.verifySearchResults = []; return; }
            try {
                const res = await fetch(`/api/contacts?search=${encodeURIComponent(q)}`, { credentials: 'include' });
                if (res.ok) {
                    const list = await res.json();
                    this.verifySearchResults = list.slice(0, 10);
                }
            } catch (e) { console.error(e); }
        },
        async selectVerifyContact(c) {
            this.verifyContact = c;
            this.verifySearchResults = [];
            this.verifySearch = this.contactDisplayName(c);
            this.verifyEdit = { ...c };
            this.verifyEditCategoriesStr = Array.isArray(c.categories) ? c.categories.join(', ') : (c.category || '');
            await this.loadVerifyStatus();
        },
        async loadVerifyStatus() {
            if (!this.verifyContact || !this.verifyContact.id) return;
            try {
                const res = await fetch(`/api/election/scrutineering/contact/${encodeURIComponent(this.verifyContact.id)}/status`, { credentials: 'include' });
                if (res.ok) this.verifyStatus = await res.json();
            } catch (e) { console.error(e); }
        },
        async saveVerifyContact() {
            if (!this.verifyContact || !this.verifyContact.id) return;
            const categories = this.verifyEditCategoriesStr ? this.verifyEditCategoriesStr.split(',').map(s => s.trim()).filter(Boolean) : [];
            const payload = { ...this.verifyEdit, categories };
            try {
                this.verifySaving = true;
                const res = await fetch(`/api/contacts/${encodeURIComponent(this.verifyContact.id)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(payload)
                });
                if (res.ok) {
                    this.verifyContact = await res.json();
                    this.verifyEdit = { ...this.verifyContact };
                    this.verifyEditCategoriesStr = Array.isArray(this.verifyContact.categories) ? this.verifyContact.categories.join(', ') : '';
                } else {
                    const err = await res.json();
                    alert('Save failed: ' + (err.error || res.status));
                }
            } catch (e) {
                console.error(e);
                alert('Save failed.');
            } finally {
                this.verifySaving = false;
            }
        },
        async toggleVoted() {
            if (!this.verifyContact || !this.verifyContact.id) return;
            try {
                if (this.verifyStatus.isVoted) {
                    await fetch(`/api/election/scrutineering/voted/${encodeURIComponent(this.verifyContact.id)}`, { method: 'DELETE', credentials: 'include' });
                    this.verifyStatus.isVoted = false;
                } else {
                    const res = await fetch('/api/election/scrutineering/voted', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ contactId: this.verifyContact.id })
                    });
                    if (res.ok) this.verifyStatus.isVoted = true;
                }
                await this.loadTally();
            } catch (e) { console.error(e); }
        },
        async loadTally() {
            try {
                const res = await fetchWithTimeout('/api/election/scrutineering/tally', { credentials: 'include' });
                if (res.ok) this.tally = await res.json();
            } catch (e) { console.error(e); }
        },
        confirmClearVoted() {
            if (!confirm('Clear all voted data for this election? This cannot be undone.')) return;
            this.doClearVoted();
        },
        async doClearVoted() {
            try {
                const res = await fetch('/api/election/scrutineering/clear-voted', { method: 'POST', credentials: 'include' });
                if (res.ok) {
                    await this.loadTally();
                    if (this.verifyContact) this.verifyStatus.isVoted = false;
                }
            } catch (e) { console.error(e); }
        },
        onKeydown(e) {
            if (e.key === 'Escape' && this.showMarkVoteModal) {
                this.showMarkVoteModal = false;
            }
        }
    },
    watch: {
        filters: {
            deep: true,
            handler() {
                // Debounce search
                clearTimeout(this.searchTimeout);
                this.searchTimeout = setTimeout(() => {
                    this.loadVoteMarks();
                }, 500);
            }
        }
    }
}).mount('#app');
</script>
