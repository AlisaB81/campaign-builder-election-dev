<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Library - Campaign Builder</title>
    <link href="/css/tailwind.min.css" rel="stylesheet">
    <link href="/css/components.css" rel="stylesheet">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body class="bg-gray-50">
    <%- include('partials/nav') %>
    <div id="app" class="min-h-screen px-4 sm:px-6 lg:px-8" style="width: 100%; max-width: 80rem; margin-left: auto; margin-right: auto;">
        <!-- Header: same width as sections below; space below via padding-bottom -->
        <div class="bg-white shadow-sm border-b" style="padding-bottom: 2.5rem;">
            <div class="w-full px-4 sm:px-6 lg:px-8 pt-8">
                <div class="flex justify-between items-center">
                    <div>
                        <h1 class="text-2xl font-bold text-gray-900 mb-2">Image Library</h1>
                        <p class="text-gray-600">Your saved images from templates and AI generation</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Filters and Search: same width as header; space above via margin-top -->
        <div class="bg-white border-b" style="margin-top: 2rem;">
            <div class="w-full px-4 sm:px-6 lg:px-8 py-6">
                <div class="flex flex-wrap gap-6 items-center">
                    <!-- Section Filter -->
                    <div class="w-96">
                        <select v-model="selectedSection" @change="loadImages" class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                            <option value="all">All Sections</option>
                            <option value="header">Header ({{ getImageDimensions('header') }})</option>
                            <option value="banner">Banner ({{ getImageDimensions('banner') }})</option>
                            <option value="body">Body ({{ getImageDimensions('body') }})</option>
                            <option value="footer">Footer ({{ getImageDimensions('footer') }})</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="w-full py-12">
            <!-- Loading State -->
            <div v-if="loading" class="flex justify-center items-center py-12">
                <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600"></div>
            </div>

            <!-- Empty State -->
            <div v-else-if="images.length === 0" class="text-center py-12">
                <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                </svg>
                <h3 class="mt-2 text-sm font-medium text-gray-900">No images found</h3>
                <p class="mt-1 text-sm text-gray-500">Get started by uploading your first image.</p>
                <div class="mt-6">
                    <button @click="showUploadModal = true" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition-colors">
                        Upload Images
                    </button>
                </div>
            </div>

            <!-- Images Grid -->
            <div v-else class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                <div v-for="image in images" :key="image.id" 
                     class="relative bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden hover:shadow-md transition-shadow">
                    
                    <!-- Image -->
                    <div class="relative bg-gray-100 overflow-hidden" :style="image.section === 'header' ? 'aspect-ratio: 16/3; min-height: 200px; max-height: 200px;' : 'aspect-ratio: 16/9; min-height: 280px; max-height: 280px;'">
                        <img :src="normalizeImageUrl(image.url)" 
                             :alt="image.name"
                             class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-auto h-auto max-w-full max-h-full object-contain"
                             :style="image.section === 'header' ? 'max-height: 200px; max-width: 100%;' : 'max-height: 280px; max-width: 100%;'"
                             @error="handleImageError($event, image)"
                             @load="handleImageLoad($event, image)"
                             :class="{ 'opacity-50': image.loading, 'hidden': image.error }">
                        
                        <!-- Loading State -->
                        <div v-if="image.loading" class="absolute inset-0 flex items-center justify-center bg-gray-100" style="z-index: 5;">
                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                        </div>
                        
                        <!-- Error State -->
                        <div v-if="image.error" class="absolute inset-0 flex items-center justify-center bg-gray-100" style="z-index: 5;">
                            <div class="text-center p-4">
                                <svg class="mx-auto h-8 w-8 text-gray-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                </svg>
                                <p class="text-xs text-gray-500">Image unavailable</p>
                                <button @click="retryImageLoad(image)" 
                                        class="mt-2 text-xs text-indigo-600 hover:text-indigo-800">
                                    Retry
                                </button>
                            </div>
                        </div>

                    </div>

                    <!-- Image Info -->
                    <div class="p-6" style="padding-top: 2rem !important;">
                        <p v-if="image.description" class="text-sm text-gray-600 line-clamp-2" style="margin-bottom: 1.5rem !important;">{{ image.description }}</p>
                        
                        <!-- Section and Size -->
                        <div class="flex items-center justify-between text-xs text-gray-500" style="margin-bottom: 1.5rem !important;">
                            <span class="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                                {{ image.section }}
                            </span>
                            <div class="flex items-center space-x-2">
                                <span v-if="image.isDefault" class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
                                    Default
                                </span>
                                <span v-if="image.size > 0" class="text-gray-500">{{ formatFileSize(image.size) }}</span>
                            </div>
                        </div>

                        <!-- Tags Display -->
                        <div v-if="getImageTags(image).length > 0" class="flex flex-wrap gap-2 mb-3">
                            <span v-for="tag in getImageTags(image)" :key="tag"
                                  class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                                {{ tag }}
                                <button @click="removeTagFromImage(image, tag)" 
                                        class="ml-1 text-gray-500 hover:text-gray-700">
                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                    </svg>
                                </button>
                            </span>
                        </div>

                        <!-- Add Tags Input -->
                        <div class="mb-3">
                            <div class="flex items-center gap-2">
                                <input v-model="image.newTag" 
                                       @keyup.enter="addTagToImage(image)"
                                       type="text" 
                                       placeholder="Add tags (comma separated)" 
                                       class="flex-1 border-2 border-gray-300 bg-white text-gray-900 rounded-md px-3 py-2 text-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-600 placeholder-gray-500">
                                <button @click="addTagToImage(image)"
                                        class="px-3 py-2 bg-indigo-600 text-white rounded-md text-sm hover:bg-indigo-700 font-medium whitespace-nowrap">
                                    Add
                                </button>
                            </div>
                        </div>

                        <!-- Actions -->
                        <div class="flex justify-end gap-2 pt-2">
                            <button @click="downloadImageFromLibrary(image)" 
                                    class="text-blue-600 hover:text-blue-700 text-sm font-medium px-3 py-2 rounded-md hover:bg-blue-50 transition-colors flex items-center gap-1">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                                </svg>
                                Download
                            </button>
                            <button v-if="!image.isDefault" @click="deleteImage(image.id)" 
                                    class="text-red-600 hover:text-red-700 text-sm font-medium px-3 py-2 rounded-md hover:bg-red-50 transition-colors">
                                Delete
                            </button>
                            <span v-else class="text-gray-400 text-sm font-medium px-3 py-2">
                                System Default
                            </span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pagination -->
            <div v-if="pagination.pages > 1" class="mt-8 flex items-center justify-between">
                <div class="text-sm text-gray-700">
                    Showing {{ (pagination.page - 1) * pagination.limit + 1 }} to {{ Math.min(pagination.page * pagination.limit, pagination.total) }} of {{ pagination.total }} images
                </div>
                <div class="flex space-x-2">
                    <button @click="changePage(pagination.page - 1)" 
                            :disabled="pagination.page <= 1"
                            class="px-3 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed">
                        Previous
                    </button>
                    <button @click="changePage(pagination.page + 1)" 
                            :disabled="pagination.page >= pagination.pages"
                            class="px-3 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed">
                        Next
                    </button>
                </div>
            </div>
        </div>

        <!-- Upload Modal -->
        <div v-if="showUploadModal" class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg shadow-xl w-full max-w-2xl">
                <div class="flex justify-between items-center p-6 border-b">
                    <h3 class="text-lg font-medium text-gray-900">Upload Images</h3>
                    <button @click="showUploadModal = false" class="text-gray-400 hover:text-gray-500">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="p-6">
                    <!-- Drag & Drop Area -->
                    <div @drop="handleDrop" 
                         @dragover.prevent 
                         @dragenter.prevent
                         :class="{
                             'border-2 border-dashed rounded-lg p-8 text-center transition-colors': true,
                             'border-indigo-300 bg-indigo-50': isDragOver,
                             'border-gray-300': !isDragOver
                         }">
                        <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                        </svg>
                        <div class="mt-4">
                            <label for="file-upload" class="cursor-pointer bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition-colors">
                                Select Images
                            </label>
                            <input id="file-upload" 
                                   type="file" 
                                   multiple 
                                   accept="image/*" 
                                   @change="handleFileSelect" 
                                   class="hidden">
                        </div>
                        <p class="mt-2 text-sm text-gray-600">or drag and drop images here</p>
                        <p class="text-xs text-gray-500">PNG, JPG, GIF up to 5MB each</p>
                    </div>

                    <!-- Selected Files -->
                    <div v-if="selectedFiles.length > 0" class="mt-6">
                        <h4 class="text-sm font-medium text-gray-900 mb-3">Selected Files</h4>
                        <div class="space-y-3">
                            <div v-for="(file, index) in selectedFiles" :key="index" class="p-3 bg-gray-50 rounded-lg">
                                <div class="flex items-center space-x-3 mb-3">
                                    <img :src="file.preview" class="h-12 w-12 object-cover rounded">
                                    <div class="flex-1">
                                        <div class="text-sm font-medium text-gray-900">{{ file.name }}</div>
                                        <div class="text-xs text-gray-500">{{ formatFileSize(file.size) }}</div>
                                    </div>
                                    <button @click="removeFile(index)" class="text-red-600 hover:text-red-700">
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                        </svg>
                                    </button>
                                </div>
                                <div class="space-y-2">
                                    <div>
                                        <label class="block text-xs font-medium text-gray-700">Section</label>
                                        <select v-model="file.section" class="mt-1 block w-full border border-gray-300 rounded-md px-2 py-1 text-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                                            <option value="header">Header ({{ getImageDimensions('header') }})</option>
                                            <option value="banner">Banner ({{ getImageDimensions('banner') }})</option>
                                            <option value="body">Body ({{ getImageDimensions('body') }})</option>
                                            <option value="footer">Footer ({{ getImageDimensions('footer') }})</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label class="block text-xs font-medium text-gray-700">Tags (comma separated)</label>
                                        <input v-model="file.tags" type="text" placeholder="e.g., marketing, business, professional" class="mt-1 block w-full border border-gray-300 rounded-md px-2 py-1 text-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flex justify-end space-x-3 p-6 border-t">
                    <button @click="showUploadModal = false" class="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50">
                        Cancel
                    </button>
                    <button @click="uploadFiles" 
                            :disabled="uploading || selectedFiles.length === 0"
                            class="px-4 py-2 bg-indigo-600 text-white rounded-md text-sm font-medium hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed">
                        {{ uploading ? 'Uploading...' : 'Upload Images' }}
                    </button>
                </div>
            </div>
        </div>

        <!-- Edit Image Modal -->
        <div v-if="showEditModal" class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 p-4">
            <div class="bg-white rounded-lg shadow-xl w-full max-w-2xl">
                <div class="flex justify-between items-center p-6 border-b">
                    <h3 class="text-lg font-medium text-gray-900">Edit Image</h3>
                    <button @click="showEditModal = false" class="text-gray-400 hover:text-gray-500">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="p-6">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <!-- Image Preview -->
                        <div>
                            <img :src="normalizeImageUrl(editingImage.url)" :alt="editingImage.name" class="w-full rounded-lg">
                        </div>
                        
                        <!-- Edit Form -->
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Name</label>
                                <input v-model="editingImage.name" type="text" class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Description</label>
                                <textarea v-model="editingImage.description" rows="3" class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Section</label>
                                <select v-model="editingImage.section" class="mt-1 block w-full border border-gray-300 rounded-md px-3 py-2 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                                    <option value="header">Header ({{ getImageDimensions('header') }})</option>
                                    <option value="banner">Banner ({{ getImageDimensions('banner') }})</option>
                                    <option value="body">Body ({{ getImageDimensions('body') }})</option>
                                    <option value="footer">Footer ({{ getImageDimensions('footer') }})</option>
                                </select>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Tags</label>
                                <div class="mt-1 flex flex-wrap gap-2">
                                    <span v-for="tag in editingImage.tags" :key="tag" 
                                          class="inline-flex items-center px-2 py-1 rounded-full text-sm bg-indigo-100 text-indigo-800">
                                        {{ tag }}
                                        <button @click="removeTag(tag)" class="ml-1 text-indigo-600 hover:text-indigo-800">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                            </svg>
                                        </button>
                                    </span>
                                    <input v-model="newTag" 
                                           @keyup.enter="addTag"
                                           placeholder="Add tag..." 
                                           class="flex-1 min-w-0 border-0 focus:ring-0 text-sm">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flex justify-end space-x-3 p-6 border-t">
                    <button @click="showEditModal = false" class="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50">
                        Cancel
                    </button>
                    <button @click="saveImage" 
                            :disabled="saving"
                            class="px-4 py-2 bg-indigo-600 text-white rounded-md text-sm font-medium hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed">
                        {{ saving ? 'Saving...' : 'Save Changes' }}
                    </button>
                </div>
            </div>
        </div>

    </div>

    <script src="/js/utils/api.js"></script>
    <script src="/js/utils/shared.js"></script>
    <script src="/js/utils/imageUtils.js"></script>
    <script src="/js/components/Modal.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    // Images and pagination
                    images: [],
                    pagination: {
                        page: 1,
                        limit: 20,
                        total: 0,
                        pages: 0
                    },
                    
                    // Filters
                    selectedSection: 'all',
                    
                    // Categories and tags
                    availableTags: [],
                    
                    // UI state
                    loading: false,
                    showUploadModal: false,
                    showEditModal: false,
                    isDragOver: false,
                    
                    // Upload state
                    selectedFiles: [],
                    uploading: false,
                    
                    // Edit state
                    editingImage: {},
                    newTag: '',
                    saving: false,

                }
            },
            
            methods: {
                // URL normalization to handle different URL formats
                normalizeImageUrl(url) {
                    // Debug logging

                    if (typeof ImageUtils !== 'undefined' && ImageUtils.normalizeImageUrl) {
                        const result = ImageUtils.normalizeImageUrl(url);

                        return result;
                    }
                    
                    // Fallback implementation
                    if (!url) {

                        return '';
                    }
                    
                    // If it's already a full URL (starts with http/https), return as is
                    if (url.startsWith('http://') || url.startsWith('https://')) {

                        return url;
                    }
                    
                    // If it's a relative URL (starts with /), make it absolute
                    if (url.startsWith('/')) {
                        const result = window.location.origin + url;

                        return result;
                    }
                    
                    // If it's a relative URL without leading slash, add it
                    if (!url.startsWith('/')) {
                        const result = window.location.origin + '/' + url;

                        return result;
                    }

                    return url;
                },
                
                        // Handle image load errors
        handleImageError(event, image) {
            console.warn('Image failed to load:', image.url);

            image.error = true;
            image.loading = false;
            
            // Try to fix common URL issues
            if (image.url && !image.url.startsWith('http')) {
                const fixedUrl = this.normalizeImageUrl(image.url);
                if (fixedUrl !== image.url) {

                    image.url = fixedUrl;
                    // Don't retry immediately to avoid infinite loops
                }
            }
        },
        
        // Handle successful image load
        handleImageLoad(event, image) {

                    image.loading = false;
                    image.error = false;

                    // Force Vue to re-render
                    this.$forceUpdate();
                },
                
                        // Retry loading an image
        retryImageLoad(image) {
            image.loading = true;
            image.error = false;
            
            // Force a reload by adding a timestamp
            this.$nextTick(() => {
                const img = document.querySelector(`img[src*="${image.url}"]`);
                if (img) {
                    const currentSrc = img.src;
                    const separator = currentSrc.includes('?') ? '&' : '?';
                    img.src = currentSrc + separator + 'retry=' + Date.now();
                }
            });
        },
                
                // Load images
                async loadImages() {
                    this.loading = true;
                    try {
                        // Build query parameters
                        const params = new URLSearchParams();
                        if (this.selectedSection && this.selectedSection !== 'all') {
                            params.append('section', this.selectedSection);
                        }
                        
                        const response = await API.get(`/api/images?${params.toString()}`);
                        this.images = response.images || [];
                        
                        // Initialize image loading states and normalize tags
                        this.images.forEach(image => {
                            image.loading = true;
                            image.error = false;
                            image.newTag = ''; // Initialize tag input field
                            
                            // Normalize tags to always be an array
                            // Tags might come as a string (comma-separated) or array from the API
                            if (image.tags) {
                                if (typeof image.tags === 'string') {
                                    // Parse comma-separated string into array
                                    image.tags = image.tags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
                                } else if (!Array.isArray(image.tags)) {
                                    // If it's not a string or array, make it an empty array
                                    image.tags = [];
                                }
                            } else {
                                // If tags is undefined or null, set to empty array
                                image.tags = [];
                            }
                        });
                        
                        // Collect all unique tags for filter dropdown
                        const tagSet = new Set();
                        this.images.forEach(img => {
                            const tags = this.getImageTags(img);
                            tags.forEach(tag => tagSet.add(tag));
                        });
                        this.availableTags = Array.from(tagSet);
                        
                        // Debug: Check DOM after a short delay
                        setTimeout(() => {

                            const imgElements = document.querySelectorAll('img[src*="campaignbuilder.ca"]');

                            imgElements.forEach((img, index) => {

                                // Special check for the specific image mentioned
                                if (img.src.includes('1740039871281-header.png')) {
                                    // Image found
                                }
                            });
                            
                            // Check loading states

                            this.images.forEach((image, index) => {

                            });
                            
                            // Check for loading spinners
                            const loadingSpinners = document.querySelectorAll('.animate-spin');

                            // Check the actual rendered HTML

                            const imageContainers = document.querySelectorAll('.relative.bg-gray-100');

                            imageContainers.forEach((container, index) => {

                                const img = container.querySelector('img');
                                if (img) {
                                    const computedStyle = window.getComputedStyle(img);

                                    // Check if image is actually visible
                                    const rect = img.getBoundingClientRect();

                                }
                            });
                        }, 1000);
                    } catch (error) {
                        console.error('Error loading images:', error);
                        this.showToast('Failed to load images', 'error');
                    } finally {
                        this.loading = false;
                    }
                },

                // Change page
                changePage(page) {
                    this.pagination.page = page;
                    this.loadImages();
                },
                
                // File handling
                handleFileSelect(event) {
                    const files = Array.from(event.target.files);
                    this.addFiles(files);
                },
                
                handleDrop(event) {
                    event.preventDefault();
                    this.isDragOver = false;
                    
                    const files = Array.from(event.dataTransfer.files);
                    this.addFiles(files);
                },
                
                addFiles(files) {
                    files.forEach(file => {
                        if (file.type.startsWith('image/')) {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                this.selectedFiles.push({
                                    file: file,
                                    name: file.name,
                                    size: file.size,
                                    preview: e.target.result,
                                    section: 'body',
                                    tags: ''
                                });
                            };
                            reader.readAsDataURL(file);
                        }
                    });
                },
                
                removeFile(index) {
                    this.selectedFiles.splice(index, 1);
                },
                
                // Upload files
                async uploadFiles() {
                    this.uploading = true;
                    try {
                        for (const fileData of this.selectedFiles) {
                            // Ensure section is set (default to 'body' if not selected)
                            const section = fileData.section || 'body';
                            
                            // Ensure tags is a string (empty string if not provided)
                            const tags = (fileData.tags && fileData.tags.trim()) ? fileData.tags.trim() : '';
                            
                            // Upload with metadata
                            await API.uploadFile('/api/images/upload', fileData.file, null, {
                                name: fileData.name || fileData.file.name,
                                section: section,
                                tags: tags
                            });
                        }
                        
                        this.showToast('Images uploaded successfully', 'success');
                        this.showUploadModal = false;
                        this.selectedFiles = [];
                        this.loadImages();
                    } catch (error) {
                        console.error('Error uploading files:', error);
                        this.showToast('Failed to upload images', 'error');
                    } finally {
                        this.uploading = false;
                    }
                },
                
                // Edit image
                editImage(image) {
                    this.editingImage = { ...image };
                    // Ensure tags is an array
                    if (this.editingImage.tags) {
                        if (typeof this.editingImage.tags === 'string') {
                            this.editingImage.tags = this.editingImage.tags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
                        } else if (!Array.isArray(this.editingImage.tags)) {
                            this.editingImage.tags = [];
                        }
                    } else {
                        this.editingImage.tags = [];
                    }
                    this.showEditModal = true;
                },
                
                addTag() {
                    if (this.newTag.trim() && !this.editingImage.tags.includes(this.newTag.trim())) {
                        this.editingImage.tags.push(this.newTag.trim());
                        this.newTag = '';
                    }
                },
                
                removeTag(tag) {
                    const index = this.editingImage.tags.indexOf(tag);
                    if (index > -1) {
                        this.editingImage.tags.splice(index, 1);
                    }
                },
                
                async saveImage() {
                    this.saving = true;
                    try {
                        await API.put(`/api/images/${this.editingImage.id}`, {
                            name: this.editingImage.name,
                            description: this.editingImage.description,
                            section: this.editingImage.section,
                            tags: this.editingImage.tags
                        });
                        
                        this.showToast('Image updated successfully', 'success');
                        this.showEditModal = false;
                        this.loadImages();
                    } catch (error) {
                        console.error('Error saving image:', error);
                        this.showToast('Failed to update image', 'error');
                    } finally {
                        this.saving = false;
                    }
                },
                
                // Delete image
                async deleteImage(imageId) {
                    if (!confirm('Are you sure you want to delete this image?')) return;
                    
                    try {
                        await API.delete(`/api/images/${imageId}`);
                        this.showToast('Image deleted successfully', 'success');
                        this.loadImages();
                    } catch (error) {
                        console.error('Error deleting image:', error);
                        this.showToast('Failed to delete image', 'error');
                    }
                },

                // Download image from library
                async downloadImageFromLibrary(image) {
                    try {
                        this.showToast('Preparing download...', 'info');
                        
                        // Use server-side download endpoint to handle CORS and file serving
                        const token = localStorage.getItem('token');
                        const response = await fetch(`/api/images/${image.id}/download`, {
                            method: 'GET',
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });
                        
                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.error || 'Failed to download image');
                        }
                        
                        // Get the blob from response
                        const blob = await response.blob();
                        
                        // Get filename from Content-Disposition header or use image name
                        const contentDisposition = response.headers.get('Content-Disposition');
                        let filename = image.name || 'image';
                        
                        if (contentDisposition) {
                            const filenameMatch = contentDisposition.match(/filename="?(.+?)"?$/);
                            if (filenameMatch) {
                                filename = filenameMatch[1];
                            }
                        } else {
                            // Fallback: construct filename from image name and extension
                            const imageUrl = this.normalizeImageUrl(image.url);
                            try {
                                const urlPath = new URL(imageUrl).pathname;
                                const extension = urlPath.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i)?.[0] || '.jpg';
                                filename = (image.name || 'image').replace(/[^a-z0-9]/gi, '_').toLowerCase() + extension;
                            } catch (e) {
                                // If URL parsing fails, use default
                                filename = (image.name || 'image').replace(/[^a-z0-9]/gi, '_').toLowerCase() + '.jpg';
                            }
                        }
                        
                        // Create a download link
                        const url = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = filename;
                        
                        // Trigger download
                        document.body.appendChild(link);
                        link.click();
                        
                        // Cleanup
                        setTimeout(() => {
                            document.body.removeChild(link);
                            window.URL.revokeObjectURL(url);
                        }, 100);
                        
                        this.showToast(`Image "${image.name}" downloaded successfully!`, 'success');
                    } catch (error) {
                        console.error('Download error:', error);
                        this.showToast('Failed to download image: ' + error.message, 'error');
                    }
                },
                
                // Use image (placeholder for template integration)
                useImage(image) {
                    // This will be integrated with template editor
                    this.showToast('Image selected for use in template', 'success');
                },

                // Utility methods
                formatFileSize(bytes) {
                    if (typeof ImageUtils !== 'undefined' && ImageUtils.formatFileSize) {
                        return ImageUtils.formatFileSize(bytes);
                    }
                    
                    // Fallback in case FileUtils is not loaded
                    if (typeof FileUtils !== 'undefined' && FileUtils.formatFileSize) {
                        return FileUtils.formatFileSize(bytes);
                    }
                    
                    // Fallback implementation
                    if (bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                },
                
                showToast(message, type = 'info') {
                    // Fallback in case ToastSystem is not loaded
                    if (typeof ToastSystem !== 'undefined' && ToastSystem.show) {
                        ToastSystem.show(message, type);
                    } else {
                        // Fallback to alert
                        alert(message);
                    }
                },
                
                getImageDimensions(type) {
                    // Fallback in case ImageConfig is not loaded
                    if (typeof ImageConfig !== 'undefined' && ImageConfig.getDimensions) {
                        return ImageConfig.getDimensions(type);
                    }
                    
                    // Fallback dimensions
                    const dimensions = {
                        header: '1200×400px',
                        banner: '1200×300px',
                        body: '800×600px',
                        footer: '600×200px'
                    };
                    return dimensions[type] || '1024×1024px';
                },
                
                // Normalize tags to always return an array
                getImageTags(image) {
                    if (!image || !image.tags) return [];
                    
                    // If tags is already an array, return it
                    if (Array.isArray(image.tags)) {
                        return image.tags.filter(tag => tag && tag.trim().length > 0);
                    }
                    
                    // If tags is a string, parse it
                    if (typeof image.tags === 'string') {
                        return image.tags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
                    }
                    
                    // Otherwise return empty array
                    return [];
                },
                
                // Add tags to an image directly from the thumbnail
                async addTagToImage(image) {
                    if (!image.newTag || !image.newTag.trim()) return;
                    
                    const newTags = image.newTag.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
                    if (newTags.length === 0) return;
                    
                    // Get current tags
                    const currentTags = this.getImageTags(image);
                    
                    // Add new tags that don't already exist
                    const tagsToAdd = newTags.filter(tag => !currentTags.includes(tag));
                    if (tagsToAdd.length === 0) {
                        image.newTag = '';
                        return;
                    }
                    
                    // Combine existing and new tags
                    const updatedTags = [...currentTags, ...tagsToAdd];
                    
                    try {
                        // Update the image via API
                        await API.put(`/api/images/${image.id}`, {
                            tags: updatedTags
                        });
                        
                        // Update local image object
                        image.tags = updatedTags;
                        image.newTag = '';
                        
                        this.showToast('Tags added successfully', 'success');
                    } catch (error) {
                        console.error('Error adding tags:', error);
                        this.showToast('Failed to add tags', 'error');
                    }
                },
                
                // Remove a tag from an image directly from the thumbnail
                async removeTagFromImage(image, tagToRemove) {
                    const currentTags = this.getImageTags(image);
                    const updatedTags = currentTags.filter(tag => tag !== tagToRemove);
                    
                    try {
                        // Update the image via API
                        await API.put(`/api/images/${image.id}`, {
                            tags: updatedTags
                        });
                        
                        // Update local image object
                        image.tags = updatedTags;
                        
                        this.showToast('Tag removed successfully', 'success');
                    } catch (error) {
                        console.error('Error removing tag:', error);
                        this.showToast('Failed to remove tag', 'error');
                    }
                }
            },
            
            async mounted() {
                await this.loadImages();
            }
        }).mount('#app');
    </script>
</body>
</html> 